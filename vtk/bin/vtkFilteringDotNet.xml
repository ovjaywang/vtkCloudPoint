<?xml version="1.0"?>
<doc>
    <assembly>
        "vtkFilteringDotNet"
    </assembly>
    <members>
        <member name="M:vtk.vtkSimpleCellTessellator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.SetSubdivisionLevels(System.Int32,System.Int32)">
            <summary>
                <para>Set both the number of fixed subdivisions and the maximum level of subdivisions. See GetFixedSubdivisions(), GetMaxSubdivisionLevel() and GetMaxAdaptiveSubdivisions() for more explanations. \pre positive_fixed: fixed&gt;=0 \pre valid_range: fixed&lt;=maxLevel \post fixed_is_set: fixed==GetFixedSubdivisions() \post maxLevel_is_set: maxLevel==GetMaxSubdivisionLevel()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.SetMaxSubdivisionLevel(System.Int32)">
            <summary>
                <para>Set the maximum level of subdivision. See GetMaxSubdivisionLevel() for more explanations. \pre positive_level: level&gt;=GetFixedSubdivisions() \post is_set: level==GetMaxSubdivisionLevel()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.SetFixedSubdivisions(System.Int32)">
            <summary>
                <para>Set the number of fixed subdivisions. See GetFixedSubdivisions() for more explanations. \pre positive_level: level&gt;=0 &amp;&amp; level&lt;=GetMaxSubdivisionLevel() \post is_set: GetFixedSubdivisions()==level</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.GetMaxAdaptiveSubdivisions">
            <summary>
                <para>Return the maximum number of adaptive subdivisions. \post valid_result: result==GetMaxSubdivisionLevel()-GetFixedSubdivisions()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.GetMaxSubdivisionLevel">
            <summary>
                <para>Return the maximum level of subdivision. It is used to prevent from infinite loop in degenerated cases. For order 3 or higher, if the inflection point is exactly on the mid-point, error metric will not detect that a subdivision is required. 0 means no subdivision, neither fixed nor adaptive. \post positive_result: result&gt;=GetFixedSubdivisions()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.GetFixedSubdivisions">
            <summary>
                <para>Return the number of fixed subdivisions. It is used to prevent from infinite loop in degenerated cases. For order 3 or higher, if the inflection point is exactly on the mid-point, error metric will not detect that a subdivision is required. 0 means no fixed subdivision: there will be only adaptive subdivisions.</para>
                <para>The algorithm first performs `GetFixedSubdivisions' non adaptive subdivisions followed by at most `GetMaxAdaptiveSubdivisions' adaptive subdivisions. Hence, there are at most `GetMaxSubdivisionLevel' subdivisions. \post positive_result: result&gt;=0 &amp;&amp; result&lt;=GetMaxSubdivisionLevel()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.Initialize(vtk.vtkGenericDataSet)">
            <summary>
                <para>Initialize the tessellator with a data set `ds'.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.Reset">
            <summary>
                <para>Reset the output for repeated use of this class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.Triangulate(vtk.vtkGenericAdaptorCell,vtk.vtkGenericAttributeCollection,vtk.vtkDoubleArray,vtk.vtkCellArray,vtk.vtkPointData)">
            <summary>
                <para>Triangulate a 2D `cell'. The result is a set of smaller linear triangles in `cellArray' with `points' and point data `internalPd'. \pre cell_exists: cell!=0 \pre valid_dimension: cell-&gt;GetDimension()==2 \pre att_exists: att!=0 \pre points_exists: points!=0 \pre cellArray_exists: cellArray!=0 \pre internalPd_exists: internalPd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.Tessellate(vtk.vtkGenericAdaptorCell,vtk.vtkGenericAttributeCollection,vtk.vtkDoubleArray,vtk.vtkCellArray,vtk.vtkPointData)">
            <summary>
                <para>Tessellate a 3D `cell'. The result is a set of smaller linear tetrahedra in `cellArray' with `points' and point data `internalPd'. \pre cell_exists: cell!=0 \pre valid_dimension: cell-&gt;GetDimension()==3 \pre att_exists: att!=0 \pre points_exists: points!=0 \pre cellArray_exists: cellArray!=0 \pre internalPd_exists: internalPd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.TessellateFace(vtk.vtkGenericAdaptorCell,vtk.vtkGenericAttributeCollection,System.Int32,vtk.vtkDoubleArray,vtk.vtkCellArray,vtk.vtkPointData)">
            <summary>
                <para>Tessellate a face of a 3D `cell'. The face is specified by the index value. The result is a set of smaller linear triangles in `cellArray' with `points' and point data `internalPd'. \pre cell_exists: cell!=0 \pre valid_dimension: cell-&gt;GetDimension()==3 \pre valid_index_range: (index&gt;=0) &amp;&amp; (index&lt;cell-&gt;GetNumberOfBoundaries(2)) \pre att_exists: att!=0 \pre points_exists: points!=0 \pre cellArray_exists: cellArray!=0 \pre internalPd_exists: internalPd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleCellTessellator.GetGenericCell">
            <summary>
                <para>Get the higher order cell in order to access the evaluation function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTrivialProducer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTrivialProducer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTrivialProducer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTrivialProducer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTrivialProducer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTrivialProducer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTrivialProducer.GetMTime">
            <summary>
                <para>The modified time of this producer is the newer of this object or the assigned output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTrivialProducer.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Set the data object that is "produced" by this producer.  It is never really modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputOutputFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputOutputFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputOutputFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageMultipleInputOutputFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputOutputFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputOutputFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputOutputFilter.GetOutput">
            <summary>
                <para>Get one input to this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputOutputFilter.GetOutput(System.Int32)">
            <summary>
                <para>Get one input to this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToStructuredPointsFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToStructuredPointsFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToStructuredPointsFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredPointsToStructuredPointsFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToStructuredPointsFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToStructuredPointsFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToStructuredPointsFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToStructuredPointsFilter.SetInput(vtk.vtkImageData)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCell3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.GetDataSet">
            <summary>
                <para>Set the data object to iterator over.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.SetDataSet(vtk.vtkHierarchicalDataSet)">
            <summary>
                <para>Set the data object to iterator over.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.GetCurrentDataObject">
            <summary>
                <para>Get the current item. Valid only when IsDoneWithTraversal() returns 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.IsDoneWithTraversal">
            <summary>
                <para>Test whether the iterator is currently pointing to a valid item. Returns 1 for yes, 0 for no.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.GoToNextItem">
            <summary>
                <para>Move the iterator to the next item in the collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataIterator.GoToFirstItem">
            <summary>
                <para>Move the iterator to the beginning of the collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCone.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCone.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCone.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCone.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCone.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCone.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCone.GetAngle">
            <summary>
                <para>Set/Get the cone angle (expressed in degrees).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCone.GetAngleMaxValue">
            <summary>
                <para>Set/Get the cone angle (expressed in degrees).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCone.GetAngleMinValue">
            <summary>
                <para>Set/Get the cone angle (expressed in degrees).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCone.SetAngle(System.Double)">
            <summary>
                <para>Set/Get the cone angle (expressed in degrees).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.CopyParameters(vtk.vtkGenericInterpolatedVelocityField)">
            <summary>
                <para>Copy the user set parameters from source. This copies the Caching parameters. Sub-classes can add more after chaining.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.GetLastDataSet">
            <summary>
                <para>Returns the last dataset that was visited. Can be used as a first guess as to where the next point will be as well as to avoid searching through all datasets to get more information about the point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.SelectVectors(System.String)">
            <summary>
                <para>Returns the last dataset that was visited. Can be used as a first guess as to where the next point will be as well as to avoid searching through all datasets to get more information about the point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.GetVectorsSelection">
            <summary>
                <para>If you want to work with an arbitrary vector array, then set its name  here. By default this in NULL and the filter will use the active vector  array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.GetCacheMiss">
            <summary>
                <para>Caching statistics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.GetCacheHit">
            <summary>
                <para>Caching statistics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.CachingOff">
            <summary>
                <para>Turn caching on/off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.CachingOn">
            <summary>
                <para>Turn caching on/off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.SetCaching(System.Int32)">
            <summary>
                <para>Turn caching on/off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.GetCaching">
            <summary>
                <para>Turn caching on/off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.GetLastLocalCoordinates(System.Double[])">
            <summary>
                <para>Returns the interpolation weights cached from last evaluation if the cached cell is valid (returns 1). Otherwise, it does not change w and returns 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.GetLastCell">
            <summary>
                <para>Return the cell cached from last evaluation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.ClearLastCell">
            <summary>
                <para>Set the last cell id to -1 so that the next search does not start from the previous cell</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.AddDataSet(vtk.vtkGenericDataSet)">
            <summary>
                <para>Add a dataset used for the implicit function evaluation. If more than one dataset is added, the evaluation point is searched in all until a match is found. THIS FUNCTION DOES NOT CHANGE THE REFERENCE COUNT OF dataset FOR THREAD SAFETY REASONS.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericInterpolatedVelocityField.FunctionValues(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate the velocity field, f, at (x, y, z, t). For now, t is ignored.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSphere.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSphere.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSphere.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSphere.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSphere.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSphere.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSphere.GetCenter">
            <summary>
                <para>Set / get the center of the sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphere.SetCenter(System.Double[])">
            <summary>
                <para>Set / get the center of the sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphere.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the center of the sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphere.GetRadius">
            <summary>
                <para>Set / get the radius of the sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphere.SetRadius(System.Double)">
            <summary>
                <para>Set / get the radius of the sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExecutive.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExecutive.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Hexagonal prism specific</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Hexagonal prism specific</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the wedge in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexagonalPrism.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.GetNextTetra(System.Int32,vtk.vtkTetra,vtk.vtkDataArray,vtk.vtkDoubleArray)">
            <summary>
                <para>Methods to get one tetra at a time. Start with InitTetraTraversal() and then invoke GetNextTetra() until the method returns 0. cellScalars are point-centered scalars on the original cell. tetScalars are point-centered scalars on the tetra: the values will be copied from cellScalars. \pre tet_exists: tet!=0 \pre cellScalars_exists: cellScalars!=0 \pre tetScalars_exists: tetScalars!=0 \pre tetScalars_valid_size: tetScalars-&gt;GetNumberOfTuples()==4</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.InitTetraTraversal">
            <summary>
                <para>Methods to get one tetra at a time. Start with InitTetraTraversal() and then invoke GetNextTetra() until the method returns 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.AddTriangles(System.Int32,vtk.vtkCellArray)">
            <summary>
                <para>Add the triangle faces classified (2=boundary) and attached to the specified point id to the connectivity list provided. (The id is the same as that specified in InsertPoint().)  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.AddTriangles(vtk.vtkCellArray)">
            <summary>
                <para>Add the triangle faces classified (2=boundary) to the connectivity list provided. The method returns the number of triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.AddTetras(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>Add the tetrahedra classified (0=inside,1=outside) to the list of ids and coordinates provided. These assume that the first four points form a tetrahedron, the next four the next, and so on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.AddTetras(System.Int32,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>Assuming that all the inserted points come from a cell `cellId' to triangulate, get the tetrahedra in outConnectivity, the points in locator and copy point data and cell data. Return the number of added tetras. \pre locator_exists: locator!=0 \pre outConnectivity: outConnectivity!=0 \pre inPD_exists: inPD!=0 \pre outPD_exists:  outPD!=0 \pre inCD_exists: inCD!=0 \pre outCD_exists: outCD!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.AddTetras(System.Int32,vtk.vtkCellArray)">
            <summary>
                <para>Add the tetrahedra classified (0=inside,1=outside) to the connectivity list provided. Inside tetrahedron are those whose points are all classified "inside." Outside tetrahedron have at least one point classified "outside." The method returns the number of tetrahedron of the type requested.    </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.AddTetras(System.Int32,vtk.vtkUnstructuredGrid)">
            <summary>
                <para>Add the tetras to the unstructured grid provided. The unstructured grid is assumed to have been initialized (with Allocate()) and points set (with SetPoints()). The tetrahdera added are of the type specified (0=inside,1=outside,2=all). Inside tetrahedron are  those whose points are classified "inside" or on the "boundary."  Outside tetrahedron have at least one point classified "outside."  The method returns the number of tetrahedrahedron of the type  requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.GetTetras(System.Int32,vtk.vtkUnstructuredGrid)">
            <summary>
                <para>Initialize and add the tetras and points from the triangulation to the unstructured grid provided.  New points are created and the mesh is allocated. (This method differs from AddTetras() in that it inserts points and cells; AddTetras only adds the tetra cells.) The tetrahdera added are of the type specified (0=inside,1=outside,2=all). Inside tetrahedron are those whose points are classified "inside" or on the "boundary."  Outside tetrahedron have at least one point classified "outside."  The method returns the number of tetrahedrahedron of the type requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.UseTwoSortIdsOff">
            <summary>
                <para>Tells the triangulator that a second sort id is provided for each point and should also be considered when sorting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.UseTwoSortIdsOn">
            <summary>
                <para>Tells the triangulator that a second sort id is provided for each point and should also be considered when sorting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.GetUseTwoSortIds">
            <summary>
                <para>Tells the triangulator that a second sort id is provided for each point and should also be considered when sorting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.SetUseTwoSortIds(System.Int32)">
            <summary>
                <para>Tells the triangulator that a second sort id is provided for each point and should also be considered when sorting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.PreSortedOff">
            <summary>
                <para>Boolean indicates whether the points have been pre-sorted. If  pre-sorted is enabled, the points are not sorted on point id. By default, presorted is off. (The point id is defined in InsertPoint().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.PreSortedOn">
            <summary>
                <para>Boolean indicates whether the points have been pre-sorted. If  pre-sorted is enabled, the points are not sorted on point id. By default, presorted is off. (The point id is defined in InsertPoint().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.GetPreSorted">
            <summary>
                <para>Boolean indicates whether the points have been pre-sorted. If  pre-sorted is enabled, the points are not sorted on point id. By default, presorted is off. (The point id is defined in InsertPoint().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.SetPreSorted(System.Int32)">
            <summary>
                <para>Boolean indicates whether the points have been pre-sorted. If  pre-sorted is enabled, the points are not sorted on point id. By default, presorted is off. (The point id is defined in InsertPoint().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.UseTemplatesOff">
            <summary>
                <para>If this flag is set, then the ordered triangulator will create and use templates for the triangulation. To use templates, the TemplateTriangulate() method should be called when appropriate. (Note: the TemplateTriangulate() method works for complete  (interior) cells without extra points due to intersection, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.UseTemplatesOn">
            <summary>
                <para>If this flag is set, then the ordered triangulator will create and use templates for the triangulation. To use templates, the TemplateTriangulate() method should be called when appropriate. (Note: the TemplateTriangulate() method works for complete  (interior) cells without extra points due to intersection, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.GetUseTemplates">
            <summary>
                <para>If this flag is set, then the ordered triangulator will create and use templates for the triangulation. To use templates, the TemplateTriangulate() method should be called when appropriate. (Note: the TemplateTriangulate() method works for complete  (interior) cells without extra points due to intersection, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.SetUseTemplates(System.Int32)">
            <summary>
                <para>If this flag is set, then the ordered triangulator will create and use templates for the triangulation. To use templates, the TemplateTriangulate() method should be called when appropriate. (Note: the TemplateTriangulate() method works for complete  (interior) cells without extra points due to intersection, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.GetNumberOfPoints">
            <summary>
                <para>Return the number of inserted points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.GetPointId(System.Int32)">
            <summary>
                <para>Return the Id of point `internalId'. This id is the one passed in argument of InsertPoint. It assumes that the point has already been inserted. The method should be invoked prior to the Triangulate method. \pre valid_range: internalId&gt;=0 &amp;&amp; internalId&lt;this-&gt;GetNumberOfPoints()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.UpdatePointType(System.Int32,System.Int32)">
            <summary>
                <para>Update the point type. This is useful when the merging of nearly  coincident points is performed. The id is the internal id returned from InsertPoint(). The method should be invoked prior to the Triangulate method. The type is specified as inside (type=0),  outside (type=1), or on the boundary (type=2). \pre valid_range: internalId&gt;=0 &amp;&amp; internalId&lt;this-&gt;GetNumberOfPoints()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.TemplateTriangulate(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Perform the triangulation. (Complete all calls to InsertPoint() prior to invoking this method.) A special version is available when templates should be used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.Triangulate">
            <summary>
                <para>Perform the triangulation. (Complete all calls to InsertPoint() prior to invoking this method.) A special version is available when templates should be used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.InsertPoint(System.Int32,System.Int32,System.Int32,System.Double[],System.Double[],System.Int32)">
            <summary>
                <para>For each point to be inserted, provide an id, a position x, parametric coordinate p, and whether the point is inside (type=0), outside (type=1), or on the boundary (type=2). You must call InitTriangulation() prior to invoking this method. Make sure that the number of points inserted does not exceed the numPts specified in InitTriangulation(). Also note that the "id" can be any integer and can be greater than numPts. It is used to create tetras (in AddTetras()) with the appropriate connectivity ids. The method returns an internal id that can be used prior to the Triangulate() method to update the type of the point with UpdatePointType(). (Note: the algorithm triangulated with the parametric coordinate p[3] and creates tetras with the global coordinate x[3]. The parametric coordinates and global coordinates may be the same.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.InsertPoint(System.Int32,System.Int32,System.Double[],System.Double[],System.Int32)">
            <summary>
                <para>For each point to be inserted, provide an id, a position x, parametric coordinate p, and whether the point is inside (type=0), outside (type=1), or on the boundary (type=2). You must call InitTriangulation() prior to invoking this method. Make sure that the number of points inserted does not exceed the numPts specified in InitTriangulation(). Also note that the "id" can be any integer and can be greater than numPts. It is used to create tetras (in AddTetras()) with the appropriate connectivity ids. The method returns an internal id that can be used prior to the Triangulate() method to update the type of the point with UpdatePointType(). (Note: the algorithm triangulated with the parametric coordinate p[3] and creates tetras with the global coordinate x[3]. The parametric coordinates and global coordinates may be the same.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.InsertPoint(System.Int32,System.Double[],System.Double[],System.Int32)">
            <summary>
                <para>For each point to be inserted, provide an id, a position x, parametric coordinate p, and whether the point is inside (type=0), outside (type=1), or on the boundary (type=2). You must call InitTriangulation() prior to invoking this method. Make sure that the number of points inserted does not exceed the numPts specified in InitTriangulation(). Also note that the "id" can be any integer and can be greater than numPts. It is used to create tetras (in AddTetras()) with the appropriate connectivity ids. The method returns an internal id that can be used prior to the Triangulate() method to update the type of the point with UpdatePointType(). (Note: the algorithm triangulated with the parametric coordinate p[3] and creates tetras with the global coordinate x[3]. The parametric coordinates and global coordinates may be the same.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.InitTriangulation(System.Double[],System.Int32)">
            <summary>
                <para>Initialize the triangulation process. Provide a bounding box and the maximum number of points to be inserted. Note that since the triangulation is performed using parametric coordinates (see InsertPoint()) the bounds should be represent the range of the parametric coordinates inserted. \post no_point_inserted: GetNumberOfPoints()==0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOrderedTriangulator.InitTriangulation(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
                <para>Initialize the triangulation process. Provide a bounding box and the maximum number of points to be inserted. Note that since the triangulation is performed using parametric coordinates (see InsertPoint()) the bounds should be represent the range of the parametric coordinates inserted. \post no_point_inserted: GetNumberOfPoints()==0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredPointsCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsCollection.GetNextItem">
            <summary>
                <para>Get the next item in the collection. NULL is returned if the collection is exhausted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsCollection.AddItem(vtk.vtkStructuredPoints)">
            <summary>
                <para>Add a pointer to a vtkStructuredPoints to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCoordinate.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.GetError(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Return the error at the mid-point. It will return an error relative to the bounding box size if GetRelative() is true, a square absolute error otherwise. See RequiresEdgeSubdivision() for a description of the arguments. \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6 \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.RequiresEdgeSubdivision(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Does the edge need to be subdivided according to the cosine between the two chords passing through the mid-point and the endpoints? The edge is defined by its `leftPoint' and its `rightPoint'. `leftPoint', `midPoint' and `rightPoint' have to be initialized before calling RequiresEdgeSubdivision(). Their format is global coordinates, parametric coordinates and point centered attributes: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.SetAngleTolerance(System.Double)">
            <summary>
                <para>Set the flatness threshold with an angle in degrees. Internally compute the cosine. value is supposed to be in ]90,180[, if not it is clamped in [90.1,179.9]. For instance 178  will give better result than 150.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.GetAngleTolerance">
            <summary>
                <para>Return the flatness threshold. \post positive_result: result&gt;90 &amp;&amp; result&lt;180</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.NewInstance">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.IsA(System.String)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothErrorMetric.GetClassName">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointLocator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointLocator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.GetMTime">
            <summary>
                <para>Overload GetMTime() because we depend on the Loop</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.GetNormal">
            <summary>
                <para>Set / get the normal used to determine what is inside and what is outside.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.SetNormal(System.Double[])">
            <summary>
                <para>Set / get the normal used to determine what is inside and what is outside.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.SetNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the normal used to determine what is inside and what is outside.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.AutomaticNormalGenerationOff">
            <summary>
                <para>Turn on/off automatic normal generation. By default, the normal is computed from the accumulated cross product of the edges. You can also specify the normal to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.AutomaticNormalGenerationOn">
            <summary>
                <para>Turn on/off automatic normal generation. By default, the normal is computed from the accumulated cross product of the edges. You can also specify the normal to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.GetAutomaticNormalGeneration">
            <summary>
                <para>Turn on/off automatic normal generation. By default, the normal is computed from the accumulated cross product of the edges. You can also specify the normal to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.SetAutomaticNormalGeneration(System.Int32)">
            <summary>
                <para>Turn on/off automatic normal generation. By default, the normal is computed from the accumulated cross product of the edges. You can also specify the normal to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.GetLoop">
            <summary>
                <para>Set/Get the array of point coordinates defining the loop. There must be at least three points used to define a loop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.SetLoop(vtk.vtkPoints)">
            <summary>
                <para>Set/Get the array of point coordinates defining the loop. There must be at least three points used to define a loop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.EvaluateGradient(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate selection loop returning the gradient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.EvaluateFunction(System.Double,System.Double,System.Double)">
            <summary>
                <para>Evaluate selection loop returning a signed distance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSelectionLoop.EvaluateFunction(System.Double[])">
            <summary>
                <para>Evaluate selection loop returning a signed distance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataCollection.GetNextItem">
            <summary>
                <para>Get the next poly data in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataCollection.AddItem(vtk.vtkPolyData)">
            <summary>
                <para>Add a poly data to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Participate in garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Participate in garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.GetMTime">
            <summary>
                <para>Override modified time retrieval because of object dependencies.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.GetWindowValues">
            <summary>
                <para>Specify the range of output values that the window range is mapped into. This is effectively a scaling and shifting of the original function values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.SetWindowValues(System.Double[])">
            <summary>
                <para>Specify the range of output values that the window range is mapped into. This is effectively a scaling and shifting of the original function values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.SetWindowValues(System.Double,System.Double)">
            <summary>
                <para>Specify the range of output values that the window range is mapped into. This is effectively a scaling and shifting of the original function values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.GetWindowRange">
            <summary>
                <para>Specify the range of function values which are considered to lie within the window. WindowRange[0] is assumed to be less than WindowRange[1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.SetWindowRange(System.Double[])">
            <summary>
                <para>Specify the range of function values which are considered to lie within the window. WindowRange[0] is assumed to be less than WindowRange[1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.SetWindowRange(System.Double,System.Double)">
            <summary>
                <para>Specify the range of function values which are considered to lie within the window. WindowRange[0] is assumed to be less than WindowRange[1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.GetImplicitFunction">
            <summary>
                <para>Specify an implicit function to operate on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitWindowFunction.SetImplicitFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Specify an implicit function to operate on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredPointsFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredPointsFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredPointsFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredPointsFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredPointsFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredPointsFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredPointsFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredPointsFilter.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToUnstructuredGridFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToUnstructuredGridFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToUnstructuredGridFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetToUnstructuredGridFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetToUnstructuredGridFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToUnstructuredGridFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToUnstructuredGridFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToUnstructuredGridFilter.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.GetMaxErrors(System.Double[])">
            <summary>
                <para>Get the maximum error measured after the fixed subdivision. \pre errors_exists: errors!=0 \pre valid_size: sizeof(errors)==GetErrorMetrics()-&gt;GetNumberOfItems()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.SetMeasurement(System.Int32)">
            <summary>
                <para>If true, measure the quality of the fixed subdivision.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.GetMeasurement">
            <summary>
                <para>If true, measure the quality of the fixed subdivision.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.InitErrorMetrics(vtk.vtkGenericDataSet)">
            <summary>
                <para>Init the error metric with the dataset. Should be called in each filter before any tessellation of any cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.Initialize(vtk.vtkGenericDataSet)">
            <summary>
                <para>Initialize the tessellator with a data set `ds'.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.GetErrorMetrics">
            <summary>
                <para>Specify the list of error metrics used to decide if an edge has to be splitted or not. It is a collection of vtkGenericSubdivisionErrorMetric-s.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.SetErrorMetrics(vtk.vtkCollection)">
            <summary>
                <para>Specify the list of error metrics used to decide if an edge has to be splitted or not. It is a collection of vtkGenericSubdivisionErrorMetric-s.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.Triangulate(vtk.vtkGenericAdaptorCell,vtk.vtkGenericAttributeCollection,vtk.vtkDoubleArray,vtk.vtkCellArray,vtk.vtkPointData)">
            <summary>
                <para>Triangulate a 2D `cell'. The result is a set of smaller linear triangles in `cellArray' with `points' and point data `internalPd'. \pre cell_exists: cell!=0 \pre valid_dimension: cell-&gt;GetDimension()==2 \pre att_exists: att!=0 \pre points_exists: points!=0 \pre cellArray_exists: cellArray!=0 \pre internalPd_exists: internalPd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.Tessellate(vtk.vtkGenericAdaptorCell,vtk.vtkGenericAttributeCollection,vtk.vtkDoubleArray,vtk.vtkCellArray,vtk.vtkPointData)">
            <summary>
                <para>Tessellate a 3D `cell'. The result is a set of smaller linear tetrahedra in `cellArray' with `points' and point data `internalPd'. \pre cell_exists: cell!=0 \pre valid_dimension: cell-&gt;GetDimension()==3 \pre att_exists: att!=0 \pre points_exists: points!=0 \pre cellArray_exists: cellArray!=0 \pre internalPd_exists: internalPd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellTessellator.TessellateFace(vtk.vtkGenericAdaptorCell,vtk.vtkGenericAttributeCollection,System.Int32,vtk.vtkDoubleArray,vtk.vtkCellArray,vtk.vtkPointData)">
            <summary>
                <para>Tessellate a face of a 3D `cell'. The face is specified by the index value. The result is a set of smaller linear triangles in `cellArray' with `points' and point data `internalPd'. \pre cell_exists: cell!=0 \pre valid_dimension: cell-&gt;GetDimension()==3 \pre valid_index_range: (index&gt;=0) &amp;&amp; (index&lt;cell-&gt;GetNumberOfBoundaries(2)) \pre att_exists: att!=0 \pre points_exists: points!=0 \pre cellArray_exists: cellArray!=0 \pre internalPd_exists: internalPd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCell.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkActor2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkActor2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCoordinate.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCoordinate.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCoordinate.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCoordinate.GetComputedLocalDisplayValue(vtk.vtkViewport)">
            <summary>
                <para>Return the computed value in a specified coordinate system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.GetComputedDisplayValue(vtk.vtkViewport)">
            <summary>
                <para>Return the computed value in a specified coordinate system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.GetComputedViewportValue(vtk.vtkViewport)">
            <summary>
                <para>Return the computed value in a specified coordinate system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.GetComputedWorldValue(vtk.vtkViewport)">
            <summary>
                <para>Return the computed value in a specified coordinate system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.GetViewport">
            <summary>
                <para>If you want this coordinate to be relative to a specific vtkViewport (vtkRenderer) then you can specify that here.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetViewport(vtk.vtkViewport)">
            <summary>
                <para>If you want this coordinate to be relative to a specific vtkViewport (vtkRenderer) then you can specify that here.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.GetReferenceCoordinate">
            <summary>
                <para>If this coordinate is relative to another coordinate, then specify that coordinate as the ReferenceCoordinate. If this is NULL the coordinate is assumed to be absolute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetReferenceCoordinate(vtk.vtkCoordinate)">
            <summary>
                <para>If this coordinate is relative to another coordinate, then specify that coordinate as the ReferenceCoordinate. If this is NULL the coordinate is assumed to be absolute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetValue(System.Double,System.Double)">
            <summary>
                <para>If this coordinate is relative to another coordinate, then specify that coordinate as the ReferenceCoordinate. If this is NULL the coordinate is assumed to be absolute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.GetValue">
            <summary>
                <para>Set/get the value of this coordinate. This can be thought of as the position of this coordinate in its coordinate system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetValue(System.Double[])">
            <summary>
                <para>Set/get the value of this coordinate. This can be thought of as the position of this coordinate in its coordinate system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetValue(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/get the value of this coordinate. This can be thought of as the position of this coordinate in its coordinate system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetCoordinateSystemToView">
            <summary>
                <para>Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetCoordinateSystemToNormalizedViewport">
            <summary>
                <para>Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetCoordinateSystemToViewport">
            <summary>
                <para>Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetCoordinateSystemToNormalizedDisplay">
            <summary>
                <para>Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetCoordinateSystemToDisplay">
            <summary>
                <para>Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.GetCoordinateSystem">
            <summary>
                <para>Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCoordinate.SetCoordinateSystem(System.Int32)">
            <summary>
                <para>Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Pentagonal prism specific</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Pentagonal prism specific</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the wedge in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell3D API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell3D API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell3D API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell3D API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell3D API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.GetCellDimension">
            <summary>
                <para>See the vtkCell3D API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPentagonalPrism.GetCellType">
            <summary>
                <para>See the vtkCell3D API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.SetOutput(vtk.vtkRectilinearGrid)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridSource.GetOutput">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyLine.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyLine.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyLine.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyLine.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the point cloud in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.IsPrimaryCell">
            <summary>
                <para>Return the center of the point cloud in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GenerateSlidingNormals(vtk.vtkPoints,vtk.vtkCellArray,vtk.vtkDataArray,System.Double[])">
            <summary>
                <para>Given points and lines, compute normals to lines. These are not true  normals, they are "orientation" normals used by classes like vtkTubeFilter that control the rotation around the line. The normals try to stay pointing in the same direction as much as possible (i.e., minimal rotation).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyLine.GenerateSlidingNormals(vtk.vtkPoints,vtk.vtkCellArray,vtk.vtkDataArray)">
            <summary>
                <para>Given points and lines, compute normals to lines. These are not true  normals, they are "orientation" normals used by classes like vtkTubeFilter that control the rotation around the line. The normals try to stay pointing in the same direction as much as possible (i.e., minimal rotation).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarTree.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkScalarTree.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.GetInput2">
            <summary>
                <para>Get the inputs to this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.GetInput1">
            <summary>
                <para>Get the inputs to this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.SetInput2(vtk.vtkImageData)">
            <summary>
                <para>Set the Input2 of this filter. If a ScalarType has not been set, then the ScalarType of the input is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageTwoInputFilter.SetInput1(vtk.vtkImageData)">
            <summary>
                <para>Set the Input1 of this filter. If a ScalarType has not been set, then the ScalarType of the input is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.SplitExtent(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
                <para>Putting this here until I merge graphics and imaging streaming.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.GetNumberOfThreads">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.GetNumberOfThreadsMaxValue">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.GetNumberOfThreadsMinValue">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.SetNumberOfThreads(System.Int32)">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.BypassOff">
            <summary>
                <para>Turning bypass on will cause the filter to turn off and simply pass the data from the first input (input0) through.   It is implemented for consistency with vtkImageToImageFilter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.BypassOn">
            <summary>
                <para>Turning bypass on will cause the filter to turn off and simply pass the data from the first input (input0) through.   It is implemented for consistency with vtkImageToImageFilter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.GetBypass">
            <summary>
                <para>Turning bypass on will cause the filter to turn off and simply pass the data from the first input (input0) through.   It is implemented for consistency with vtkImageToImageFilter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.SetBypass(System.Int32)">
            <summary>
                <para>Turning bypass on will cause the filter to turn off and simply pass the data from the first input (input0) through.   It is implemented for consistency with vtkImageToImageFilter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.GetInput">
            <summary>
                <para>Get one input to this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.GetInput(System.Int32)">
            <summary>
                <para>Get one input to this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.RemoveInput(vtk.vtkImageData)">
            <summary>
                <para>Adds an input to the first null position in the input list. Expands the list memory if necessary</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.AddInput(vtk.vtkImageData)">
            <summary>
                <para>Adds an input to the first null position in the input list. Expands the list memory if necessary</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMultipleInputFilter.SetInput(System.Int32,vtk.vtkImageData)">
            <summary>
                <para>Set an Input of this filter. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLine.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLine.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLine.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLine.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLine.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLine.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Line specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.DistanceToLine(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Determine the distance of the current vertex to the edge defined by the vertices provided.  Returns distance squared. Note: line is assumed infinite in extent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.DistanceToLine(System.Double[],System.Double[],System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>Compute the distance of a point x to a finite line (p1,p2). The method computes the parametric coordinate t and the point location on the line. Note that t is unconstrained (i.e., it may lie outside the range [0,1]) but the closest point will lie within the finite line [p1,p2]. Also, the method returns the distance squared between x and the line (p1,p2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.Intersection(System.Double[],System.Double[],System.Double[],System.Double[],System.Double@,System.Double@)">
            <summary>
                <para>Performs intersection of two finite 3D lines. An intersection is found if the projection of the two lines onto the plane perpendicular to the cross product of the two lines intersect. The parameters (u,v) are the  parametric coordinates of the lines at the position of closest approach.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Line-line intersection. Intersection has to occur within [0,1] parametric coordinates and with specified tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the triangle in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this line using scalar value provided. Like contouring, except that it cuts the line to produce other lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLine.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.Next">
            <summary>
                <para>Move the iterator to the next position in the list. \pre not_at_end: !IsAtEnd()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.GetCell">
            <summary>
                <para>Get the cell at the current traversal position. NOT THREAD SAFE \pre not_at_end: !IsAtEnd() \post result_exits: result!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.GetCell(vtk.vtkGenericAdaptorCell)">
            <summary>
                <para>Get the cell at current position. The cell should be instantiated with the NewCell() method. \pre not_at_end: !IsAtEnd() \pre c_exists: c!=0 THREAD SAFE</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.NewCell">
            <summary>
                <para>Create an empty cell. The user is responsible for deleting it. \post result_exists: result!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.IsAtEnd">
            <summary>
                <para>Is the iterator at the end of traversal?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.Begin">
            <summary>
                <para>Move iterator to first position if any (loop initialization).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.NewInstance">
            <summary>
                <para>Standard VTK construction and type macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.IsA(System.String)">
            <summary>
                <para>Standard VTK construction and type macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCellIterator.GetClassName">
            <summary>
                <para>Standard VTK construction and type macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataObjectCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataObjectCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectCollection.GetItem(System.Int32)">
            <summary>
                <para>Get the ith data object in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectCollection.GetNextItem">
            <summary>
                <para>Get the next data object in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectCollection.AddItem(vtk.vtkDataObject)">
            <summary>
                <para>Add a data object to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic hexahedron specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic hexahedron specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the quadratic wedge in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Line-edge intersection. Intersection has to occur within [0,1] parametric coordinates and with specified tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this quadratic hexahedron using scalar value provided. Like  contouring, except that it cuts the hex to produce linear  tetrahedron.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.GetFace(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.GetEdge(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.GetNumberOfFaces">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.GetNumberOfEdges">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.GetCellDimension">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticWedge.GetCellType">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredGridFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredGridFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredGridFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredGridFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredGridFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredGridFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredGridFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToStructuredGridFilter.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataToPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataToPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataToPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataToPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataToPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataToPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataToPolyDataFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataToPolyDataFilter.SetInput(vtk.vtkPolyData)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHexahedron.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHexahedron.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHexahedron.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHexahedron.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHexahedron.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHexahedron.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Hexahedron specific.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Hexahedron specific.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHexahedron.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkViewport.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkViewport.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericAttribute.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.ShallowCopy(vtk.vtkGenericAttribute)">
            <summary>
                <para>Update `this' using fields of `other'. \pre other_exists: other!=0 \pre not_self: other!=this</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.DeepCopy(vtk.vtkGenericAttribute)">
            <summary>
                <para>Recursive duplication of `other' in `this'. \pre other_exists: other!=0 \pre not_self: other!=this</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetComponent(System.Int32,vtk.vtkGenericPointIterator)">
            <summary>
                <para>Value of the component `i' of the attribute at position `p'. \pre valid_component: (i&gt;=0) &amp;&amp; (i&lt;GetNumberOfComponents()) \pre p_exists: p!=0 \pre p_valid: !p-&gt;IsAtEnd()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetComponent(System.Int32,vtk.vtkGenericCellIterator,System.Double[])">
            <summary>
                <para>Put component `i' of the attribute at all points of cell `c' in `values'. \pre valid_component: (i&gt;=0) &amp;&amp; (i&lt;GetNumberOfComponents()) \pre c_exists: c!=0 \pre c_valid: !c-&gt;IsAtEnd() \pre values_exist: values!=0 \pre valid_values: sizeof(values)&gt;=c-&gt;GetCell()-&gt;GetNumberOfPoints()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetTuple(vtk.vtkGenericPointIterator,System.Double[])">
            <summary>
                <para>Put the value of the attribute at position `p' into `tuple'. \pre p_exists: p!=0 \pre p_valid: !p-&gt;IsAtEnd() \pre tuple_exists: tuple!=0 \pre valid_tuple_size: sizeof(tuple)&gt;=GetNumberOfComponents()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetTuple(vtk.vtkGenericCellIterator,System.Double[])">
            <summary>
                <para>Put attribute at all points of cell `c' in `tuple'. \pre c_exists: c!=0 \pre c_valid: !c-&gt;IsAtEnd() \pre tuple_exists: tuple!=0 \pre valid_tuple: sizeof(tuple)&gt;=GetNumberOfComponents()*c-&gt;GetCell()-&gt;GetNumberOfPoints()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetTuple(vtk.vtkGenericAdaptorCell,System.Double[])">
            <summary>
                <para>Put attribute at all points of cell `c' in `tuple'. \pre c_exists: c!=0 \pre c_valid: !c-&gt;IsAtEnd() \pre tuple_exists: tuple!=0 \pre valid_tuple: sizeof(tuple)&gt;=GetNumberOfComponents()*c-&gt;GetCell()-&gt;GetNumberOfPoints()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetMaxNorm">
            <summary>
                <para>Return the maximum euclidean norm for the tuples. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetRange(System.Int32,System.Double[])">
            <summary>
                <para>Range of the attribute component `component'. If `component'==-1, it returns the range of the magnitude (euclidean norm). THREAD SAFE \pre valid_component: (component&gt;=-1)&amp;&amp;(component&lt;GetNumberOfComponents())</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetActualMemorySize">
            <summary>
                <para>Size in kilobytes taken by the attribute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetSize">
            <summary>
                <para>Number of tuples. \post valid_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetComponentType">
            <summary>
                <para>Type of the components of the attribute: int, float, double \post valid_result: (result==VTK_BIT)           ||(result==VTK_CHAR)                   ||(result==VTK_UNSIGNED_CHAR) ||(result==VTK_SHORT)                   ||(result==VTK_UNSIGNED_SHORT)||(result==VTK_INT)                   ||(result==VTK_UNSIGNED_INT)  ||(result==VTK_LONG)                   ||(result==VTK_UNSIGNED_LONG) ||(result==VTK_FLOAT)                   ||(result==VTK_DOUBLE)        ||(result==VTK_ID_TYPE)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetType">
            <summary>
                <para>Type of the attribute: scalar, vector, normal, texture coordinate, tensor \post valid_result: (result==vtkDataSetAttributes::SCALARS)                   ||(result==vtkDataSetAttributes::VECTORS)                   ||(result==vtkDataSetAttributes::NORMALS)                   ||(result==vtkDataSetAttributes::TCOORDS)                   ||(result==vtkDataSetAttributes::TENSORS)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetCentering">
            <summary>
                <para>Is the attribute centered either on points, cells or boundaries? \post valid_result: (result==vtkPointCentered)||(result==vtkCellCentered)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetNumberOfComponents">
            <summary>
                <para>Dimension of the attribute. (1 for scalar, 3 for velocity) \post positive_result: result&gt;=0 \post GetType()==VTK_SCALARS implies result==1 \post (GetType()==VTK_VECTORS||(GetType()==VTK_NORMALS)||(GetType()==VTK_TCOORDS) implies result==3 \post GetType()==VTK_TENSORS implies result==6</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttribute.GetName">
            <summary>
                <para>Name of the attribute. (e.g. "velocity") \post result_may_not_exist: result!=0 || result==0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.SetAttributesToInterpolateToAll">
            <summary>
                <para>Set the attributes to interpolate. \pre not_empty: !IsEmpty() \pre positive_size: size&gt;=0 \pre valid_attributes: size&gt;0 implies attributes!=0 \pre valid_attributes_contents: attributes!=0 implies                     !HasAttributes(size,attributes,GetActiveAttribute()) \post is_set: (GetNumberOfAttributesToInterpolate()==size)&amp;&amp;               (GetAttributesToInterpolate()==attributes)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.SetAttributesToInterpolate(System.Int32,System.Int32[])">
            <summary>
                <para>Set the attributes to interpolate. \pre not_empty: !IsEmpty() \pre positive_size: size&gt;=0 \pre valid_attributes: size&gt;0 implies attributes!=0 \pre valid_attributes_contents: attributes!=0 implies                     !HasAttributes(size,attributes,GetActiveAttribute()) \post is_set: (GetNumberOfAttributesToInterpolate()==size)&amp;&amp;               (GetAttributesToInterpolate()==attributes)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetNumberOfAttributesToInterpolate">
            <summary>
                <para>Number of attributes to interpolate. \pre not_empty: !IsEmpty() \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.SetActiveAttribute(System.Int32,System.Int32)">
            <summary>
                <para>Set the scalar attribute to be processed. -1 means module. \pre not_empty: !IsEmpty() \pre valid_attribute: attribute&gt;=0 &amp;&amp; attribute&lt;GetNumberOfAttributes() \pre valid_component: component&gt;=-1 &amp;&amp;              component&lt;GetAttribute(attribute)-&gt;GetNumberOfComponents() \post is_set: GetActiveAttribute()==attribute &amp;&amp;               GetActiveComponent()==component</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetActiveComponent">
            <summary>
                <para>Component of the active attribute to be processed. -1 means module. \pre not_empty: GetNumberOfAttributes()&gt;0 \post valid_result: result&gt;=-1 &amp;&amp;       result&lt;GetAttribute(GetActiveAttribute())-&gt;GetNumberOfComponents()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetActiveAttribute">
            <summary>
                <para>Index of the attribute to be processed (not necessarily scalar). \pre not_empty: !IsEmpty() \post valid_result: result&gt;=0 &amp;&amp; result&lt;GetNumberOfAttributes()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetMTime">
            <summary>
                <para>vtkAttributeCollection is a composite object and needs to check each member of its collection for modified time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.ShallowCopy(vtk.vtkGenericAttributeCollection)">
            <summary>
                <para>Copy, via reference counting, the other attribute array. \pre other_exists: other!=0 \pre not_self: other!=this \post same_size: GetNumberOfAttributes()==other-&gt;GetNumberOfAttributes()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.DeepCopy(vtk.vtkGenericAttributeCollection)">
            <summary>
                <para>Copy, without reference counting, the other attribute array. \pre other_exists: other!=0 \pre not_self: other!=this \post same_size: GetNumberOfAttributes()==other-&gt;GetNumberOfAttributes()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.Reset">
            <summary>
                <para>Remove all attributes. \post is_empty: GetNumberOfAttributes()==0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.RemoveAttribute(System.Int32)">
            <summary>
                <para>Remove the attribute at `i'. \pre not_empty: !IsEmpty() \pre valid_i: i&gt;=0 &amp;&amp; i&lt;GetNumberOfAttributes() \post fewer_items: GetNumberOfAttributes()==old GetNumberOfAttributes()-1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.InsertAttribute(System.Int32,vtk.vtkGenericAttribute)">
            <summary>
                <para>Replace the attribute at index `i' by `a'. \pre not_empty: !IsEmpty() \pre a_exists: a!=0 \pre valid_i: i&gt;=0 &amp;&amp; i&lt;GetNumberOfAttributes() \post same_size: GetNumberOfAttributes()==old GetNumberOfAttributes() \post item_is_set: GetAttribute(i)==a</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.InsertNextAttribute(vtk.vtkGenericAttribute)">
            <summary>
                <para>Add the attribute `a' to the end of the collection. \pre a_exists: a!=0 \post more_items: GetNumberOfAttributes()==old GetNumberOfAttributes()+1 \post a_is_set: GetAttribute(GetNumberOfAttributes()-1)==a</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetAttributeIndex(System.Int32)">
            <summary>
                <para>Return the index of the first component of attribute `i' in an array of format attrib0comp0 attrib0comp1 ... attrib4comp0 ... \pre valid_i: i&gt;=0 &amp;&amp; i&lt;GetNumberOfAttributes() \pre is_point_centered: GetAttribute(i)-&gt;GetCentering()==vtkPointCentered</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.FindAttribute(System.String)">
            <summary>
                <para>Return the index of the attribute named `name'. Return the non-negative index if found. Return -1 otherwise. \pre name_exists: name!=0 \post valid_result: (result==-1) || (result&gt;=0) &amp;&amp; (result&lt;=GetNumberOfAttributes())</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetAttribute(System.Int32)">
            <summary>
                <para>Return a pointer to the ith instance of vtkGenericAttribute. \pre not_empty: !IsEmpty() \pre valid_i: i&gt;=0 &amp;&amp; i&lt;GetNumberOfAttributes() \post result_exists: result!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.IsEmpty">
            <summary>
                <para>Indicate whether the collection contains any attributes. \post definition: result==(GetNumberOfAttributes()==0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetActualMemorySize">
            <summary>
                <para>Actual size of the data in kilobytes; only valid after the pipeline has updated. It is guaranteed to be greater than or equal to the memory required to represent the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetMaxNumberOfComponents">
            <summary>
                <para>Maximum number of components encountered among all attributes. \post positive_result: result&gt;=0 \post valid_result: result&lt;=GetNumberOfComponents()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetNumberOfPointCenteredComponents">
            <summary>
                <para>Return the number of components. This is the sum of all components found in all point centered attributes. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetNumberOfComponents">
            <summary>
                <para>Return the number of components. This is the sum of all components found in all attributes. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetNumberOfAttributes">
            <summary>
                <para>Return the number of attributes (e.g., instances of vtkGenericAttribute)  in the collection. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard type definition and print methods for a VTK class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.NewInstance">
            <summary>
                <para>Standard type definition and print methods for a VTK class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.IsA(System.String)">
            <summary>
                <para>Standard type definition and print methods for a VTK class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAttributeCollection.GetClassName">
            <summary>
                <para>Standard type definition and print methods for a VTK class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.UPDATE_BLOCKS">
            <summary>
                <para>vtkCompositeDataPipeline specific keys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.INPUT_REQUIRED_COMPOSITE_DATA_TYPE">
            <summary>
                <para>vtkCompositeDataPipeline specific keys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.MARKED_FOR_UPDATE">
            <summary>
                <para>vtkCompositeDataPipeline specific keys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.COMPOSITE_DATA_INFORMATION">
            <summary>
                <para>vtkCompositeDataPipeline specific keys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.COMPOSITE_DATA_TYPE_NAME">
            <summary>
                <para>vtkCompositeDataPipeline specific keys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.END_LOOP">
            <summary>
                <para>vtkCompositeDataPipeline specific keys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.BEGIN_LOOP">
            <summary>
                <para>vtkCompositeDataPipeline specific keys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataPipeline.GetCompositeOutputData(System.Int32)">
            <summary>
                <para>Returns the data object stored with the COMPOSITE_DATA_SET() in the output port</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataObject.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic edge specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic edge specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the quadratic tetra in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Line-edge intersection. Intersection has to occur within [0,1] parametric coordinates and with specified tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this edge using scalar value provided. Like contouring, except that it cuts the edge to produce linear line segments.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.GetEdge(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.GetNumberOfFaces">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.GetNumberOfEdges">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.GetCellDimension">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticEdge.GetCellType">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectilinearGridToPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToPolyDataFilter.GetInput">
            <summary>
                <para>Set / get the input Grid or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToPolyDataFilter.SetInput(vtk.vtkRectilinearGrid)">
            <summary>
                <para>Set / get the input Grid or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.GetOperationTypeAsString">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.SetOperationTypeToUnionOfMagnitudes">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.SetOperationTypeToDifference">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.SetOperationTypeToIntersection">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.SetOperationTypeToUnion">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.GetOperationType">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.GetOperationTypeMaxValue">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.GetOperationTypeMinValue">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.SetOperationType(System.Int32)">
            <summary>
                <para>Specify the type of boolean operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.GetFunction">
            <summary>
                <para>Return the collection of implicit functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.RemoveFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Remove a function from the list of implicit functions to boolean.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.AddFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Add another implicit function to the list of functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.GetMTime">
            <summary>
                <para>Override modified time retrieval because of object dependencies.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.EvaluateGradient(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate gradient of boolean combination.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.EvaluateFunction(System.Double,System.Double,System.Double)">
            <summary>
                <para>Evaluate boolean combinations of implicit function using current operator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitBoolean.EvaluateFunction(System.Double[])">
            <summary>
                <para>Evaluate boolean combinations of implicit function using current operator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuad.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuad.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuad.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuad.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuad.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuad.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuad.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>vtkQuad specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>vtkQuad specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this quad using scalar value provided. Like contouring, except that it cuts the quad to produce other quads and/or triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the triangle in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuad.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleImageToImageFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleImageToImageFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleImageToImageFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSimpleImageToImageFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSimpleImageToImageFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleImageToImageFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionShiftScale.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionShiftScale.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionShiftScale.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionShiftScale.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionShiftScale.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionShiftScale.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunctionAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic quad specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic quad specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the pyramid in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Line-edge intersection. Intersection has to occur within [0,1] parametric coordinates and with specified tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this quadratic quad using scalar value provided. Like contouring,  except that it cuts the quad to produce linear triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.GetEdge(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.GetNumberOfFaces">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.GetNumberOfEdges">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.GetCellDimension">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticQuad.GetCellType">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.ComputeInputUpdateExtents(vtk.vtkDataObject)">
            <summary>
                <para>By default copy the output update extent to the input</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.GetUnstructuredGridOutput">
            <summary>
                <para>Get the output as vtkUnstructuredGrid. Performs run-time checking.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.GetStructuredGridOutput">
            <summary>
                <para>Get the output as vtkStructuredGrid. Performs run-time checking.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.GetPolyDataOutput">
            <summary>
                <para>Get the output as vtkPolyData. Performs run-time checking.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this filter. If output is NULL, then input hasn't been set, which is necessary for abstract filter objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.GetOutput">
            <summary>
                <para>Get the output of this filter. If output is NULL, then input hasn't been set, which is necessary for abstract filter objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.GetInput">
            <summary>
                <para>Get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetToPointSetFilter.SetInput(vtk.vtkPointSet)">
            <summary>
                <para>Specify the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVoxel.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVoxel.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVoxel.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVoxel.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVoxel.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVoxel.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVoxel.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Voxel specific methods for interpolation and derivatives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Voxel specific methods for interpolation and derivatives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxel.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolygon.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolygon.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolygon.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolygon.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolygon.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolygon.IntersectPolygonWithPolygon(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Double[],System.Double,System.Double[])">
            <summary>
                <para>Method intersects two polygons. You must supply the number of points and point coordinates (npts, *pts) and the bounding box (bounds) of the two polygons. Also supply a tolerance squared for controlling error. The method returns 1 if there is an intersection, and 0 if not. A single point of intersection x[3] is also returned if there is an intersection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.Triangulate(vtk.vtkIdList)">
            <summary>
                <para>Triangulate this polygon. The user must provide the vtkIdList outTris. On output, the outTris list contains the ids of the points defining the triangulation. The ids are ordered into groups of three: each three-group defines one triangle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.PointInPolygon(System.Double[],System.Int32,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Determine whether point is inside polygon. Function uses ray-casting to determine if point is inside polygon. Works for arbitrary polygon shape (e.g., non-convex). Returns 0 if point is not in polygon; 1 if it is. Can also return -1 to indicate degenerate polygon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.ParameterizePolygon(System.Double[],System.Double[],System.Double@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>Create a local s-t coordinate system for a polygon. The point p0 is the origin of the local system, p10 is s-axis vector, and p20 is the t-axis vector. (These are expressed in the modeling coordinate system and are vectors of dimension [3].) The values l20 and l20 are the lengths of the vectors p10 and p20, and n is the polygon normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.ComputeWeights(System.Double[],System.Double[])">
            <summary>
                <para>Compute interpolation weights using 1/r**2 normalized sum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.ComputeNormal(System.Int32,System.Double[],System.Double[])">
            <summary>
                <para>Compute the polygon normal from an array of points. This version assumes that the polygon is convex, and looks for the first valid normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.ComputeNormal(vtk.vtkPoints,System.Double[])">
            <summary>
                <para>Polygon specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.ComputeNormal(vtk.vtkPoints,System.Int32,System.Int32[],System.Double[])">
            <summary>
                <para>Polygon specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.IsPrimaryCell">
            <summary>
                <para>Polygon specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolygon.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergePoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMergePoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMergePoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMergePoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMergePoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMergePoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMergePoints.InsertUniquePoint(System.Double[],System.Int32@)">
            <summary>
                <para>Determine whether point given by x[3] has been inserted into points list. Return 0 if point was already in the list, otherwise return 1. If the point was not in the list, it will be ADDED.  In either case, the id of the point (newly inserted or not) is returned in the ptId argument. Note this combines the functionality of IsInsertedPoint() followed by a call to InsertNextPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergePoints.IsInsertedPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Determine whether point given by x[3] has been inserted into points list. Return id of previously inserted point if this is true, otherwise return -1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergePoints.IsInsertedPoint(System.Double[])">
            <summary>
                <para>Determine whether point given by x[3] has been inserted into points list. Return id of previously inserted point if this is true, otherwise return -1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellTypes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetFirstNonZeroValue">
            <summary>
                <para>Returns the first point location which precedes a non-zero segment of the function. Note that the value at this point may be zero.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetType">
            <summary>
                <para>Return the type of function: Function Types:    0 : Constant        (No change in slope between end points)    1 : NonDecreasing   (Always increasing or zero slope)    2 : NonIncreasing   (Always decreasing or zero slope)    3 : Varied          (Contains both decreasing and increasing slopes)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.ClampingOff">
            <summary>
                <para>When zero range clamping is Off, GetValue() returns 0.0 when a value is requested outside of the points specified. When zero range clamping is On, GetValue() returns the value at the value at the lowest point for a request below all points  specified and returns the value at the highest point for a request  above all points specified. On is the default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.ClampingOn">
            <summary>
                <para>When zero range clamping is Off, GetValue() returns 0.0 when a value is requested outside of the points specified. When zero range clamping is On, GetValue() returns the value at the value at the lowest point for a request below all points  specified and returns the value at the highest point for a request  above all points specified. On is the default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetClamping">
            <summary>
                <para>When zero range clamping is Off, GetValue() returns 0.0 when a value is requested outside of the points specified. When zero range clamping is On, GetValue() returns the value at the value at the lowest point for a request below all points  specified and returns the value at the highest point for a request  above all points specified. On is the default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.SetClamping(System.Int32)">
            <summary>
                <para>When zero range clamping is Off, GetValue() returns 0.0 when a value is requested outside of the points specified. When zero range clamping is On, GetValue() returns the value at the value at the lowest point for a request below all points  specified and returns the value at the highest point for a request  above all points specified. On is the default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.BuildFunctionFromTable(System.Double,System.Double,System.Int32,System.Double[],System.Int32)">
            <summary>
                <para>Constructs a piecewise function from a table.  Function range is is set to [x1, x2], function size is set to size, and function points are regularly spaced between x1 and x2.  Parameter "stride" is is step through the input table.  It is used by vtkColorTransferFunction to construct 3 piecewise functions from an rgb table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetTable(System.Double,System.Double,System.Int32,System.Double[],System.Int32)">
            <summary>
                <para>Fills in an array of function values evaluated at regular intervals. Parameter "stride" is used to step through the output "table". It is used by vtkColorTransferFunction to fill in an rgb table using three separate piecewise functions and three separate calls to GetTable().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetTable(System.Double,System.Double,System.Int32,System.Single[],System.Int32)">
            <summary>
                <para>Fills in an array of function values evaluated at regular intervals. Parameter "stride" is used to step through the output "table". It is used by vtkColorTransferFunction to fill in an rgb table using three separate piecewise functions and three separate calls to GetTable().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.AdjustRange(System.Double[])">
            <summary>
                <para>Remove all points out of the new range, and make sure there is a point at each end of that range. Return 1 on success, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetRange">
            <summary>
                <para>Returns the min and max point locations of the function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.FillFromDataPointer(System.Int32,System.Double[])">
            <summary>
                <para>Returns a pointer to the data stored in the table. Fills from a pointer to data stored in a similar table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetValue(System.Double)">
            <summary>
                <para>Returns the value of the function at the specified location using the specified interpolation. Returns zero if the specified location is outside the min and max points of the function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.AddSegment(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Add a line segment to the function. All points defined between the two points specified are removed from the function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.RemoveAllPoints">
            <summary>
                <para>Removes all points from the function. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.RemovePoint(System.Double)">
            <summary>
                <para>Add/Remove points to/from the function. If a duplicate point is added then the function value is changed at that location. Return the index of the point (0 based), or -1 on error.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.AddPoint(System.Double,System.Double)">
            <summary>
                <para>Add/Remove points to/from the function. If a duplicate point is added then the function value is changed at that location. Return the index of the point (0 based), or -1 on error.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetSize">
            <summary>
                <para>Get the number of points used to specify the function</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPiecewiseFunction.GetDataObjectType">
            <summary>
                <para>Return what type of dataset this is.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWedge.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWedge.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWedge.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWedge.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWedge.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWedge.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWedge.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Wedge specific methods for computing interpolation functions and derivatives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Wedge specific methods for computing interpolation functions and derivatives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the wedge in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWedge.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.GetError(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Return the error at the mid-point. The type of error depends on the state of the concrete error metric. For instance, it can return an absolute or relative error metric. See RequiresEdgeSubdivision() for a description of the arguments. \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6 \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.RequiresEdgeSubdivision(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Does the edge need to be subdivided according to the distance between the value of the active attribute/component at the midpoint and the mean value between the endpoints? The edge is defined by its `leftPoint' and its `rightPoint'. `leftPoint', `midPoint' and `rightPoint' have to be initialized before calling RequiresEdgeSubdivision(). Their format is global coordinates, parametric coordinates and point centered attributes: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.SetAttributeTolerance(System.Double)">
            <summary>
                <para>Set the relative attribute accuracy to `value'. See GetAttributeTolerance() for details. \pre valid_range_value: value&gt;0 &amp;&amp; value&lt;1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.GetAttributeTolerance">
            <summary>
                <para>Relative tolerance of the active scalar (attribute+component). Subdivision is required if the square distance between the real attribute at the mid point on the edge and the interpolated attribute is greater than AttributeTolerance. This is the attribute accuracy. 0.01 will give better result than 0.1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.SetAbsoluteAttributeTolerance(System.Double)">
            <summary>
                <para>Set the absolute attribute accuracy to `value'. See GetAbsoluteAttributeTolerance() for details. It is particularly useful when some concrete implementation of vtkGenericAttribute does not support GetRange() request, called internally in SetAttributeTolerance(). It may happen when the implementation support higher order attributes but cannot compute the range. \pre valid_range_value: value&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.GetAbsoluteAttributeTolerance">
            <summary>
                <para>Absolute tolerance of the active scalar (attribute+component). Subdivision is required if the square distance between the real attribute at the mid point on the edge and the interpolated attribute is greater than AbsoluteAttributeTolerance. This is the attribute accuracy. 0.01 will give better result than 0.1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.NewInstance">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.IsA(System.String)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributesErrorMetric.GetClassName">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.GetOutGradient">
            <summary>
                <para>Set / get the function gradient to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.SetOutGradient(System.Double[])">
            <summary>
                <para>Set / get the function gradient to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.SetOutGradient(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the function gradient to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.GetOutValue">
            <summary>
                <para>Set / get the function value to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.SetOutValue(System.Double)">
            <summary>
                <para>Set / get the function value to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.GetDataSet">
            <summary>
                <para>Set / get the dataset used for the implicit function evaluation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.SetDataSet(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the dataset used for the implicit function evaluation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitDataSet.GetMTime">
            <summary>
                <para>Return the MTime also considering the DataSet dependency.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataObjectSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataObjectSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectSource.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output field of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectSource.GetOutput(System.Int32)">
            <summary>
                <para>Get the output field of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectSource.GetOutput">
            <summary>
                <para>Get the output field of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkKochanekSpline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.DeepCopy(vtk.vtkSpline)">
            <summary>
                <para>Deep copy of cardinal spline data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.GetDefaultContinuity">
            <summary>
                <para>Set the continuity for all points. Default is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.SetDefaultContinuity(System.Double)">
            <summary>
                <para>Set the continuity for all points. Default is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.GetDefaultTension">
            <summary>
                <para>Set the tension for all points. Default is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.SetDefaultTension(System.Double)">
            <summary>
                <para>Set the tension for all points. Default is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.GetDefaultBias">
            <summary>
                <para>Set the bias for all points. Default is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.SetDefaultBias(System.Double)">
            <summary>
                <para>Set the bias for all points. Default is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.Evaluate(System.Double)">
            <summary>
                <para>Evaluate a 1D Kochanek spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKochanekSpline.Compute">
            <summary>
                <para>Compute Kochanek Spline coefficients.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointSetSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointSetSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetSource.SetOutput(vtk.vtkPointSet)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetSource.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetSource.GetOutput">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToStructuredGridFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToStructuredGridFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToStructuredGridFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredGridToStructuredGridFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToStructuredGridFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToStructuredGridFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToStructuredGridFilter.GetInput">
            <summary>
                <para>Set / get the input Grid or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToStructuredGridFilter.SetInput(vtk.vtkStructuredGrid)">
            <summary>
                <para>Set / get the input Grid or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.SetOutput(vtk.vtkStructuredGrid)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridSource.GetOutput">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.CopyParameters(vtk.vtkInterpolatedVelocityField)">
            <summary>
                <para>Copy the user set parameters from source. This copies the Caching parameters. Sub-classes can add more after chaining.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.GetLastDataSet">
            <summary>
                <para>Returns the last dataset that was visited. Can be used as a first guess as to where the next point will be as well as to avoid searching through all datasets to get more information about the point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.SelectVectors(System.String)">
            <summary>
                <para>Returns the last dataset that was visited. Can be used as a first guess as to where the next point will be as well as to avoid searching through all datasets to get more information about the point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.GetVectorsSelection">
            <summary>
                <para>If you want to work with an arbitrary vector array, then set its name  here. By default this in NULL and the filter will use the active vector  array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.GetCacheMiss">
            <summary>
                <para>Caching statistics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.GetCacheHit">
            <summary>
                <para>Caching statistics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.CachingOff">
            <summary>
                <para>Turn caching on/off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.CachingOn">
            <summary>
                <para>Turn caching on/off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.SetCaching(System.Int32)">
            <summary>
                <para>Turn caching on/off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.GetCaching">
            <summary>
                <para>Turn caching on/off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.GetLastLocalCoordinates(System.Double[])">
            <summary>
                <para>Returns the interpolation weights cached from last evaluation if the cached cell is valid (returns 1). Otherwise, it does not change w and returns 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.GetLastWeights(System.Double[])">
            <summary>
                <para>Returns the interpolation weights cached from last evaluation if the cached cell is valid (returns 1). Otherwise, it does not change w and returns 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.ClearLastCellId">
            <summary>
                <para>Returns the interpolation weights cached from last evaluation if the cached cell is valid (returns 1). Otherwise, it does not change w and returns 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.SetLastCellId(System.Int32)">
            <summary>
                <para>Return the cell id cached from last evaluation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.GetLastCellId">
            <summary>
                <para>Return the cell id cached from last evaluation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.AddDataSet(vtk.vtkDataSet)">
            <summary>
                <para>Add a dataset used for the implicit function evaluation. If more than one dataset is added, the evaluation point is searched in all until a match is found. THIS FUNCTION DOES NOT CHANGE THE REFERENCE COUNT OF dataset FOR THREAD SAFETY REASONS.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatedVelocityField.FunctionValues(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate the velocity field, f, at (x, y, z, t). For now, t is ignored.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitSum.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.NormalizeByWeightOff">
            <summary>
                <para>When calculating the function and gradient values of the composite function, setting NormalizeByWeight on will divide the final result by the total weight of the component functions. This process does not otherwise normalize the gradient vector. By default, NormalizeByWeight is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.NormalizeByWeightOn">
            <summary>
                <para>When calculating the function and gradient values of the composite function, setting NormalizeByWeight on will divide the final result by the total weight of the component functions. This process does not otherwise normalize the gradient vector. By default, NormalizeByWeight is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.GetNormalizeByWeight">
            <summary>
                <para>When calculating the function and gradient values of the composite function, setting NormalizeByWeight on will divide the final result by the total weight of the component functions. This process does not otherwise normalize the gradient vector. By default, NormalizeByWeight is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.SetNormalizeByWeight(System.Int32)">
            <summary>
                <para>When calculating the function and gradient values of the composite function, setting NormalizeByWeight on will divide the final result by the total weight of the component functions. This process does not otherwise normalize the gradient vector. By default, NormalizeByWeight is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.SetFunctionWeight(vtk.vtkImplicitFunction,System.Double)">
            <summary>
                <para>Set the weight (coefficient) of the given function to be weight.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.RemoveAllFunctions">
            <summary>
                <para>Remove all functions from the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.AddFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Remove all functions from the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.AddFunction(vtk.vtkImplicitFunction,System.Double)">
            <summary>
                <para>Add another implicit function to the list of functions, along with a  weighting factor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.GetMTime">
            <summary>
                <para>Override modified time retrieval because of object dependencies.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.EvaluateGradient(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate gradient of the weighted sum of functions.  Input functions should be linear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.EvaluateFunction(System.Double,System.Double,System.Double)">
            <summary>
                <para>Evaluate implicit function using current functions and weights.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitSum.EvaluateFunction(System.Double[])">
            <summary>
                <para>Evaluate implicit function using current functions and weights.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.LoadFactor">
            <summary>
                <para>For debugging purposes. It is particularly useful to dump the table and check that nothing is left after a complete iteration. LoadFactor should ideally be very low to be able to have a constant time access</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.DumpTable">
            <summary>
                <para>For debugging purposes. It is particularly useful to dump the table and check that nothing is left after a complete iteration. LoadFactor should ideally be very low to be able to have a constant time access</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.IncrementPointReferenceCount(System.Int32)">
            <summary>
                <para>Increment the reference count for the indicated point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.RemovePoint(System.Int32)">
            <summary>
                <para>Remove a point from the point table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.InsertPointAndScalar(System.Int32,System.Double[],System.Double[])">
            <summary>
                <para>Insert point associated with an edge. \pre: sizeof(s)==GetNumberOfComponents()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.InsertPoint(System.Int32,System.Double[])">
            <summary>
                <para>Insert point associated with an edge.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.CheckPoint(System.Int32,System.Double[],System.Double[])">
            <summary>
                <para>Check for the existence of a point and return its coordinate value. \pre scalar_size: sizeof(scalar)==this-&gt;GetNumberOfComponents()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.CheckPoint(System.Int32)">
            <summary>
                <para>Check if a point is already in the point table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.SetNumberOfComponents(System.Int32)">
            <summary>
                <para>Set the total number of components for the point-centered attributes. \pre positive_count: count&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.GetNumberOfComponents">
            <summary>
                <para>Return the total number of components for the point-centered attributes. \post positive_result: result&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.Initialize(System.Int32)">
            <summary>
                <para>To specify the starting point id. It will initialize LastPointId This is very sensitive the start point should be cautiously chosen</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.CheckEdgeReferenceCount(System.Int32,System.Int32)">
            <summary>
                <para>Return the edge reference count.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.IncrementEdgeReferenceCount(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Method that increments the referencecount and returns it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.CheckEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
                <para>Method to determine whether an edge is in the table (0 or 1), or not (-1). It returns whether the edge was split (1) or not (0), and the point id exists.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.RemoveEdge(System.Int32,System.Int32)">
            <summary>
                <para>Method to remove an edge from the table. The method returns the current reference count.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.InsertEdge(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Insert an edge but do not split it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.InsertEdge(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
                <para>Split the edge with the indicated point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard VTK type and print macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.NewInstance">
            <summary>
                <para>Standard VTK type and print macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.IsA(System.String)">
            <summary>
                <para>Standard VTK type and print macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericEdgeTable.GetClassName">
            <summary>
                <para>Standard VTK type and print macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSpline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSpline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSetAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCylinder.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCylinder.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCylinder.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCylinder.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCylinder.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCylinder.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCylinder.GetCenter">
            <summary>
                <para>Set/Get cylinder center</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinder.SetCenter(System.Double[])">
            <summary>
                <para>Set/Get cylinder center</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinder.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get cylinder center</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinder.GetRadius">
            <summary>
                <para>Set/Get cylinder radius.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinder.SetRadius(System.Double)">
            <summary>
                <para>Set/Get cylinder radius.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic hexahedron specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic hexahedron specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Line-edge intersection. Intersection has to occur within [0,1] parametric coordinates and with specified tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this quadratic hexahedron using scalar value provided. Like  contouring, except that it cuts the hex to produce linear  tetrahedron.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.GetFace(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.GetEdge(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.GetNumberOfFaces">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.GetNumberOfEdges">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.GetCellDimension">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticHexahedron.GetCellType">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.ComputeInputUpdateExtents(vtk.vtkDataObject)">
            <summary>
                <para>Do not let datasets return more than requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToPolyDataFilter.SetInput(vtk.vtkUnstructuredGrid)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.GetId">
            <summary>
                <para>Return the unique identifier for the point, could be non-contiguous. \pre not_off: !IsAtEnd()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.GetPosition(System.Double[])">
            <summary>
                <para>Get the coordinates of the point at the current iterator position. \pre not_off: !IsAtEnd() \pre x_exists: x!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.Next">
            <summary>
                <para>Move the iterator to the next position in the list. \pre not_off: !IsAtEnd()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.IsAtEnd">
            <summary>
                <para>Is the iterator at the end of traversal?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.Begin">
            <summary>
                <para>Move iterator to first position if any (loop initialization).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.NewInstance">
            <summary>
                <para>Standard VTK construction and type macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.IsA(System.String)">
            <summary>
                <para>Standard VTK construction and type macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericPointIterator.GetClassName">
            <summary>
                <para>Standard VTK construction and type macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMapper2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMapper2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMapper2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMapper2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMapper2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAbstractMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.GetScalars(vtk.vtkDataSet,System.Int32,System.Int32,System.Int32,System.String,System.Int32@)">
            <summary>
                <para>Internal helper function for getting the active scalars. The scalar mode indicates where the scalars come from.  The cellFlag is a  return value that is set when the scalars actually are cell scalars. the arrayAccessMode is used to indicate how to retrieve the scalars from  field data (if the scalarMode indicates that). The component is used to  indicate which component in the data array to use as the scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.ShallowCopy(vtk.vtkAbstractMapper)">
            <summary>
                <para>Make a shallow copy of this mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.SetClippingPlanes(vtk.vtkPlanes)">
            <summary>
                <para>An alternative way to set clipping planes: use up to six planes found in the supplied instance of the implicit function vtkPlanes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.GetClippingPlanes">
            <summary>
                <para>Get/Set the vtkPlaneCollection which specifies the clipping planes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.SetClippingPlanes(vtk.vtkPlaneCollection)">
            <summary>
                <para>Get/Set the vtkPlaneCollection which specifies the clipping planes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.RemoveAllClippingPlanes">
            <summary>
                <para>Specify clipping planes to be applied when the data is mapped (at most 6 clipping planes can be specified).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.RemoveClippingPlane(vtk.vtkPlane)">
            <summary>
                <para>Specify clipping planes to be applied when the data is mapped (at most 6 clipping planes can be specified).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.AddClippingPlane(vtk.vtkPlane)">
            <summary>
                <para>Specify clipping planes to be applied when the data is mapped (at most 6 clipping planes can be specified).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.GetTimeToDraw">
            <summary>
                <para>Get the time required to draw the geometry last time it was rendered</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this mapper. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper.GetMTime">
            <summary>
                <para>Override Modifiedtime as we have added Clipping planes</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitVolume.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.GetOutGradient">
            <summary>
                <para>Set the function gradient to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.SetOutGradient(System.Double[])">
            <summary>
                <para>Set the function gradient to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.SetOutGradient(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the function gradient to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.GetOutValue">
            <summary>
                <para>Set the function value to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.SetOutValue(System.Double)">
            <summary>
                <para>Set the function value to use for points outside of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.GetVolume">
            <summary>
                <para>Specify the volume for the implicit function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.SetVolume(vtk.vtkImageData)">
            <summary>
                <para>Specify the volume for the implicit function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitVolume.GetMTime">
            <summary>
                <para>Returns the mtime also considering the volume.  This also calls Update on the volume, and it therefore must be called before the function is evaluated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.SplitExtent(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
                <para>Putting this here until I merge graphics and imaging streaming.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.GetNumberOfThreads">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.GetNumberOfThreadsMaxValue">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.GetNumberOfThreadsMinValue">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadedImageAlgorithm.SetNumberOfThreads(System.Int32)">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.GetCacheSize">
            <summary>
                <para>This is the maximum number of images that can be retained in memory. it defaults to 10.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.SetCacheSize(System.Int32)">
            <summary>
                <para>This is the maximum number of images that can be retained in memory. it defaults to 10.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.Update(System.Int32)">
            <summary>
                <para>Bring the algorithm's outputs up-to-date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCachedStreamingDemandDrivenPipeline.Update">
            <summary>
                <para>Bring the algorithm's outputs up-to-date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCardinalSpline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCardinalSpline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCardinalSpline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCardinalSpline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCardinalSpline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCardinalSpline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCardinalSpline.DeepCopy(vtk.vtkSpline)">
            <summary>
                <para>Deep copy of cardinal spline data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCardinalSpline.Evaluate(System.Double)">
            <summary>
                <para>Evaluate a 1D cardinal spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUniformGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetCellBlanking">
            <summary>
                <para>Returns 1 if there is any visibility constraint on the cells, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetPointBlanking">
            <summary>
                <para>Returns 1 if there is any visibility constraint on the points, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.IsCellVisible(System.Int32)">
            <summary>
                <para>Return non-zero value if specified point is visible. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.IsPointVisible(System.Int32)">
            <summary>
                <para>Return non-zero value if specified point is visible. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.SetCellVisibilityArray(vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Set an array that defines the (blanking) visibility of the cells  in the grid. Make sure that length of the visibility array matches  the number of points in the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetCellVisibilityArray">
            <summary>
                <para>Get the array that defines the blanking (visibility) of each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.SetPointVisibilityArray(vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Set an array that defines the (blanking) visibility of the points  in the grid. Make sure that length of the visibility array matches  the number of points in the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetPointVisibilityArray">
            <summary>
                <para>Get the array that defines the blanking (visibility) of each point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.UnBlankCell(System.Int32)">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off cells in the structured grid. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.BlankCell(System.Int32)">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off cells in the structured grid. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.UnBlankPoint(System.Int32)">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.BlankPoint(System.Int32)">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetScalarRange(System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetMaxCellSize">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.Initialize">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetPointCells(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetCellPoints(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetCellType(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.FindAndGetCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.FindCell(System.Double[],vtk.vtkCell,vtk.vtkGenericCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.FindCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetCell(System.Int32,vtk.vtkGenericCell)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetCell(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.GetDataObjectType">
            <summary>
                <para>Return what type of dataset this is.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUniformGrid.CopyStructure(vtk.vtkDataSet)">
            <summary>
                <para>Copy the geometric and topological structure of an input image data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.GetOutput(System.Int32)">
            <summary>
                <para>Set/Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.GetOutput">
            <summary>
                <para>Set/Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsSource.SetOutput(vtk.vtkStructuredPoints)">
            <summary>
                <para>Set/Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetNumberOfVerticesOnFace(System.Int32)">
            <summary>
                <para>Return the number of vertices defining face `faceId'. \pre is_3d: this-&gt;GetDimension()==3 \pre valid_faceId_range: faceId&gt;=0 &amp;&amp; faceId&lt;this-&gt;GetNumberOfBoundaries(2) \post positive_result: &amp;&amp; result&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.TriangulateFace(vtk.vtkGenericAttributeCollection,vtk.vtkGenericCellTessellator,System.Int32,vtk.vtkPoints,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData)">
            <summary>
                <para>Tessellate face `index' of the cell. See Tessellate() for further explanations. \pre cell_is_3d: GetDimension()==3 \pre attributes_exist: attributes!=0 \pre tessellator_exists: tess!=0 \pre valid_face: index&gt;=0 \pre points_exist: points!=0 \pre cellArray_exists: cellArray!=0 \pre internalPd_exists: internalPd!=0 \pre pd_exist: pd!=0 \pre cd_exists: cd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetPointIds(System.Int32[])">
            <summary>
                <para>Put into `id' the list of ids the point of the cell. \pre id_exists: id!=0 \pre valid_size: sizeof(id)==GetNumberOfPoints();</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.IsOnBoundary">
            <summary>
                <para>Is the cell on the exterior boundary of the dataset? \pre 2d: GetDimension()==2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.IsFaceOnBoundary(System.Int32)">
            <summary>
                <para>Is the face `faceId' of the current cell on a exterior boundary of the dataset? \pre 3d: GetDimension()==3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.Tessellate(vtk.vtkGenericAttributeCollection,vtk.vtkGenericCellTessellator,vtk.vtkPoints,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Tessellate the cell if it is not linear or if at least one attribute of `attributes' is not linear. The output are linear cells of the same dimension than than cell. If the cell is linear and all attributes are linear, the output is just a copy of the current cell. `points', `cellArray', `pd' and `cd' are cumulative output data arrays over cell iterations: they store the result of each call to Tessellate(). `internalPd' is initialized by the calling filter and stores the result of the tessellation. If it is not null, `types' is fill with the types of the linear cells. `types' is null when it is called from vtkGenericGeometryFilter and not null when it is called from vtkGenericDatasetTessellator. \pre attributes_exist: attributes!=0 \pre tessellator_exists: tess!=0 \pre points_exist: points!=0 \pre cellArray_exists: cellArray!=0 \pre internalPd_exists: internalPd!=0 \pre pd_exist: pd!=0 \pre cd_exists: cd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetParametricDistance(System.Double[])">
            <summary>
                <para>Return the distance of the parametric coordinate `pcoords' to the current cell.  If inside the cell, a distance of zero is returned. This is used during picking to get the correct cell picked. (The tolerance will occasionally allow cells to be picked who are not really intersected "inside" the cell.)  \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetParametricCenter(System.Double[])">
            <summary>
                <para>Get the center of the current cell (in parametric coordinates)and place in the `pcoords'.  If the current cell is a composite, the return value is the sub-cell id that the center is in.  \post valid_result: (result&gt;=0) &amp;&amp; (IsPrimary() implies result==0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetLength2">
            <summary>
                <para>Return the bounding box diagonal squared of the current cell. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetBounds(System.Double[])">
            <summary>
                <para>Compute the bounding box of the current cell in `bounds' in global coordinates. THREAD SAFE</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.Derivatives(System.Int32,System.Double[],vtk.vtkGenericAttribute,System.Double[])">
            <summary>
                <para>Compute derivatives `derivs' of the attribute `attribute' (from its values at the corner points of the cell) given sub-cell `subId' (0 means primary cell) and parametric coordinates `pcoords'. Derivatives are in the x-y-z coordinate directions for each data value. \pre positive_subId: subId&gt;=0 \pre clamped_pcoords: (0&lt;=pcoords[0])&amp;&amp;(pcoords[0]&lt;=1)&amp;&amp;(0&lt;=pcoords[1]) &amp;&amp;(pcoords[1]&lt;=1)&amp;&amp;(0&lt;=pcoords[2])%%(pcoords[2]&lt;=1) \pre attribute_exists: attribute!=0 \pre derivs_exists: derivs!=0 \pre valid_size: sizeof(derivs)&gt;=attribute-&gt;GetNumberOfComponents()*3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Is there an intersection between the current cell and the ray (`p1',`p2') according to a tolerance `tol'? If true, `x' is the global intersection, `t' is the parametric coordinate for the line, `pcoords' are the parametric coordinates for cell. `subId' is the sub-cell where the intersection occurs. \pre positive_tolerance: tol&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.Clip(System.Double,vtk.vtkImplicitFunction,vtk.vtkGenericAttributeCollection,vtk.vtkGenericCellTessellator,System.Int32,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkCellData,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData)">
            <summary>
                <para>Cut (or clip) the current cell with respect to the contour defined by the `value' or the implicit function `f' of the scalar attribute (`attributes-&gt;GetActiveAttribute()',`attributes-&gt;GetActiveComponent()'). If `f' exists, `value' is not used. The output is the part of the current cell which is inside the contour.  The output is a set of zero, one or more cells of the same topological dimension as the current cell. Normally, cell points whose scalar value is greater than "value" are considered inside. If `insideOut' is on, this is reversed.  Clipping interpolates the `attributes-&gt;GetNumberOfattributesToInterpolate()' attributes `attributes-&gt;GetAttributesToInterpolate()'.  `locator', `connectivity', `outPd' and `outCd' are cumulative data arrays over cell iterations: they store the result of each call to Clip(): - `locator' is points list that merges points as they are inserted (i.e., prevents duplicates). - `connectivity' is an array of generated cells - `outPd' is an array of interpolated point data along the edge (if not-NULL) - `outCd' is an array of copied cell data of the current cell (if not-NULL) `internalPd', `secondaryPd' and `secondaryCd' are initialized by the filter that call it from `attributes'. - `internalPd' stores the result of the tessellation pass: the higher-order cell is tessellated into linear sub-cells. - `secondaryPd' and `secondaryCd' are used internally as inputs to the Clip() method on linear sub-cells. Note: the CopyAllocate() method must be invoked on both `outPd' and `outCd', from `secondaryPd' and `secondaryCd'.</para>
                <para>NOTE: `vtkGenericAttributeCollection *attributes' will be replaced by a       `vtkInformation'.</para>
                <para>\pre attributes_exist: attributes!=0 \pre tessellator_exists: tess!=0 \pre locator_exists: locator!=0 \pre connectivity_exists: connectivity!=0 \pre internalPd_exists: internalPd!=0 \pre secondaryPd_exists: secondaryPd!=0 \pre secondaryCd_exists: secondaryCd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.Contour(vtk.vtkContourValues,vtk.vtkImplicitFunction,vtk.vtkGenericAttributeCollection,vtk.vtkGenericCellTessellator,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkCellData,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData)">
            <summary>
                <para>Generate a contour (contouring primitives) for each `values' or with respect to an implicit function `f'. Contouring is performed on the scalar attribute (`attributes-&gt;GetActiveAttribute()' `attributes-&gt;GetActiveComponent()').  Contouring interpolates the `attributes-&gt;GetNumberOfattributesToInterpolate()' attributes `attributes-&gt;GetAttributesToInterpolate()'.  The `locator', `verts', `lines', `polys', `outPd' and `outCd' are cumulative data arrays over cell iterations: they store the result of each call to Contour(): - `locator' is points list that merges points as they are inserted (i.e., prevents duplicates). - `verts' is an array of generated vertices - `lines' is an array of generated lines - `polys' is an array of generated polygons - `outPd' is an array of interpolated point data along the edge (if not-NULL) - `outCd' is an array of copied cell data of the current cell (if  not-NULL) `internalPd', `secondaryPd' and `secondaryCd' are initialized by the filter that call it from `attributes'. - `internalPd' stores the result of the tessellation pass: the higher-order cell is tessellated into linear sub-cells. - `secondaryPd' and `secondaryCd' are used internally as inputs to the Contour() method on linear sub-cells. Note: the CopyAllocate() method must be invoked on both `outPd' and `outCd', from `secondaryPd' and `secondaryCd'.</para>
                <para>NOTE: `vtkGenericAttributeCollection *attributes' will be replaced by a       `vtkInformation'.</para>
                <para>\pre values_exist: (values!=0 &amp;&amp; f==0) || (values==0 &amp;&amp; f!=0) \pre attributes_exist: attributes!=0 \pre tessellator_exists: tess!=0 \pre locator_exists: locator!=0 \pre verts_exist: verts!=0 \pre lines_exist: lines!=0 \pre polys_exist: polys!=0 \pre internalPd_exists: internalPd!=0 \pre secondaryPd_exists: secondaryPd!=0 \pre secondaryCd_exists: secondaryCd!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.InterpolateTuple(vtk.vtkGenericAttributeCollection,System.Double[],System.Double[])">
            <summary>
                <para>Interpolate the whole collection of attributes `c' at local position `pcoords' of the cell into `val'. Only point centered attributes are taken into account. \pre c_exists: c!=0 \pre clamped_point: pcoords[0]&gt;=0 &amp;&amp; pcoords[0]&lt;=1 &amp;&amp; pcoords[1]&gt;=0 &amp;&amp;                     pcoords[1]&lt;=1 &amp;&amp; pcoords[2]&gt;=0 &amp;&amp; pcoords[2]&lt;=1 \pre val_exists: val!=0 \pre valid_size: sizeof(val)==c-&gt;GetNumberOfPointCenteredComponents()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.InterpolateTuple(vtk.vtkGenericAttribute,System.Double[],System.Double[])">
            <summary>
                <para>Interpolate the attribute `a' at local position `pcoords' of the cell into `val'. \pre a_exists: a!=0 \pre a_is_point_centered: a-&gt;GetCentering()==vtkPointCentered \pre clamped_point: pcoords[0]&gt;=0 &amp;&amp; pcoords[0]&lt;=1 &amp;&amp; pcoords[1]&gt;=0 &amp;&amp;                     pcoords[1]&lt;=1 &amp;&amp; pcoords[2]&gt;=0 &amp;&amp; pcoords[2]&lt;=1 \pre val_exists: val!=0 \pre valid_size: sizeof(val)==a-&gt;GetNumberOfComponents()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.EvaluateLocation(System.Int32,System.Double[],System.Double[])">
            <summary>
                <para>Determine the global coordinates `x' from sub-cell `subId' and parametric coordinates `pcoords' in the cell. \pre positive_subId: subId&gt;=0 \pre clamped_pcoords: (0&lt;=pcoords[0])&amp;&amp;(pcoords[0]&lt;=1)&amp;&amp;(0&lt;=pcoords[1]) &amp;&amp;(pcoords[1]&lt;=1)&amp;&amp;(0&lt;=pcoords[2])&amp;&amp;(pcoords[2]&lt;=1)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@)">
            <summary>
                <para>Is `x' inside the current cell? It also evaluate parametric coordinates `pcoords', sub-cell id `subId' (0 means primary cell), distance squared to the sub-cell in `dist2' and closest corner point `closestPoint'. `dist2' and `closestPoint' are not evaluated if `closestPoint'==0. If a numerical error occurred, -1 is returned and all other results should be ignored. \post valid_result: result==-1 || result==0 || result==1 \post positive_distance: result!=-1 implies (closestPoint!=0 implies                                               dist2&gt;=0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetNeighbors(vtk.vtkGenericAdaptorCell,vtk.vtkGenericCellIterator)">
            <summary>
                <para>Put into `neighbors' the cells (dimension&gt;boundary-&gt;GetDimension()) of the dataset that share the boundary `boundary' with this cell. `this' IS NOT INCLUDED. \pre boundary_exists: boundary!=0 \pre real_boundary: !boundary-&gt;IsInDataSet() \pre cell_of_the_dataset: IsInDataSet() \pre boundary: HasBoundary(boundary) \pre neighbors_exist: neighbors!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.CountEdgeNeighbors(System.Int32[])">
            <summary>
                <para>Number of cells (dimension&gt;boundary-&gt;GetDimension()) of the dataset that share the boundary `boundary' of `this'. `this' IS NOT INCLUDED. \pre boundary_exists: boundary!=0 \pre real_boundary: !boundary-&gt;IsInDataSet() \pre cell_of_the_dataset: IsInDataSet() \pre boundary: HasBoundary(boundary) \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.CountNeighbors(vtk.vtkGenericAdaptorCell)">
            <summary>
                <para>Number of cells (dimension&gt;boundary-&gt;GetDimension()) of the dataset that share the boundary `boundary' of `this'. `this' IS NOT INCLUDED. \pre boundary_exists: boundary!=0 \pre real_boundary: !boundary-&gt;IsInDataSet() \pre cell_of_the_dataset: IsInDataSet() \pre boundary: HasBoundary(boundary) \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetBoundaryIterator(vtk.vtkGenericCellIterator,System.Int32)">
            <summary>
                <para>Return the `boundaries' the cells of dimension `dim' (or all dimensions less than GetDimension() if -1) that are part of the boundary of the cell. \pre valid_dim_range: (dim==-1) || ((dim&gt;=0)&amp;&amp;(dim&lt;GetDimension())) \pre boundaries_exist: boundaries!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.NewCellIterator">
            <summary>
                <para>Create an empty cell iterator. The user is responsible for deleting it. \post result_exists: result!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetPointIterator(vtk.vtkGenericPointIterator)">
            <summary>
                <para>Return the points of cell into `it'. \pre it_exists: it!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetNumberOfDOFNodes">
            <summary>
                <para>Accumulated number of DOF nodes of the current cell. A DOF node is a component of cell with a given topological dimension. e.g.: a triangle has 4 DOF: 1 face and 3 edges. An hexahedron has 19 DOF: 1 region, 6 faces, and 12 edges.</para>
                <para>The number of vertices is not included in the count because vertices are a special case: a vertex will have at most a single field value associated with it; DOF nodes may have an arbitrary number of field values associated with them. \post valid_result: result==GetNumberOfBoundaries(-1)+1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetNumberOfBoundaries(System.Int32)">
            <summary>
                <para>Return the number of boundaries of dimension `dim' (or all dimensions greater than 0 and less than GetDimension() if -1) of the cell. When \a dim is -1, the number of vertices is not included in the count because vertices are a special case: a vertex will have at most a single field value associated with it; DOF nodes may have an arbitrary number of field values associated with them. \pre valid_dim_range: (dim==-1) || ((dim&gt;=0)&amp;&amp;(dim&lt;GetDimension())) \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetNumberOfPoints">
            <summary>
                <para>Return the number of points that compose the cell. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.IsPrimary">
            <summary>
                <para>Is the cell primary (i.e. not composite) ?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.IsAttributeLinear(vtk.vtkGenericAttribute)">
            <summary>
                <para>Does the attribute `a' have a non-linear interpolation? \pre a_exists: a!=0 \post definition: result==(GetAttributeOrder()==1)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetHighestOrderAttribute(vtk.vtkGenericAttributeCollection)">
            <summary>
                <para>Return the index of the first point centered attribute with the highest order in `ac'. \pre ac_exists: ac!=0 \post valid_result: result&gt;=-1 &amp;&amp; result&lt;ac-&gt;GetNumberOfAttributes()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetAttributeOrder(vtk.vtkGenericAttribute)">
            <summary>
                <para>Return the Interpolation order of attribute `a' on the cell (may differ by cell).   \pre a_exists: a!=0  \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.IsGeometryLinear">
            <summary>
                <para>Does the cell have a non-linear interpolation for the geometry? \post definition: result==(GetGeometryOrder()==1)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetGeometryOrder">
            <summary>
                <para>Return the interpolation order of the geometry. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetDimension">
            <summary>
                <para>Return the topological dimension of the current cell. \post valid_result: result&gt;=0 &amp;&amp; result&lt;=3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetType">
            <summary>
                <para>Return the type of the current cell. \post (result==VTK_HIGHER_ORDER_EDGE)||       (result==VTK_HIGHER_ORDER_TRIANGLE)||       (result==VTK_HIGHER_ORDER_TETRAHEDRON)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.IsInDataSet">
            <summary>
                <para>Does `this' a cell of a dataset? (otherwise, it is a boundary cell)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericAdaptorCell.GetId">
            <summary>
                <para>Unique identification number of the cell over the whole data set. This unique key may not be contiguous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCastToConcrete.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCastToConcrete.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCastToConcrete.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCastToConcrete.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCastToConcrete.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCastToConcrete.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.AddInput(System.Int32,vtk.vtkDataSet)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.AddInput(vtk.vtkDataSet)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.SetInput(System.Int32,vtk.vtkDataSet)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetRectilinearGridOutput">
            <summary>
                <para>Get the output as vtkRectilinearGrid. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetUnstructuredGridOutput">
            <summary>
                <para>Get the output as vtkUnstructuredGrid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetStructuredGridOutput">
            <summary>
                <para>Get the output as vtkStructuredGrid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetImageDataOutput">
            <summary>
                <para>Get the output as vtkStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetStructuredPointsOutput">
            <summary>
                <para>Get the output as vtkStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetPolyDataOutput">
            <summary>
                <para>Get the output as vtkPolyData.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetInput">
            <summary>
                <para>Get the input data object. This method is not recommended for use, but lots of old style filters use it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformation.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationUnsignedLongKey.Set(vtk.vtkInformation,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.Length(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.Get(vtk.vtkInformation,System.Int32[])">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerPointerKey.Set(vtk.vtkInformation,System.Int32[],System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.Report(vtk.vtkInformation,vtk.vtkGarbageCollector)">
            <summary>
                <para>Report a reference this key has in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.DeepCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Duplicate (new instance created) the entry associated with this key from one information object to another (new instances of any contained vtkInformation and vtkInformationVector objects are created).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationVectorKey.Set(vtk.vtkInformation,vtk.vtkInformationVector)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.Report(vtk.vtkInformation,vtk.vtkGarbageCollector)">
            <summary>
                <para>Report a reference this key has in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.Remove(vtk.vtkInformation)">
            <summary>
                <para>Remove this key from the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.Length(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.Remove(vtk.vtkInformation,vtk.vtkExecutive,System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortVectorKey.Append(vtk.vtkInformation,vtk.vtkExecutive,System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleKey.Set(vtk.vtkInformation,System.Double)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageToStructuredPoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageToStructuredPoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageToStructuredPoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageToStructuredPoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageToStructuredPoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageToStructuredPoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageToStructuredPoints.GetVectorInput">
            <summary>
                <para>Set/Get the input object from the image pipeline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToStructuredPoints.SetVectorInput(vtk.vtkImageData)">
            <summary>
                <para>Set/Get the input object from the image pipeline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLocator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSpline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSpline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSpline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSpline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSpline.DeepCopy(vtk.vtkSpline)">
            <summary>
                <para>Deep copy of spline data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetMTime">
            <summary>
                <para>Return the MTime also considering the Piecewise function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetRightValue">
            <summary>
                <para>The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.SetRightValue(System.Double)">
            <summary>
                <para>The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetLeftValue">
            <summary>
                <para>The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.SetLeftValue(System.Double)">
            <summary>
                <para>The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetRightConstraint">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetRightConstraintMaxValue">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetRightConstraintMinValue">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.SetRightConstraint(System.Int32)">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetLeftConstraint">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetLeftConstraintMaxValue">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetLeftConstraintMinValue">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.SetLeftConstraint(System.Int32)">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.ClosedOff">
            <summary>
                <para>Control whether the spline is open or closed. A closed spline forms a continuous loop: the first and last points are the same, and derivatives are continuous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.ClosedOn">
            <summary>
                <para>Control whether the spline is open or closed. A closed spline forms a continuous loop: the first and last points are the same, and derivatives are continuous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetClosed">
            <summary>
                <para>Control whether the spline is open or closed. A closed spline forms a continuous loop: the first and last points are the same, and derivatives are continuous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.SetClosed(System.Int32)">
            <summary>
                <para>Control whether the spline is open or closed. A closed spline forms a continuous loop: the first and last points are the same, and derivatives are continuous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.RemoveAllPoints">
            <summary>
                <para>Remove all points from the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.RemovePoint(System.Double)">
            <summary>
                <para>Remove a point from the data to be fit with the spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.AddPoint(System.Double,System.Double)">
            <summary>
                <para>Add a pair of points to be fit with the spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetNumberOfPoints">
            <summary>
                <para>Return the number of points inserted thus far.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.Evaluate(System.Double)">
            <summary>
                <para>Interpolate the value of the spline at parametric location of t.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.Compute">
            <summary>
                <para>Compute the coefficients for the spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.ClampValueOff">
            <summary>
                <para>Set/Get ClampValue. If On, results of the interpolation will be clamped to the min/max of the input data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.ClampValueOn">
            <summary>
                <para>Set/Get ClampValue. If On, results of the interpolation will be clamped to the min/max of the input data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetClampValue">
            <summary>
                <para>Set/Get ClampValue. If On, results of the interpolation will be clamped to the min/max of the input data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.SetClampValue(System.Int32)">
            <summary>
                <para>Set/Get ClampValue. If On, results of the interpolation will be clamped to the min/max of the input data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.GetParametricRange(System.Double[])">
            <summary>
                <para>Set/Get the parametric range. If not set, the range is determined implicitly by keeping track of the (min,max) parameter values for t. If set, the AddPoint() method will clamp the t value to lie within the specified range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.SetParametricRange(System.Double[])">
            <summary>
                <para>Set/Get the parametric range. If not set, the range is determined implicitly by keeping track of the (min,max) parameter values for t. If set, the AddPoint() method will clamp the t value to lie within the specified range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpline.SetParametricRange(System.Double,System.Double)">
            <summary>
                <para>Set/Get the parametric range. If not set, the range is determined implicitly by keeping track of the (min,max) parameter values for t. If set, the AddPoint() method will clamp the t value to lie within the specified range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricSpline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetRightValue">
            <summary>
                <para>The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetRightValue(System.Double)">
            <summary>
                <para>The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetLeftValue">
            <summary>
                <para>The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetLeftValue(System.Double)">
            <summary>
                <para>The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetRightConstraint">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetRightConstraintMaxValue">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetRightConstraintMinValue">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetRightConstraint(System.Int32)">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetLeftConstraint">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetLeftConstraintMaxValue">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetLeftConstraintMinValue">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetLeftConstraint(System.Int32)">
            <summary>
                <para>Set the type of constraint of the left(right) end points. Four constraints are available:</para>
                <para>0: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.</para>
                <para>1: the first derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>2: the second derivative at left(right) most point is set to Left(Right)Value.</para>
                <para>3: the second derivative at left(right)most points is Left(Right)Value times second derivative at first interior point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.ParameterizeByLengthOff">
            <summary>
                <para>Control whether the spline is parameterized by length or by point index. Default is by length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.ParameterizeByLengthOn">
            <summary>
                <para>Control whether the spline is parameterized by length or by point index. Default is by length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetParameterizeByLength">
            <summary>
                <para>Control whether the spline is parameterized by length or by point index. Default is by length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetParameterizeByLength(System.Int32)">
            <summary>
                <para>Control whether the spline is parameterized by length or by point index. Default is by length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.ClosedOff">
            <summary>
                <para>Control whether the spline is open or closed. A closed spline forms a continuous loop: the first and last points are the same, and derivatives are continuous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.ClosedOn">
            <summary>
                <para>Control whether the spline is open or closed. A closed spline forms a continuous loop: the first and last points are the same, and derivatives are continuous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetClosed">
            <summary>
                <para>Control whether the spline is open or closed. A closed spline forms a continuous loop: the first and last points are the same, and derivatives are continuous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetClosed(System.Int32)">
            <summary>
                <para>Control whether the spline is open or closed. A closed spline forms a continuous loop: the first and last points are the same, and derivatives are continuous.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetPoints">
            <summary>
                <para>Specify the list of points defining the spline. Do this by  specifying a vtkPoints array containing the points. Note that the order of the points in vtkPoints is the order that the splines will be fit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetPoints(vtk.vtkPoints)">
            <summary>
                <para>Specify the list of points defining the spline. Do this by  specifying a vtkPoints array containing the points. Note that the order of the points in vtkPoints is the order that the splines will be fit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetZSpline">
            <summary>
                <para>By default, this class is constructed with three instances of vtkCardinalSpline (for each of the x-y-z coordinate axes). The user may choose to create and assign their own instances of vtkSpline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetYSpline">
            <summary>
                <para>By default, this class is constructed with three instances of vtkCardinalSpline (for each of the x-y-z coordinate axes). The user may choose to create and assign their own instances of vtkSpline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetXSpline">
            <summary>
                <para>By default, this class is constructed with three instances of vtkCardinalSpline (for each of the x-y-z coordinate axes). The user may choose to create and assign their own instances of vtkSpline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetZSpline(vtk.vtkSpline)">
            <summary>
                <para>By default, this class is constructed with three instances of vtkCardinalSpline (for each of the x-y-z coordinate axes). The user may choose to create and assign their own instances of vtkSpline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetYSpline(vtk.vtkSpline)">
            <summary>
                <para>By default, this class is constructed with three instances of vtkCardinalSpline (for each of the x-y-z coordinate axes). The user may choose to create and assign their own instances of vtkSpline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.SetXSpline(vtk.vtkSpline)">
            <summary>
                <para>By default, this class is constructed with three instances of vtkCardinalSpline (for each of the x-y-z coordinate axes). The user may choose to create and assign their own instances of vtkSpline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Evaluate a scalar value at parametric coordinate u[0] and Pt[3]. The scalar value is just the parameter u[0].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Evaluate the spline at parametric coordinate u[0] returning the point coordinate Pt[3].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSpline.GetDimension">
            <summary>
                <para>Evaluate the spline at parametric coordinate u[0] returning the point coordinate Pt[3].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellTypes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellTypes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellTypes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellTypes.DeepCopy(vtk.vtkCellTypes)">
            <summary>
                <para>Standard DeepCopy method.  Since this object contains no reference to other objects, there is no ShallowCopy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.GetActualMemorySize">
            <summary>
                <para>Return the memory in kilobytes consumed by this cell type array.  Used to support streaming and reading/writing data. The value  returned is guaranteed to be greater than or equal to the memory  required to actually represent the data represented by this object.  The information returned is valid only after the pipeline has  been updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.Reset">
            <summary>
                <para>Initialize object without releasing memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.Squeeze">
            <summary>
                <para>Reclaim any extra memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.GetCellType(System.Int32)">
            <summary>
                <para>Return the type of cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.InsertNextType(System.Byte)">
            <summary>
                <para>Add the type specified to the end of the list. Range checking is performed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.IsType(System.Byte)">
            <summary>
                <para>Return 1 if type specified is contained in list; 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.GetNumberOfTypes">
            <summary>
                <para>Return the number of types in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.DeleteCell(System.Int32)">
            <summary>
                <para>Delete cell by setting to NULL cell type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.GetCellLocation(System.Int32)">
            <summary>
                <para>Return the location of the cell in the associated vtkCellArray.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.SetCellTypes(System.Int32,vtk.vtkUnsignedCharArray,vtk.vtkIntArray)">
            <summary>
                <para>Specify a group of cell types.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.InsertNextCell(System.Byte,System.Int32)">
            <summary>
                <para>Add a cell to the object in the next available slot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.InsertCell(System.Int32,System.Byte,System.Int32)">
            <summary>
                <para>Add a cell at specified id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellTypes.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate memory for this array. Delete old storage only if necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSuperquadric.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetToroidal(System.Int32)">
            <summary>
                <para>Set/Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetToroidal">
            <summary>
                <para>Set/Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.ToroidalOff">
            <summary>
                <para>Set/Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.ToroidalOn">
            <summary>
                <para>Set/Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetSize">
            <summary>
                <para>Set/Get Superquadric isotropic size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetSize(System.Double)">
            <summary>
                <para>Set/Get Superquadric isotropic size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetThetaRoundness(System.Double)">
            <summary>
                <para>Set/Get Superquadric east/west roundness. Values range from 0 (rectangular) to 1 (circular) to higher orders.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetThetaRoundness">
            <summary>
                <para>Set/Get Superquadric east/west roundness. Values range from 0 (rectangular) to 1 (circular) to higher orders.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetPhiRoundness(System.Double)">
            <summary>
                <para>Set/Get Superquadric north/south roundness.  Values range from 0 (rectangular) to 1 (circular) to higher orders.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetPhiRoundness">
            <summary>
                <para>Set/Get Superquadric north/south roundness.  Values range from 0 (rectangular) to 1 (circular) to higher orders.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetThicknessMaxValue">
            <summary>
                <para>Set/Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetThicknessMinValue">
            <summary>
                <para>Set/Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetThickness(System.Double)">
            <summary>
                <para>Set/Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetThickness">
            <summary>
                <para>Set/Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetScale">
            <summary>
                <para>Set the scale factors of the superquadric. Default is 1,1,1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetScale(System.Double[])">
            <summary>
                <para>Set the scale factors of the superquadric. Default is 1,1,1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetScale(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the scale factors of the superquadric. Default is 1,1,1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.GetCenter">
            <summary>
                <para>Set the center of the superquadric. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetCenter(System.Double[])">
            <summary>
                <para>Set the center of the superquadric. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadric.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the center of the superquadric. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithmOutput.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAlgorithmOutput.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredPoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredPoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.Crop">
            <summary>
                <para>Reallocates and copies to set the Extent to the UpdateExtent. This is used internally when the exact extent is requested,  and the source generated more than the update extent. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetExtentType">
            <summary>
                <para>Structured extent. The extent type is a 3D extent</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetActualMemorySize">
            <summary>
                <para>Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetExtent">
            <summary>
                <para>Different ways to set the extent of the data array.  The extent should be set before the "Scalars" are set or allocated. The Extent is stored  in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.SetExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Different ways to set the extent of the data array.  The extent should be set before the "Scalars" are set or allocated. The Extent is stored  in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.SetExtent(System.Int32[])">
            <summary>
                <para>Different ways to set the extent of the data array.  The extent should be set before the "Scalars" are set or allocated. The Extent is stored  in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetZCoordinates">
            <summary>
                <para>Specify the grid coordinates in the z-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.SetZCoordinates(vtk.vtkDataArray)">
            <summary>
                <para>Specify the grid coordinates in the z-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetYCoordinates">
            <summary>
                <para>Specify the grid coordinates in the y-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.SetYCoordinates(vtk.vtkDataArray)">
            <summary>
                <para>Specify the grid coordinates in the y-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetXCoordinates">
            <summary>
                <para>Specify the grid coordinates in the x-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.SetXCoordinates(vtk.vtkDataArray)">
            <summary>
                <para>Specify the grid coordinates in the x-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.ComputeCellId(System.Int32[])">
            <summary>
                <para>Given a location in structured coordinates (i-j-k), return the cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.ComputePointId(System.Int32[])">
            <summary>
                <para>Given a location in structured coordinates (i-j-k), return the point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.ComputeStructuredCoordinates(System.Double[],System.Int32[],System.Double[])">
            <summary>
                <para>Convenience function computes the structured coordinates for a point x[3]. The cell is specified by the array ijk[3], and the parametric coordinates in the cell are specified with pcoords[3]. The function returns a 0 if the point x is outside of the grid, and a 1 if inside the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetDataDimension">
            <summary>
                <para>Return the dimensionality of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetDimensions">
            <summary>
                <para>Get dimensions of this rectilinear grid dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.SetDimensions(System.Int32[])">
            <summary>
                <para>Set dimensions of rectilinear grid dataset. This also sets the extent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.SetDimensions(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set dimensions of rectilinear grid dataset. This also sets the extent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetCellNeighbors(System.Int32,vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetMaxCellSize">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.ComputeBounds">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetPointCells(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetCellPoints(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetCellType(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.FindAndGetCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.FindCell(System.Double[],vtk.vtkCell,vtk.vtkGenericCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.FindCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.FindPoint(System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.FindPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetCellBounds(System.Int32,System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetCell(System.Int32,vtk.vtkGenericCell)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetCell(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetPoint(System.Int32,System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetPoint(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetNumberOfPoints">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetNumberOfCells">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.Initialize">
            <summary>
                <para>Restore object to initial state. Release memory back to system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.CopyStructure(vtk.vtkDataSet)">
            <summary>
                <para>Copy the geometric and topological structure of an input rectilinear grid object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGrid.GetDataObjectType">
            <summary>
                <para>Return what type of dataset this is.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.ComputeInputUpdateExtents(vtk.vtkDataObject)">
            <summary>
                <para>By default copy the output update extent to the input</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.GetInput">
            <summary>
                <para>Get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.GetRectilinearGridOutput">
            <summary>
                <para>Get the output as vtkRectilinearGrid. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.GetUnstructuredGridOutput">
            <summary>
                <para>Get the output as vtkUnstructuredGrid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.GetStructuredGridOutput">
            <summary>
                <para>Get the output as vtkStructuredGrid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.GetStructuredPointsOutput">
            <summary>
                <para>Get the output as vtkStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.GetPolyDataOutput">
            <summary>
                <para>Get the output as vtkPolyData.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this filter. If output is NULL then input hasn't been set which is necessary for abstract objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.GetOutput">
            <summary>
                <para>Get the output of this filter. If output is NULL then input hasn't been set which is necessary for abstract objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataSetFilter.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Specify the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetSource.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSource.GetOutput">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.GetError(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Return the error at the mid-point. The type of error depends on the state of the concrete error metric. For instance, it can return an absolute or relative error metric. See RequiresEdgeSubdivision() for a description of the arguments. \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6 \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.RequiresEdgeSubdivision(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Does the edge need to be subdivided according to the distance between the line passing through its endpoints in screen space and the projection of its mid point? The edge is defined by its `leftPoint' and its `rightPoint'. `leftPoint', `midPoint' and `rightPoint' have to be initialized before calling RequiresEdgeSubdivision(). Their format is global coordinates, parametric coordinates and point centered attributes: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.SetViewport(vtk.vtkViewport)">
            <summary>
                <para>Set/Get the renderer with `renderer' on which the error metric  is based. The error metric use the active camera of the renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.GetViewport">
            <summary>
                <para>Set/Get the renderer with `renderer' on which the error metric  is based. The error metric use the active camera of the renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.SetPixelTolerance(System.Double)">
            <summary>
                <para>Set the squared screen-based geometric accuracy measured in pixels. Subdivision will be required if the square distance between the projection of the real point and the straight line passing through the projection of the vertices of the edge is greater than `value'. For instance, 0.25 will give better result than 1. \pre positive_value: value&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.GetPixelTolerance">
            <summary>
                <para>Return the squared screen-based geometric accurary measured in pixels. An accuracy less or equal to 0.25 (0.5^2) ensures that the screen-space interpolation of a mid-point matchs exactly with the projection of the mid-point (a value less than 1 but greater than 0.25 is not enough, because of 8-neighbors). Maybe it is useful for lower accuracy in case of anti-aliasing? \post positive_result: result&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.NewInstance">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.IsA(System.String)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewDependentErrorMetric.GetClassName">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExplicitCell.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.GetDataSet">
            <summary>
                <para>Set/Get the mesh that owns this cell. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.SetDataSet(vtk.vtkDataSet)">
            <summary>
                <para>Set/Get the mesh that owns this cell. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.GetCellId">
            <summary>
                <para>Set/Get the cell id. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.SetCellId(System.Int32)">
            <summary>
                <para>Set/Get the cell id. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExplicitCell.IsExplicitCell">
            <summary>
                <para>Set/Get the cell id. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToImageFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToImageFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToImageFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetToImageFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetToImageFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToImageFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToImageFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToImageFilter.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericDataSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetEstimatedSize">
            <summary>
                <para>Estimated size needed after tessellation (or special operation)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetDataObjectType">
            <summary>
                <para>Return the type of data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetActualMemorySize">
            <summary>
                <para>Actual size of the data in kilobytes; only valid after the pipeline has updated. It is guaranteed to be greater than or equal to the memory required to represent the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetTessellator">
            <summary>
                <para>Set/Get a cell tessellator if cells must be tessellated during processing. \pre tessellator_exists: tessellator!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.SetTessellator(vtk.vtkGenericCellTessellator)">
            <summary>
                <para>Set/Get a cell tessellator if cells must be tessellated during processing. \pre tessellator_exists: tessellator!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetAttributes">
            <summary>
                <para>Get the collection of attributes associated with this dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetLength">
            <summary>
                <para>Return the length of the diagonal of the bounding box. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetCenter(System.Double[])">
            <summary>
                <para>Get the center of the bounding box in global coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetBounds(System.Double[])">
            <summary>
                <para>Return the geometry bounding box in global coordinates in the form (xmin,xmax, ymin,ymax, zmin,zmax) in the `bounds' array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.ComputeBounds">
            <summary>
                <para>Compute the geometry bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetMTime">
            <summary>
                <para>Datasets are composite objects and need to check each part for their modified time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.FindPoint(System.Double[],vtk.vtkGenericPointIterator)">
            <summary>
                <para>Locate the closest point `p' to position `x' (global coordinates). \pre not_empty: GetNumberOfPoints()&gt;0 \pre p_exists: p!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.NewPointIterator">
            <summary>
                <para>Return an iterator to traverse the points composing the dataset; they can be points that define a cell or isolated. The user is responsible for deleting the iterator. \post result_exists: result!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.NewBoundaryIterator(System.Int32,System.Int32)">
            <summary>
                <para>Return an iterator to traverse cell boundaries of dimension `dim' (or all dimensions if -1) of the dataset.  If `exteriorOnly' is true, only the exterior cell boundaries of the dataset will be returned, otherwise it will return exterior and interior cell boundaries. The user is responsible for deleting the iterator. \pre valid_dim_range: (dim&gt;=-1) &amp;&amp; (dim&lt;=2) \post result_exists: result!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.NewCellIterator(System.Int32)">
            <summary>
                <para>Return an iterator to traverse cells of dimension `dim' (or all dimensions if -1) that explicitly define the dataset. For instance, it will return only tetrahedra if the mesh is defined by tetrahedra. If the mesh is composed of two parts, one with tetrahedra and another part with triangles, it will return both, but will not return the boundary edges and vertices of these cells. The user is responsible for deleting the iterator. \pre valid_dim_range: (dim&gt;=-1) &amp;&amp; (dim&lt;=3) \post result_exists: result!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetCellTypes(vtk.vtkCellTypes)">
            <summary>
                <para>Get a list of types of cells in a dataset. The list consists of an array of types (not necessarily in any order), with a single entry per type. For example a dataset 5 triangles, 3 lines, and 100 hexahedra would result a list of three entries, corresponding to the types VTK_TRIANGLE, VTK_LINE, and VTK_HEXAHEDRON. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED \pre types_exist: types!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetCellDimension">
            <summary>
                <para>Return -1 if the dataset is explicitly defined by cells of varying dimensions or if there are no cells. If the dataset is explicitly defined by cells of a unique dimension, return this dimension. \post valid_range: (result&gt;=-1) &amp;&amp; (result&lt;=3)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetNumberOfCells(System.Int32)">
            <summary>
                <para>Return the number of cells that explicitly define the dataset. See  NewCellIterator() for more details. \pre valid_dim_range: (dim&gt;=-1) &amp;&amp; (dim&lt;=3) \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetNumberOfPoints">
            <summary>
                <para>Return the number of points composing the dataset. See NewPointIterator() for more details. \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.NewInstance">
            <summary>
                <para>Standard VTK type and print macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.IsA(System.String)">
            <summary>
                <para>Standard VTK type and print macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericDataSet.GetClassName">
            <summary>
                <para>Standard VTK type and print macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.GetRelative">
            <summary>
                <para>Return the type of output of GetError()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.GetError(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Return the error at the mid-point. It will return an error relative to the bounding box size if GetRelative() is true, a square absolute error otherwise. See RequiresEdgeSubdivision() for a description of the arguments. \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6 \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.RequiresEdgeSubdivision(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Does the edge need to be subdivided according to the distance between the line passing through its endpoints and the mid point? The edge is defined by its `leftPoint' and its `rightPoint'. `leftPoint', `midPoint' and `rightPoint' have to be initialized before calling RequiresEdgeSubdivision(). Their format is global coordinates, parametric coordinates and point centered attributes: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.SetRelativeGeometricTolerance(System.Double,vtk.vtkGenericDataSet)">
            <summary>
                <para>Set the geometric accuracy with a value relative to the length of the bounding box of the dataset. Internally compute the absolute tolerance. For instance 0.01 will give better result than 0.1. \pre valid_range_value: value&gt;0 &amp;&amp; value&lt;1 \pre ds_exists: ds!=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.SetAbsoluteGeometricTolerance(System.Double)">
            <summary>
                <para>Set the geometric accuracy with a squared absolute value. This is the geometric object-based accuracy. Subdivision will be required if the square distance between the real point and the straight line passing through the vertices of the edge is greater than `value'. For instance 0.01 will give better result than 0.1. \pre positive_value: value&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.GetAbsoluteGeometricTolerance">
            <summary>
                <para>Return the squared absolute geometric accuracy. See SetAbsoluteGeometricTolerance() for details. \post positive_result: result&gt;0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.NewInstance">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.IsA(System.String)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometricErrorMetric.GetClassName">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.GetDataSet">
            <summary>
                <para>Set/Get the dataset to be tessellated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.SetDataSet(vtk.vtkGenericDataSet)">
            <summary>
                <para>Set/Get the dataset to be tessellated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.GetGenericCell">
            <summary>
                <para>The cell that the edge belongs to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.SetGenericCell(vtk.vtkGenericAdaptorCell)">
            <summary>
                <para>The cell that the edge belongs to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.GetError(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Return the error at the mid-point. The type of error depends on the state of the concrete error metric. For instance, it can return an absolute or relative error metric. See RequiresEdgeSubdivision() for a description of the arguments. \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6 \post positive_result: result&gt;=0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.RequiresEdgeSubdivision(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Does the edge need to be subdivided according to the implemented computation? The edge is defined by its `leftPoint' and its `rightPoint'. `leftPoint', `midPoint' and `rightPoint' have to be initialized before calling RequiresEdgeSubdivision(). Their format is global coordinates, parametric coordinates and point centered attributes: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \pre leftPoint_exists: leftPoint!=0 \pre midPoint_exists: midPoint!=0 \pre rightPoint_exists: rightPoint!=0 \pre clamped_alpha: alpha&gt;0 &amp;&amp; alpha&lt;1 \pre valid_size: sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)          =GetAttributeCollection()-&gt;GetNumberOfPointCenteredComponents()+6</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.NewInstance">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.IsA(System.String)">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericSubdivisionErrorMetric.GetClassName">
            <summary>
                <para>Standard VTK type and error macros.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToUnstructuredGridFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToUnstructuredGridFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToUnstructuredGridFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredPointsToUnstructuredGridFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToUnstructuredGridFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToUnstructuredGridFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToUnstructuredGridFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToUnstructuredGridFilter.SetInput(vtk.vtkImageData)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredGridToPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToPolyDataFilter.GetInput">
            <summary>
                <para>Set / get the input Grid or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridToPolyDataFilter.SetInput(vtk.vtkStructuredGrid)">
            <summary>
                <para>Set / get the input Grid or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageInPlaceFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageInPlaceFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageInPlaceFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageInPlaceFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageInPlaceFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageInPlaceFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.DeepCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Duplicate (new instance created) the entry associated with this key from one information object to another (new instances of any contained vtkInformation and vtkInformationVector objects are created).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationInformationKey.Set(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.InitTraversal(System.Double)">
            <summary>
                <para>Begin to traverse the cells based on a scalar value. Returned cells will have scalar values that span the scalar value specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.Initialize">
            <summary>
                <para>Initialize locator. Frees memory and resets object as appropriate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.BuildTree">
            <summary>
                <para>Construct the scalar tree from the dataset provided. Checks build times and modified time from input and reconstructs the tree if necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.GetMaxLevel">
            <summary>
                <para>Set the maximum allowable level for the tree. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.GetMaxLevelMaxValue">
            <summary>
                <para>Set the maximum allowable level for the tree. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.GetMaxLevelMinValue">
            <summary>
                <para>Set the maximum allowable level for the tree. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.SetMaxLevel(System.Int32)">
            <summary>
                <para>Set the maximum allowable level for the tree. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.GetLevel">
            <summary>
                <para>Get the level of the scalar tree. This value may change each time the scalar tree is built and the branching factor changes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.GetBranchingFactor">
            <summary>
                <para>Set the branching factor for the tree. This is the number of children per tree node. Smaller values (minimum is 2) mean deeper trees and more memory overhead. Larger values mean shallower trees, less memory usage, but worse performance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.GetBranchingFactorMaxValue">
            <summary>
                <para>Set the branching factor for the tree. This is the number of children per tree node. Smaller values (minimum is 2) mean deeper trees and more memory overhead. Larger values mean shallower trees, less memory usage, but worse performance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.GetBranchingFactorMinValue">
            <summary>
                <para>Set the branching factor for the tree. This is the number of children per tree node. Smaller values (minimum is 2) mean deeper trees and more memory overhead. Larger values mean shallower trees, less memory usage, but worse performance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.SetBranchingFactor(System.Int32)">
            <summary>
                <para>Set the branching factor for the tree. This is the number of children per tree node. Smaller values (minimum is 2) mean deeper trees and more memory overhead. Larger values mean shallower trees, less memory usage, but worse performance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard type related macros and PrintSelf() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.NewInstance">
            <summary>
                <para>Standard type related macros and PrintSelf() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.IsA(System.String)">
            <summary>
                <para>Standard type related macros and PrintSelf() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleScalarTree.GetClassName">
            <summary>
                <para>Standard type related macros and PrintSelf() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarTree.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkScalarTree.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkScalarTree.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkScalarTree.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkScalarTree.InitTraversal(System.Double)">
            <summary>
                <para>Begin to traverse the cells based on a scalar value. Returned cells will have scalar values that span the scalar value specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarTree.Initialize">
            <summary>
                <para>Initialize locator. Frees memory and resets object as appropriate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarTree.BuildTree">
            <summary>
                <para>Construct the scalar tree from the dataset provided. Checks build times and modified time from input and reconstructs the tree if necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarTree.GetDataSet">
            <summary>
                <para>Build the tree from the points/cells defining this dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarTree.SetDataSet(vtk.vtkDataSet)">
            <summary>
                <para>Build the tree from the points/cells defining this dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCell.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCell.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToUnstructuredGridFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToUnstructuredGridFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToUnstructuredGridFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToUnstructuredGridFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToUnstructuredGridFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToUnstructuredGridFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToUnstructuredGridFilter.GetInput">
            <summary>
                <para>Set / get the input Grid or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridToUnstructuredGridFilter.SetInput(vtk.vtkUnstructuredGrid)">
            <summary>
                <para>Set / get the input Grid or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.SetOutput(vtk.vtkUnstructuredGrid)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridSource.GetOutput">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.Report(vtk.vtkInformation,vtk.vtkGarbageCollector)">
            <summary>
                <para>Report a reference this key has in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDataObjectKey.Set(vtk.vtkInformation,vtk.vtkDataObject)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.GetCurrentDataObject">
            <summary>
                <para>Get the current item. Valid only when IsDoneWithTraversal() returns 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.IsDoneWithTraversal">
            <summary>
                <para>Test whether the iterator is currently pointing to a valid item. Returns 1 for yes, 0 for no.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.GoToNextItem">
            <summary>
                <para>Move the iterator to the next item in the collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.GoToFirstItem">
            <summary>
                <para>Move the iterator to the beginning of the collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataIterator.InitTraversal">
            <summary>
                <para>Move the iterator to the beginning of the collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPyramid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPyramid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPyramid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPyramid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPyramid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPyramid.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Pyramid specific methods for computing interpolation functions and derivatives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Pyramid specific methods for computing interpolation functions and derivatives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the pyramid in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPyramid.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationStringKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationStringKey.Set(vtk.vtkInformation,System.String)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPerlinNoise.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.GetAmplitude">
            <summary>
                <para>Set/get the amplitude of the noise function.  By default, the amplitude is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.SetAmplitude(System.Double)">
            <summary>
                <para>Set/get the amplitude of the noise function.  By default, the amplitude is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.GetPhase">
            <summary>
                <para>Set/get the phase of the noise function.  This parameter can be used to shift the noise function within space (perhaps to avoid a beat with a noise pattern at another scale).  Phase tends to repeat about every unit, so a phase of 0.5 is a half-cycle shift.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.SetPhase(System.Double[])">
            <summary>
                <para>Set/get the phase of the noise function.  This parameter can be used to shift the noise function within space (perhaps to avoid a beat with a noise pattern at another scale).  Phase tends to repeat about every unit, so a phase of 0.5 is a half-cycle shift.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.SetPhase(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/get the phase of the noise function.  This parameter can be used to shift the noise function within space (perhaps to avoid a beat with a noise pattern at another scale).  Phase tends to repeat about every unit, so a phase of 0.5 is a half-cycle shift.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.GetFrequency">
            <summary>
                <para>Set/get the frequency, or physical scale,  of the noise function  (higher is finer scale).  The frequency can be adjusted per axis, or the same for all axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.SetFrequency(System.Double[])">
            <summary>
                <para>Set/get the frequency, or physical scale,  of the noise function  (higher is finer scale).  The frequency can be adjusted per axis, or the same for all axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.SetFrequency(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/get the frequency, or physical scale,  of the noise function  (higher is finer scale).  The frequency can be adjusted per axis, or the same for all axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.EvaluateGradient(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate PerlinNoise gradient.  Currently, the method returns a 0  gradient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.EvaluateFunction(System.Double,System.Double,System.Double)">
            <summary>
                <para>Evaluate PerlinNoise function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerlinNoise.EvaluateFunction(System.Double[])">
            <summary>
                <para>Evaluate PerlinNoise function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPixel.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPixel.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPixel.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPixel.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPixel.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPixel.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPixel.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Pixel specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Pixel specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the triangle in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPixel.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.SplitExtent(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
                <para>Putting this here until I merge graphics and imaging streaming.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.GetNumberOfThreads">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.GetNumberOfThreadsMaxValue">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.GetNumberOfThreadsMinValue">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.SetNumberOfThreads(System.Int32)">
            <summary>
                <para>Get/Set the number of threads to create when rendering</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.ThreadedExecute(vtk.vtkImageData,vtk.vtkImageData,System.Int32[],System.Int32)">
            <summary>
                <para>If the subclass does not define an Execute method, then the task will be broken up, multiple threads will be spawned, and each thread will call this method. It is public so that the thread functions can call this method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.GetBypass">
            <summary>
                <para>Obsolete feature - do not use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.BypassOff">
            <summary>
                <para>Obsolete feature - do not use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.BypassOn">
            <summary>
                <para>Obsolete feature - do not use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.SetBypass(System.Int32)">
            <summary>
                <para>Obsolete feature - do not use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.GetInput">
            <summary>
                <para>Set the Input of a filter. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToImageFilter.SetInput(vtk.vtkImageData)">
            <summary>
                <para>Set the Input of a filter. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageSource.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageSource.GetOutput">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageSource.SetOutput(vtk.vtkImageData)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellLinks.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellLinks.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellLinks.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellLinks.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellLinks.DeepCopy(vtk.vtkCellLinks)">
            <summary>
                <para>Standard DeepCopy method.  Since this object contains no reference to other objects, there is no ShallowCopy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.GetActualMemorySize">
            <summary>
                <para>Return the memory in kilobytes consumed by this cell links array.  Used to support streaming and reading/writing data. The value  returned is guaranteed to be greater than or equal to the memory  required to actually represent the data represented by this object.  The information returned is valid only after the pipeline has  been updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.Reset">
            <summary>
                <para>Reset to a state of no entries without freeing the memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.Squeeze">
            <summary>
                <para>Reclaim any unused memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.ResizeCellList(System.Int32,System.Int32)">
            <summary>
                <para>Change the length of a point's link list (i.e., list of cells using a point) by the size specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.AddCellReference(System.Int32,System.Int32)">
            <summary>
                <para>Add the reference to the cell (cellId) from the point (ptId). This adds a reference to the cellId from the cell list, but does not resize the list (extend memory with ResizeCellList(), if necessary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.RemoveCellReference(System.Int32,System.Int32)">
            <summary>
                <para>Delete the reference to the cell (cellId) from the point (ptId). This removes the reference to the cellId from the cell list, but does not resize the list (recover memory with ResizeCellList(), if necessary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.DeletePoint(System.Int32)">
            <summary>
                <para>Delete point (and storage) by destroying links to using cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.InsertNextCellReference(System.Int32,System.Int32)">
            <summary>
                <para>Insert a cell id into the list of cells (at the end) using the cell id  provided. (Make sure to extend the link list (if necessary) using the method ResizeCellList().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.InsertNextPoint(System.Int32)">
            <summary>
                <para>Insert a new point into the cell-links data structure. The size parameter is the initial size of the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.BuildLinks(vtk.vtkDataSet,vtk.vtkCellArray)">
            <summary>
                <para>Build the link list array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.BuildLinks(vtk.vtkDataSet)">
            <summary>
                <para>Build the link list array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.GetNcells(System.Int32)">
            <summary>
                <para>Get the number of cells using the point specified by ptId.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLinks.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate the specified number of links (i.e., number of points) that will be built.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkEmptyCell.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEmptyCell.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVertex.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVertex.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVertex.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVertex.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVertex.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVertex.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Vertex specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>Get the derivative of the vertex. Returns (0.0, 0.0, 0.0) for all  dimensions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>Triangulate the vertex. This method fills pts and ptIds with information from the only point in the vertex.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Intersect with a ray. Return parametric coordinates (both line and cell) and global intersection coordinates, given ray definition and tolerance.  The method returns non-zero value if intersection occurs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the triangle in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>Generate contouring primitives. The scalar list cellScalars are scalar values at each cell point. The point locator is essentially a  points list that merges points as they are inserted (i.e., prevents  duplicates). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>Given parametric coordinates of a point, return the closest cell boundary, and whether the point is inside or outside of the cell. The cell boundary is defined by a list of points (pts) that specify a vertex (1D cell).  If the return value of the method is != 0, then the point is inside the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVertex.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTriangleStrip.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.DecomposeStrip(System.Int32,System.Int32[],vtk.vtkCellArray)">
            <summary>
                <para>Given a triangle strip, decompose it into a list of (triangle)  polygons. The polygons are appended to the end of the list of triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the point cloud in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.IsPrimaryCell">
            <summary>
                <para>Return the center of the point cloud in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleStrip.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIdTypeKey.Set(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.GetNumberOfPoints">
            <summary>
                <para>Returns the total number of points of all blocks. This will iterate over all blocks and call GetNumberOfPoints() so it might be expansive. Does not include the number of blanked points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.GenerateVisibilityArrays">
            <summary>
                <para>Blank lower level cells if they are overlapped by higher level ones.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.GetRefinementRatio(System.UInt32)">
            <summary>
                <para>Returns the refinement of a given level.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.SetRefinementRatio(System.UInt32,System.Int32)">
            <summary>
                <para>Sets the refinement of a given level.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalBoxDataSet.GetDataSet(vtk.vtkInformation)">
            <summary>
                <para>Sets the refinement of a given level.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.GetNumberOfPoints">
            <summary>
                <para>Returns the total number of points of all blocks. This will iterate over all blocks and call GetNumberOfPoints() so it might be expansive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.SetHierarchicalDataInformation(vtk.vtkHierarchicalDataInformation)">
            <summary>
                <para>Set the information about the datasets.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.GetHierarchicalDataInformation">
            <summary>
                <para>Returns the data structure containing information about the datasets.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.GetDataSet(vtk.vtkInformation)">
            <summary>
                <para>Uses keys LEVEL() and INDEX() to call GetDataSet(LEVEL, INDEX)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.GetDataSet(System.UInt32,System.UInt32)">
            <summary>
                <para>Get a dataset give a level and an id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.AddDataSet(vtk.vtkInformation,vtk.vtkDataObject)">
            <summary>
                <para>Uses keys LEVEL() and INDEX() to call SetDataSet(LEVEL, INDEX, dobj)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.SetDataSet(System.UInt32,System.UInt32,vtk.vtkDataObject)">
            <summary>
                <para>Set the dataset pointer for a given node. This method does not remove the existing parent/child links. It only replaces the dataset pointer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.InitializeNode(System.UInt32,System.UInt32)">
            <summary>
                <para>Initialize the entry for a dataset node. This removes all parent/child links between the given node and others.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.GetNumberOfDataSets(System.UInt32)">
            <summary>
                <para>Returns the number of datasets in a given level.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.SetNumberOfDataSets(System.UInt32,System.UInt32)">
            <summary>
                <para>Set the number of datasets in a given level. This call might cause allocation if the new number of datasets is larger than the current one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.GetNumberOfLevels">
            <summary>
                <para>Returns the number of levels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.SetNumberOfLevels(System.UInt32)">
            <summary>
                <para>Set the number of refinement levels. This call might cause allocation if the new number of levels is larger than the current one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.Initialize">
            <summary>
                <para>Restore data object to initial state,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.GetDataObjectType">
            <summary>
                <para>Restore data object to initial state,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSet.NewIterator">
            <summary>
                <para>Return a new (forward) iterator  (the iterator has to be deleted by user)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.GetProducerPort">
            <summary>
                <para>Get the port currently producing this object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.SetPipelineInformation(vtk.vtkInformation)">
            <summary>
                <para>Set the pipeline information object that owns this data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.GetDataSet(vtk.vtkInformation)">
            <summary>
                <para>Returns a dataset pointed by appropriate keys in the index information object.  Which keys are used depends on the actual subclass.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.AddDataSet(vtk.vtkInformation,vtk.vtkDataObject)">
            <summary>
                <para>Adds dobj to the composite dataset. Where the dataset goes is determined by appropriate keys in the index information object. Which keys are used depends on the actual subclass.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.Initialize">
            <summary>
                <para>Restore data object to initial state,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.GetDataObjectType">
            <summary>
                <para>Restore data object to initial state,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCompositeDataSet.NewIterator">
            <summary>
                <para>Return a new (forward) iterator  (the iterator has to be deleted by user)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.Remove(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationRequestKey.Set(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.Report(vtk.vtkInformation,vtk.vtkGarbageCollector)">
            <summary>
                <para>Report a reference this key has in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationObjectBaseKey.Set(vtk.vtkInformation,vtk.vtkObjectBase)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.Get(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerKey.Set(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.Length(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.Get(vtk.vtkInformation,System.Double[])">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.Set(vtk.vtkInformation,System.Double[],System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationDoubleVectorKey.Append(vtk.vtkInformation,System.Double)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.UPDATE_TIME_INDEX">
            <summary>
                <para>Update time requested by the pipeline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.TIME_STEPS">
            <summary>
                <para>Key to store available time steps.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.EXACT_EXTENT">
            <summary>
                <para>Key to specify the request for exact extent in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.WHOLE_BOUNDING_BOX">
            <summary>
                <para>Key to store the bounding box of the entire data set in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.MAXIMUM_NUMBER_OF_PIECES">
            <summary>
                <para>Key to store the maximum number of pieces provided in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.WHOLE_EXTENT">
            <summary>
                <para>Key to store the whole extent provided in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.UPDATE_NUMBER_OF_GHOST_LEVELS">
            <summary>
                <para>Keys to store an update request in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.UPDATE_NUMBER_OF_PIECES">
            <summary>
                <para>Keys to store an update request in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.UPDATE_PIECE_NUMBER">
            <summary>
                <para>Keys to store an update request in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.UPDATE_EXTENT">
            <summary>
                <para>Keys to store an update request in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.UPDATE_EXTENT_INITIALIZED">
            <summary>
                <para>Keys to store an update request in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.EXTENT_TRANSLATOR">
            <summary>
                <para>Key to store an extent translator in pipeline information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.CONTINUE_EXECUTING">
            <summary>
                <para>Key for an algorithm to store in a request to tell this executive to keep executing it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.REQUEST_UPDATE_EXTENT">
            <summary>
                <para>Key defining a request to propagate the update extent upstream.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetWholeBoundingBox(System.Int32,System.Double[])">
            <summary>
                <para>Set/Get the whole bounding box of an output port data object. The whole whole bounding box is meta data for data sets.  It gets set by the algorithm during the update information pass.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetWholeBoundingBox(System.Int32,System.Double[])">
            <summary>
                <para>Set/Get the whole bounding box of an output port data object. The whole whole bounding box is meta data for data sets.  It gets set by the algorithm during the update information pass.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetExtentTranslator(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the object that will translate pieces into structured extents for an output port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetExtentTranslator(vtk.vtkInformation,vtk.vtkExtentTranslator)">
            <summary>
                <para>Get/Set the object that will translate pieces into structured extents for an output port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetRequestExactExtent(System.Int32)">
            <summary>
                <para>This request flag indicates whether the requester can handle more data than requested for the given port.  Right now it is used in vtkImageData.  Image filters can return more data than requested. The the consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself.  This functionality used to be in ImageToStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetRequestExactExtent(System.Int32,System.Int32)">
            <summary>
                <para>This request flag indicates whether the requester can handle more data than requested for the given port.  Right now it is used in vtkImageData.  Image filters can return more data than requested. The the consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself.  This functionality used to be in ImageToStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetUpdateGhostLevel(vtk.vtkInformation)">
            <summary>
                <para>Set/Get the update piece, update number of pieces, and update number of ghost levels for an output port.  Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetUpdateGhostLevel(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>Set/Get the update piece, update number of pieces, and update number of ghost levels for an output port.  Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetUpdateNumberOfPieces(vtk.vtkInformation)">
            <summary>
                <para>Set/Get the update piece, update number of pieces, and update number of ghost levels for an output port.  Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetUpdateNumberOfPieces(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>Set/Get the update piece, update number of pieces, and update number of ghost levels for an output port.  Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetUpdatePiece(vtk.vtkInformation)">
            <summary>
                <para>Set/Get the update piece, update number of pieces, and update number of ghost levels for an output port.  Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetUpdatePiece(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>Set/Get the update piece, update number of pieces, and update number of ghost levels for an output port.  Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetUpdateExtent(vtk.vtkInformation,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the update piece, update number of pieces, and update number of ghost levels for an output port.  Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetUpdateExtent(vtk.vtkInformation,System.Int32[])">
            <summary>
                <para>Get/Set the update extent for output ports that use 3D extents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetUpdateExtent(vtk.vtkInformation,System.Int32[])">
            <summary>
                <para>Get/Set the update extent for output ports that use 3D extents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetUpdateExtentToWholeExtent(vtk.vtkInformation)">
            <summary>
                <para>If the whole input extent is required to generate the requested output extent, this method can be called to set the input update extent to the whole input extent. This method assumes that the whole extent is known (that UpdateInformation has been called)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetWholeExtent(vtk.vtkInformation,System.Int32[])">
            <summary>
                <para>Set/Get the whole extent of an output port.  The whole extent is meta data for structured data sets.  It gets set by the algorithm during the update information pass.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetWholeExtent(vtk.vtkInformation,System.Int32[])">
            <summary>
                <para>Set/Get the whole extent of an output port.  The whole extent is meta data for structured data sets.  It gets set by the algorithm during the update information pass.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.GetMaximumNumberOfPieces(vtk.vtkInformation)">
            <summary>
                <para>Set/Get the maximum number of pieces that can be requested from the given port.  The maximum number of pieces is meta data for unstructured data sets.  It gets set by the source during the update information call.  A value of -1 indicates that there is no maximum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.SetMaximumNumberOfPieces(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>Set/Get the maximum number of pieces that can be requested from the given port.  The maximum number of pieces is meta data for unstructured data sets.  It gets set by the source during the update information call.  A value of -1 indicates that there is no maximum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.PropagateUpdateExtent(System.Int32)">
            <summary>
                <para>Propagate the update request from the given output port back through the pipeline.  Should be called only when information is up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.UpdateWholeExtent">
            <summary>
                <para>Bring the outputs up-to-date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.Update(System.Int32)">
            <summary>
                <para>Bring the outputs up-to-date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamingDemandDrivenPipeline.Update">
            <summary>
                <para>Bring the outputs up-to-date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.NewDataObject(System.String)">
            <summary>
                <para>Create (New) and return a data object of the given type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.DATA_NOT_GENERATED">
            <summary>
                <para>Key to store a mark for an output that will not be generated. Algorithms use this to tell the executive that they will not generate certain outputs for a REQUEST_DATA.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.RELEASE_DATA">
            <summary>
                <para>Key to specify in pipeline information the request that data be released after it is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.REQUEST_DATA_NOT_GENERATED">
            <summary>
                <para>Key defining a request to mark outputs that will NOT be generated during a REQUEST_DATA.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.REQUEST_DATA">
            <summary>
                <para>Key defining a request to make sure the output data are up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.REQUEST_INFORMATION">
            <summary>
                <para>Key defining a request to make sure the output information is up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.REQUEST_DATA_OBJECT">
            <summary>
                <para>Key defining a request to make sure the output data objects exist.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.UpdateData(System.Int32)">
            <summary>
                <para>Bring the output data up to date.  This should be called only when information is up to date.  Use the Update method if it is not known that the information is up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.UpdateInformation">
            <summary>
                <para>Bring the output information up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.UpdateDataObject">
            <summary>
                <para>Bring the output data object's existence up to date.  This does not actually produce data, but does create the data object that will store data produced during the UpdateData step.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.UpdatePipelineMTime">
            <summary>
                <para>Bring the PipelineMTime up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.GetReleaseDataFlag(System.Int32)">
            <summary>
                <para>Get whether the given output port releases data when it is consumed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.SetReleaseDataFlag(System.Int32,System.Int32)">
            <summary>
                <para>Set whether the given output port releases data when it is consumed.  Returns 1 if the the value changes and 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.GetPipelineMTime">
            <summary>
                <para>Get the PipelineMTime for this exective.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.Update(System.Int32)">
            <summary>
                <para>Bring the algorithm's outputs up-to-date.  Returns 1 for success and 0 for failure.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDemandDrivenPipeline.Update">
            <summary>
                <para>Bring the algorithm's outputs up-to-date.  Returns 1 for success and 0 for failure.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPropAssembly.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.GetNumberOfPaths">
            <summary>
                <para>Methods to traverse the paths (i.e., leaf nodes) of a prop assembly. These methods should be contrasted to those that traverse the list of parts using GetParts().  GetParts() returns a list of children of this assembly, not necessarily the leaf nodes of the assembly. To use the methods below - first invoke InitPathTraversal() followed by repeated calls to GetNextPath().  GetNextPath() returns a NULL pointer when the list is exhausted. (See the superclass vtkProp for more information about paths.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.GetNextPath">
            <summary>
                <para>Methods to traverse the paths (i.e., leaf nodes) of a prop assembly. These methods should be contrasted to those that traverse the list of parts using GetParts().  GetParts() returns a list of children of this assembly, not necessarily the leaf nodes of the assembly. To use the methods below - first invoke InitPathTraversal() followed by repeated calls to GetNextPath().  GetNextPath() returns a NULL pointer when the list is exhausted. (See the superclass vtkProp for more information about paths.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.InitPathTraversal">
            <summary>
                <para>Methods to traverse the paths (i.e., leaf nodes) of a prop assembly. These methods should be contrasted to those that traverse the list of parts using GetParts().  GetParts() returns a list of children of this assembly, not necessarily the leaf nodes of the assembly. To use the methods below - first invoke InitPathTraversal() followed by repeated calls to GetNextPath().  GetNextPath() returns a NULL pointer when the list is exhausted. (See the superclass vtkProp for more information about paths.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.GetMTime">
            <summary>
                <para>Override default GetMTime method to also consider all of the prop assembly's parts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this vtkPropAssembly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.GetBounds">
            <summary>
                <para>Get the bounds for this prop assembly as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax). May return NULL in some cases (meaning the bounds is undefined).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Render this assembly and all its parts.  The rendering process is recursive. The parts of each assembly are rendered only if the visibility for the prop is turned on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Render this assembly and all its parts.  The rendering process is recursive. The parts of each assembly are rendered only if the visibility for the prop is turned on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Render this assembly and all its parts.  The rendering process is recursive. The parts of each assembly are rendered only if the visibility for the prop is turned on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.GetParts">
            <summary>
                <para>Return the list of parts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.RemovePart(vtk.vtkProp)">
            <summary>
                <para>Remove a part from the list of parts,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropAssembly.AddPart(vtk.vtkProp)">
            <summary>
                <para>Add a part to the list of parts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkViewport.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkViewport.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkViewport.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkViewport.RemoveAllProps">
            <summary>
                <para>@deprecated Replaced by vtkViewport::RemoveAllViewProps() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.HasProp(vtk.vtkProp)">
            <summary>
                <para>@deprecated Replaced by vtkViewport::HasViewProp() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetProps">
            <summary>
                <para>@deprecated Replaced by vtkViewport::GetViewProps() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.AddProp(vtk.vtkProp)">
            <summary>
                <para>@deprecated Replaced by vtkViewport::AddViewProp() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.RemoveProp(vtk.vtkProp)">
            <summary>
                <para>@deprecated Replaced by vtkViewport::RemoveViewProp() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetPickedZ">
            <summary>
                <para>Return the Z value for the last picked Prop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetIsPicking">
            <summary>
                <para>Methods used to return the pick (x,y) in local display coordinates (i.e., it's that same as selectionX and selectionY).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetPickY">
            <summary>
                <para>Methods used to return the pick (x,y) in local display coordinates (i.e., it's that same as selectionX and selectionY).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetPickX">
            <summary>
                <para>Methods used to return the pick (x,y) in local display coordinates (i.e., it's that same as selectionX and selectionY).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.PickPropFrom(System.Double,System.Double,vtk.vtkPropCollection)">
            <summary>
                <para>Same as PickProp with two arguments, but selects from the given collection of Props instead of the Renderers props.  Make sure the Props in the collection are in this renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.PickProp(System.Double,System.Double)">
            <summary>
                <para>Return the Prop that has the highest z value at the given x, y position in the viewport.  Basically, the top most prop that renders the pixel at selectionX, selectionY will be returned.  If no Props are there NULL is returned.  This method selects from the Viewports Prop list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetTiledSizeAndOrigin(System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
            <summary>
                <para>Get the size and origin of the viewport in display coordinates. Note: if the window has not yet been realized, GetSize() and GetOrigin()  return (0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetTiledSize(System.Int32[],System.Int32[])">
            <summary>
                <para>Get the size and origin of the viewport in display coordinates. Note: if the window has not yet been realized, GetSize() and GetOrigin()  return (0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetOrigin">
            <summary>
                <para>Get the size and origin of the viewport in display coordinates. Note: if the window has not yet been realized, GetSize() and GetOrigin()  return (0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetSize">
            <summary>
                <para>Get the size and origin of the viewport in display coordinates. Note: if the window has not yet been realized, GetSize() and GetOrigin()  return (0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.WorldToView(System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.ViewToNormalizedViewport(System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.NormalizedViewportToViewport(System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.ViewportToNormalizedDisplay(System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.NormalizedDisplayToDisplay(System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.DisplayToLocalDisplay(System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.ViewToWorld(System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.NormalizedViewportToView(System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.ViewportToNormalizedViewport(System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.NormalizedDisplayToViewport(System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.DisplayToNormalizedDisplay(System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.LocalDisplayToDisplay(System.Double@,System.Double@)">
            <summary>
                <para>These methods map from one coordinate system to another. They are primarily used by the vtkCoordinate object and are often strung together. These methods return valid information only if the window has been realized (e.g., GetSize() returns something other than (0,0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.WorldToDisplay">
            <summary>
                <para>Convert world point coordinates to display (or screen) coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.DisplayToWorld">
            <summary>
                <para>Convert display (or screen) coordinates to world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.ViewToWorld">
            <summary>
                <para>Convert view point coordinates to world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.WorldToView">
            <summary>
                <para>Convert world point coordinates to view coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.ViewToDisplay">
            <summary>
                <para>Convert view coordinates to display coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.DisplayToView">
            <summary>
                <para>Convert display coordinates to view coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetVTKWindow">
            <summary>
                <para>Return the vtkWindow that owns this vtkViewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.IsInViewport(System.Int32,System.Int32)">
            <summary>
                <para>Is a given display point in this Viewport's viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetCenter">
            <summary>
                <para>Return the center of this viewport in display coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetWorldPoint">
            <summary>
                <para>Specify a point location in world coordinates. This method takes  homogeneous coordinates. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetWorldPoint(System.Double[])">
            <summary>
                <para>Specify a point location in world coordinates. This method takes  homogeneous coordinates. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetWorldPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point location in world coordinates. This method takes  homogeneous coordinates. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetViewPoint">
            <summary>
                <para>Specify a point location in view coordinates. The origin is in the  middle of the viewport and it extends from -1 to 1 in all three dimensions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetViewPoint(System.Double[])">
            <summary>
                <para>Specify a point location in view coordinates. The origin is in the  middle of the viewport and it extends from -1 to 1 in all three dimensions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetViewPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point location in view coordinates. The origin is in the  middle of the viewport and it extends from -1 to 1 in all three dimensions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetDisplayPoint">
            <summary>
                <para>Set/get a point location in display (or screen) coordinates. The lower left corner of the window is the origin and y increases as you go up the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetDisplayPoint(System.Double[])">
            <summary>
                <para>Set/get a point location in display (or screen) coordinates. The lower left corner of the window is the origin and y increases as you go up the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetDisplayPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/get a point location in display (or screen) coordinates. The lower left corner of the window is the origin and y increases as you go up the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetViewport">
            <summary>
                <para>Specify the viewport for the Viewport to draw in the rendering window.  Coordinates are expressed as (xmin,ymin,xmax,ymax), where each coordinate is 0 &lt;= coordinate &lt;= 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetViewport(System.Double[])">
            <summary>
                <para>Specify the viewport for the Viewport to draw in the rendering window.  Coordinates are expressed as (xmin,ymin,xmax,ymax), where each coordinate is 0 &lt;= coordinate &lt;= 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetViewport(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the viewport for the Viewport to draw in the rendering window.  Coordinates are expressed as (xmin,ymin,xmax,ymax), where each coordinate is 0 &lt;= coordinate &lt;= 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetPixelAspect">
            <summary>
                <para>Set the aspect ratio of a pixel in the rendered image.  This factor permits the image to rendered anisotropically (i.e., stretched in one direction or the other).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetPixelAspect(System.Double[])">
            <summary>
                <para>Set the aspect ratio of a pixel in the rendered image.  This factor permits the image to rendered anisotropically (i.e., stretched in one direction or the other).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetPixelAspect(System.Double,System.Double)">
            <summary>
                <para>Set the aspect ratio of a pixel in the rendered image.  This factor permits the image to rendered anisotropically (i.e., stretched in one direction or the other).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.ComputeAspect">
            <summary>
                <para>Set the aspect ratio of the rendered image. This is computed  automatically and should not be set by the user.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetAspect">
            <summary>
                <para>Set the aspect ratio of the rendered image. This is computed  automatically and should not be set by the user.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetAspect(System.Double[])">
            <summary>
                <para>Set the aspect ratio of the rendered image. This is computed  automatically and should not be set by the user.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetAspect(System.Double,System.Double)">
            <summary>
                <para>Set the aspect ratio of the rendered image. This is computed  automatically and should not be set by the user.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetBackground">
            <summary>
                <para>Set/Get the background color of the rendering screen using an rgb color specification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetBackground(System.Double[])">
            <summary>
                <para>Set/Get the background color of the rendering screen using an rgb color specification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.SetBackground(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the background color of the rendering screen using an rgb color specification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetActors2D">
            <summary>
                <para>Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.RemoveActor2D(vtk.vtkProp)">
            <summary>
                <para>Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.AddActor2D(vtk.vtkProp)">
            <summary>
                <para>Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.RemoveAllViewProps">
            <summary>
                <para>Remove all actors from the list of actors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.RemoveViewProp(vtk.vtkProp)">
            <summary>
                <para>Remove an actor from the list of actors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.HasViewProp(vtk.vtkProp)">
            <summary>
                <para>Query if a prop is in the list of props.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.GetViewProps">
            <summary>
                <para>Return any props in this viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkViewport.AddViewProp(vtk.vtkProp)">
            <summary>
                <para>Add a prop to the list of props. Prop is the superclass of all  actors, volumes, 2D actors, composite props etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkActor2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkActor2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkActor2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetActualPositionCoordinate">
            <summary>
                <para>Return the actual vtkCoordinate reference that the mapper should use to position the actor. This is used internally by the mappers and should be overridden in specialized subclasses and otherwise ignored.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this vtkActor2D. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetActors2D(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetMTime">
            <summary>
                <para>Return this objects MTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetHeight">
            <summary>
                <para>Set/Get the height and width of the Actor2D. The value is expressed as a fraction of the viewport. This really is just another way of setting the Position2 instance variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetHeight(System.Double)">
            <summary>
                <para>Set/Get the height and width of the Actor2D. The value is expressed as a fraction of the viewport. This really is just another way of setting the Position2 instance variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetWidth">
            <summary>
                <para>Set/Get the height and width of the Actor2D. The value is expressed as a fraction of the viewport. This really is just another way of setting the Position2 instance variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetWidth(System.Double)">
            <summary>
                <para>Set/Get the height and width of the Actor2D. The value is expressed as a fraction of the viewport. This really is just another way of setting the Position2 instance variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetPosition2">
            <summary>
                <para>Access the Position2 instance variable. This variable controls the upper right corner of the Actor2D. It is by default relative to Position and in normalized viewport coordinates. Some 2D actor subclasses ignore the position2 variable</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetPosition2(System.Double[])">
            <summary>
                <para>Access the Position2 instance variable. This variable controls the upper right corner of the Actor2D. It is by default relative to Position and in normalized viewport coordinates. Some 2D actor subclasses ignore the position2 variable</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetPosition2(System.Double,System.Double)">
            <summary>
                <para>Access the Position2 instance variable. This variable controls the upper right corner of the Actor2D. It is by default relative to Position and in normalized viewport coordinates. Some 2D actor subclasses ignore the position2 variable</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetPosition2Coordinate">
            <summary>
                <para>Access the Position2 instance variable. This variable controls the upper right corner of the Actor2D. It is by default relative to Position and in normalized viewport coordinates. Some 2D actor subclasses ignore the position2 variable</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetDisplayPosition(System.Int32,System.Int32)">
            <summary>
                <para>Set the Prop2D's position in display coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetPosition">
            <summary>
                <para>Get the PositionCoordinate instance of vtkCoordinate. This is used for for complicated or relative positioning. The position variable controls the lower left corner of the Actor2D</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetPosition(System.Double[])">
            <summary>
                <para>Get the PositionCoordinate instance of vtkCoordinate. This is used for for complicated or relative positioning. The position variable controls the lower left corner of the Actor2D</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetPosition(System.Double,System.Double)">
            <summary>
                <para>Get the PositionCoordinate instance of vtkCoordinate. This is used for for complicated or relative positioning. The position variable controls the lower left corner of the Actor2D</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetPositionCoordinate">
            <summary>
                <para>Get the PositionCoordinate instance of vtkCoordinate. This is used for for complicated or relative positioning. The position variable controls the lower left corner of the Actor2D</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetProperty(vtk.vtkProperty2D)">
            <summary>
                <para>Set this vtkProp's vtkProperty2D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetProperty">
            <summary>
                <para>Returns this actor's vtkProperty2D.  Creates a property if one doesn't already exist.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetLayerNumber">
            <summary>
                <para>Set/Get the layer number in the overlay planes into which to render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetLayerNumber(System.Int32)">
            <summary>
                <para>Set/Get the layer number in the overlay planes into which to render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.GetMapper">
            <summary>
                <para>Set/Get the vtkMapper2D which defines the data to be drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.SetMapper(vtk.vtkMapper2D)">
            <summary>
                <para>Set/Get the vtkMapper2D which defines the data to be drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2D.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkActor2DCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Sort and then render the collection of 2D actors.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.GetLastItem">
            <summary>
                <para>Access routines that are provided for compatibility with previous version of VTK.  Please use the GetNextActor2D(), GetLastActor2D() variants where possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.GetNextItem">
            <summary>
                <para>Access routines that are provided for compatibility with previous version of VTK.  Please use the GetNextActor2D(), GetLastActor2D() variants where possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.GetLastActor2D">
            <summary>
                <para>Standard Collection methods</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.GetNextActor2D">
            <summary>
                <para>Standard Collection methods</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.IsItemPresent(vtk.vtkActor2D)">
            <summary>
                <para>Standard Collection methods</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.AddItem(vtk.vtkActor2D)">
            <summary>
                <para>Add an actor to the list.  The new actor is inserted in the list according to it's layer number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor2DCollection.Sort">
            <summary>
                <para>Sorts the vtkActor2DCollection by layer number.  Smaller layer numbers are first.  Layer numbers can be any integer value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationVector.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationVector.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationVector.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationVector.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationVector.Copy(vtk.vtkInformationVector,System.Int32)">
            <summary>
                <para>Copy all information entries from the given vtkInformation instance.  Any previously existing entries are removed.  If  deep==1, a deep copy of the information structure is performed (new  instances of any contained vtkInformation and vtkInformationVector  objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Initiate garbage collection when a reference is removed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Initiate garbage collection when a reference is removed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.Remove(vtk.vtkInformation)">
            <summary>
                <para>Append/Remove an information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.Append(vtk.vtkInformation)">
            <summary>
                <para>Append/Remove an information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.GetInformationObject(System.Int32)">
            <summary>
                <para>Get/Set the vtkInformation instance stored at the given index in the vector.  The vector will automatically expand to include the index given if necessary.  Missing entries in-between will be filled with empty vtkInformation instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.SetInformationObject(System.Int32,vtk.vtkInformation)">
            <summary>
                <para>Get/Set the vtkInformation instance stored at the given index in the vector.  The vector will automatically expand to include the index given if necessary.  Missing entries in-between will be filled with empty vtkInformation instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.SetNumberOfInformationObjects(System.Int32)">
            <summary>
                <para>Get/Set the number of information objects in the vector.  Setting the number to larger than the current number will create empty vtkInformation instances.  Setting the number to smaller than the current number will remove entries from higher indices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationVector.GetNumberOfInformationObjects">
            <summary>
                <para>Get/Set the number of information objects in the vector.  Setting the number to larger than the current number will create empty vtkInformation instances.  Setting the number to smaller than the current number will remove entries from higher indices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTetra.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTetra.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTetra.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTetra.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTetra.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTetra.InterpolationDerivs(System.Double[])">
            <summary>
                <para>Tetra specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Tetra specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.ComputeVolume(System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the volume of a tetrahedron defined by the four points p1, p2, p3, and p4.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.BarycentricCoords(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Given a 3D point x[3], determine the barycentric coordinates of the point. Barycentric coordinates are a natural coordinate system for simplices that express a position as a linear combination of the vertices. For a  tetrahedron, there are four barycentric coordinates (because there are four vertices), and the sum of the coordinates must equal 1. If a  point x is inside a simplex, then all four coordinates will be strictly  positive.  If three coordinates are zero (so the fourth =1), then the  point x is on a vertex. If two coordinates are zero, the point x is on an  edge (and so on). In this method, you must specify the vertex coordinates x1-&gt;x4. Returns 0 if tetrahedron is degenerate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.Insphere(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the center (center[3]) and radius (method return value) of a sphere that just fits inside the faces of a tetrahedron defined by the four points x1, x2, x3, and x4.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.Circumsphere(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the circumcenter (center[3]) and radius squared (method return value) of a tetrahedron defined by the four points x1, x2, x3, and x4.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.TetraCenter(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the center of the tetrahedron,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.GetParametricDistance(System.Double[])">
            <summary>
                <para>Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the tetrahedron in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>Returns the set of points that are on the boundary of the tetrahedron that are closest parametrically to the point specified. This may include faces, edges, or vertices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTetra.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageData.GetExtentType">
            <summary>
                <para>The extent type is a 3D extent</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.ComputeInternalExtent(System.Int32[],System.Int32[],System.Int32[])">
            <summary>
                <para>Given how many pixel are required on a side for bounrary conditions (in bnds), the target extent to traverse, compute the internal extent (the extent for this ImageData that does nto suffer from any boundary conditions) and place it in intExt</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetArrayIncrements(vtk.vtkDataArray,System.Int32[])">
            <summary>
                <para>Since various arrays have different number of components, the will have different increments.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetArrayPointer(vtk.vtkDataArray,System.Int32[])">
            <summary>
                <para>These are convenience methods for getting a pointer from any filed array.  It is a start at expanding image filters to process any array (not just scalars).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetArrayPointerForExtent(vtk.vtkDataArray,System.Int32[])">
            <summary>
                <para>These are convenience methods for getting a pointer from any filed array.  It is a start at expanding image filters to process any array (not just scalars).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.PrepareForNewData">
            <summary>
                <para>make the output data ready for new data to be inserted. For most  objects we just call Initialize. But for image data we leave the old data in case the memory can be reused.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.CopyInformationFromPipeline(vtk.vtkInformation)">
            <summary>
                <para>Override these to handle origin, spacing, scalar type, and scalar number of components.  See vtkDataObject for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.CopyInformationToPipeline(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Override these to handle origin, spacing, scalar type, and scalar number of components.  See vtkDataObject for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetNumberOfScalarComponents">
            <summary>
                <para>Set/Get the number of scalar components for points. As with the SetScalarType method this is setting pipeline info.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetNumberOfScalarComponents(System.Int32)">
            <summary>
                <para>Set/Get the number of scalar components for points. As with the SetScalarType method this is setting pipeline info.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarTypeAsString">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarType">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarType(System.Int32)">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToChar">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToUnsignedChar">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToUnsignedShort">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToShort">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToUnsignedLong">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToLong">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToUnsignedInt">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToInt">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToDouble">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarTypeToFloat">
            <summary>
                <para>Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetOrigin">
            <summary>
                <para>Set the origin of the data. The origin plus spacing determine the position in space of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetOrigin(System.Double[])">
            <summary>
                <para>Set the origin of the data. The origin plus spacing determine the position in space of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the origin of the data. The origin plus spacing determine the position in space of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetSpacing">
            <summary>
                <para>Set the spacing (width,height,length) of the cubical cells that compose the data set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetSpacing(System.Double[])">
            <summary>
                <para>Set the spacing (width,height,length) of the cubical cells that compose the data set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetSpacing(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the spacing (width,height,length) of the cubical cells that compose the data set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetActualMemorySize">
            <summary>
                <para>Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.Crop">
            <summary>
                <para>Reallocates and copies to set the Extent to the UpdateExtent. This is used internally when the exact extent is requested,  and the source generated more than the update extent. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.CopyAndCastFrom(vtk.vtkImageData,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Reallocates and copies to set the Extent to the UpdateExtent. This is used internally when the exact extent is requested,  and the source generated more than the update extent. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.CopyAndCastFrom(vtk.vtkImageData,System.Int32[])">
            <summary>
                <para>This method is passed a input and output region, and executes the filter algorithm to fill the output from the input. It just executes a switch statement to call the correct function for the regions data types.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.AllocateScalars">
            <summary>
                <para>Allocate the vtkScalars object associated with this object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarComponentFromDouble(System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
                <para>For access to data from tcl</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarComponentAsDouble(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>For access to data from tcl</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetScalarComponentFromFloat(System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
                <para>For access to data from tcl</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarComponentAsFloat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>For access to data from tcl</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarPointer">
            <summary>
                <para>Access the native pointer for the scalar data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarPointer(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Access the native pointer for the scalar data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarPointer(System.Int32[])">
            <summary>
                <para>Access the native pointer for the scalar data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarPointerForExtent(System.Int32[])">
            <summary>
                <para>Access the native pointer for the scalar data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetContinuousIncrements(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                <para>Different ways to get the increments for moving around the data. incX is always returned with 0.  incY is returned with the increment needed to move from the end of one X scanline of data to the start of the next line.  incZ is filled in with the increment needed to move from the end of one image to the start of the next.  The proper way to use these values is to for a loop over Z, Y, X, C, incrementing the pointer by 1 after each component.  When the end of the component is reached, the pointer is set to the beginning of the next pixel, thus incX is properly set to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetIncrements(System.Int32[])">
            <summary>
                <para>Different ways to get the increments for moving around the data. GetIncrements() calls ComputeIncrements() to ensure the increments are up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetIncrements(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                <para>Different ways to get the increments for moving around the data. GetIncrements() calls ComputeIncrements() to ensure the increments are up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetIncrements">
            <summary>
                <para>Different ways to get the increments for moving around the data. GetIncrements() calls ComputeIncrements() to ensure the increments are up to date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarSize">
            <summary>
                <para>Set the size of the scalar type in bytes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarTypeMax">
            <summary>
                <para>These returns the minimum and maximum values the ScalarType can hold without overflowing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetScalarTypeMin">
            <summary>
                <para>These returns the minimum and maximum values the ScalarType can hold without overflowing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetEstimatedMemorySize">
            <summary>
                <para>Get the estimated size of this data object itself. Should be called after UpdateInformation() and PropagateUpdateExtent() have both been  called. This estimate should be fairly accurate since this is structured data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetExtent">
            <summary>
                <para>Set/Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point.  The extent should be set before the "Scalars" are set or allocated.  The Extent is stored in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point.  The extent should be set before the "Scalars" are set or allocated.  The Extent is stored in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetExtent(System.Int32[])">
            <summary>
                <para>Set/Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point.  The extent should be set before the "Scalars" are set or allocated.  The Extent is stored in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.UpdateInformation">
            <summary>
                <para>Override to copy information from pipeline information to data information for backward compatibility.  See vtkDataObject::UpdateInformation for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetAxisUpdateExtent(System.Int32,System.Int32@,System.Int32@)">
            <summary>
                <para>Set / Get the extent on just one axis</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetAxisUpdateExtent(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set / Get the extent on just one axis</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.ComputeCellId(System.Int32[])">
            <summary>
                <para>Given a location in structured coordinates (i-j-k), return the cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.ComputePointId(System.Int32[])">
            <summary>
                <para>Given a location in structured coordinates (i-j-k), return the point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetDataDimension">
            <summary>
                <para>Return the dimensionality of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetPointGradient(System.Int32,System.Int32,System.Int32,vtk.vtkDataArray,System.Double[])">
            <summary>
                <para>Given structured coordinates (i,j,k) for a point in a structured point  dataset, compute the gradient vector from the scalar data at that point.  The scalars s are the scalars from which the gradient is to be computed. This method will treat structured point datasets of any dimension.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetVoxelGradient(System.Int32,System.Int32,System.Int32,vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Given structured coordinates (i,j,k) for a voxel cell, compute the eight  gradient values for the voxel corners. The order in which the gradient vectors are arranged corresponds to the ordering of the voxel points.  Gradient vector is computed by central differences (except on edges of  volume where forward difference is used). The scalars s are the scalars from which the gradient is to be computed. This method will treat  only 3D structured point datasets (i.e., volumes).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.ComputeStructuredCoordinates(System.Double[],System.Int32[],System.Double[])">
            <summary>
                <para>Convenience function computes the structured coordinates for a point x[3]. The voxel is specified by the array ijk[3], and the parametric coordinates in the cell are specified with pcoords[3]. The function returns a 0 if the point x is outside of the volume, and a 1 if inside the volume.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetDimensions(System.Int32[])">
            <summary>
                <para>Get dimensions of this structured points dataset. It is the number of points on each axis. Dimensions are computed from Extents during this call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetDimensions">
            <summary>
                <para>Get dimensions of this structured points dataset. It is the number of points on each axis. Dimensions are computed from Extents during this call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetDimensions(System.Int32[])">
            <summary>
                <para>Set dimensions of structured points dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.SetDimensions(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set dimensions of structured points dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.Initialize">
            <summary>
                <para>Restore data object to initial state,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetMaxCellSize">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.ComputeBounds">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetPointCells(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetCellPoints(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetCellType(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.FindAndGetCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.FindCell(System.Double[],vtk.vtkCell,vtk.vtkGenericCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.FindCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.FindPoint(System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.FindPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetCellBounds(System.Int32,System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetCell(System.Int32,vtk.vtkGenericCell)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetCell(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetPoint(System.Int32,System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetPoint(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetNumberOfPoints">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetNumberOfCells">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.GetDataObjectType">
            <summary>
                <para>Return what type of dataset this is.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageData.CopyStructure(vtk.vtkDataSet)">
            <summary>
                <para>Copy the geometric and topological structure of an input image data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredPointsToPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToPolyDataFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsToPolyDataFilter.SetInput(vtk.vtkImageData)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExecutive.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExecutive.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExecutive.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExecutive.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExecutive.KEYS_TO_COPY">
            <summary>
                <para>Keys to program vtkExecutive::ProcessRequest with the default behavior for unknown requests.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.FORWARD_DIRECTION">
            <summary>
                <para>Keys to program vtkExecutive::ProcessRequest with the default behavior for unknown requests.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.ALGORITHM_DIRECTION">
            <summary>
                <para>Keys to program vtkExecutive::ProcessRequest with the default behavior for unknown requests.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.ALGORITHM_AFTER_FORWARD">
            <summary>
                <para>Keys to program vtkExecutive::ProcessRequest with the default behavior for unknown requests.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.ALGORITHM_BEFORE_FORWARD">
            <summary>
                <para>Keys to program vtkExecutive::ProcessRequest with the default behavior for unknown requests.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.FROM_OUTPUT_PORT">
            <summary>
                <para>Information key to store the output port number from which a request is made.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.CONSUMERS">
            <summary>
                <para>Information key to store the executive/port number pairs consuming an information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.PRODUCER">
            <summary>
                <para>Information key to store the executive/port number producing an information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Participate in garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Participate in garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.SetSharedOutputInformation(vtk.vtkInformationVector)">
            <summary>
                <para>Set a pointer to an outside instance of input or output information vectors.  No references are held to the given vectors, and setting this does not change the executive object modification time.  This is a preliminary interface to use in implementing filters with internal pipelines, and may change without notice when a future interface is created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetProducerPort(vtk.vtkDataObject)">
            <summary>
                <para>Get the output port that produces the given data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetInputData(System.Int32,System.Int32)">
            <summary>
                <para>Get the data object for an output port of the algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.SetOutputData(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Get/Set the data object for an output port of the algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.SetOutputData(System.Int32,vtk.vtkDataObject,vtk.vtkInformation)">
            <summary>
                <para>Get/Set the data object for an output port of the algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetOutputData(System.Int32)">
            <summary>
                <para>Get/Set the data object for an output port of the algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetInputExecutive(System.Int32,System.Int32)">
            <summary>
                <para>Get the executive managing the given input connection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetInputInformation(System.Int32)">
            <summary>
                <para>Get the pipeline information vectors for the given input port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetInputInformation(System.Int32,System.Int32)">
            <summary>
                <para>Get the pipeline information for the given input connection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetOutputInformation">
            <summary>
                <para>Get the pipeline information object for all output ports.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetOutputInformation(System.Int32)">
            <summary>
                <para>Get the pipeline information object for the given output port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetNumberOfInputConnections(System.Int32)">
            <summary>
                <para>Get the number of input connections on the given port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetNumberOfOutputPorts">
            <summary>
                <para>Get the number of input/output ports for the algorithm associated with this executive.  Returns 0 if no algorithm is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetNumberOfInputPorts">
            <summary>
                <para>Get the number of input/output ports for the algorithm associated with this executive.  Returns 0 if no algorithm is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.Update(System.Int32)">
            <summary>
                <para>Bring the algorithm's outputs up-to-date.  Returns 1 for success and 0 for failure.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.Update">
            <summary>
                <para>Bring the algorithm's outputs up-to-date.  Returns 1 for success and 0 for failure.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExecutive.GetAlgorithm">
            <summary>
                <para>Get the algorithm to which this executive has been assigned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.Report(vtk.vtkInformation,vtk.vtkGarbageCollector)">
            <summary>
                <para>Report a reference this key has in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.GetPort(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.GetExecutive(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationExecutivePortKey.Set(vtk.vtkInformation,vtk.vtkExecutive,System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTriangle.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTriangle.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTriangle.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTriangle.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTriangle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTriangle.ComputeQuadric(System.Double[],System.Double[],System.Double[],vtk.vtkQuadric)">
            <summary>
                <para>Calculate the error quadric for this triangle.  Return the quadric as a 4x4 matrix or a vtkQuadric.  (from Peter Lindstrom's Siggraph 2000 paper, "Out-of-Core Simplification of Large Polygonal Models")</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.ComputeQuadric(System.Double[],System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>Calculate the error quadric for this triangle.  Return the quadric as a 4x4 matrix or a vtkQuadric.  (from Peter Lindstrom's Siggraph 2000 paper, "Out-of-Core Simplification of Large Polygonal Models")</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.PointInTriangle(System.Double[],System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Given a point x, determine whether it is inside (within the tolerance squared, tol2) the triangle defined by the three  coordinate values p1, p2, p3. Method is via comparing dot products. (Note: in current implementation the tolerance only works in the neighborhood of the three vertices of the triangle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.ComputeNormalDirection(System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the (unnormalized) triangle normal direction from three points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.ComputeNormal(System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the triangle normal from three points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.ComputeNormal(vtk.vtkPoints,System.Int32,System.Int32[],System.Double[])">
            <summary>
                <para>Compute the triangle normal from a points list, and a list of point ids that index into the points list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.ProjectTo2D(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Project triangle defined in 3D to 2D coordinates. Returns 0 if degenerate triangle; non-zero value otherwise. Input points are x1-&gt;x3; output 2D points are v1-&gt;v3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.BarycentricCoords(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Given a 2D point x[2], determine the barycentric coordinates of the point. Barycentric coordinates are a natural coordinate system for simplices that express a position as a linear combination of the vertices. For a  triangle, there are three barycentric coordinates (because there are three vertices), and the sum of the coordinates must equal 1. If a  point x is inside a simplex, then all three coordinates will be strictly  positive.  If two coordinates are zero (so the third =1), then the  point x is on a vertex. If one coordinates are zero, the point x is on an  edge. In this method, you must specify the vertex coordinates x1-&gt;x3.  Returns 0 if triangle is degenerate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.Circumcircle(System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the circumcenter (center[3]) and radius squared (method return value) of a triangle defined by the three points x1, x2, and x3. (Note that the coordinates are 2D. 3D points can be used but the z-component will be ignored.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.TriangleArea(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the area of a triangle in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.TriangleCenter(System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute the center of the triangle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.GetParametricDistance(System.Double[])">
            <summary>
                <para>Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the triangle in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Plane intersection plus in/out test on triangle. The in/out test is  performed using tol as the tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>vtkTriangle specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>vtkTriangle specific methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this triangle using scalar value provided. Like contouring, except that it cuts the triangle to produce other triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangle.GetEdge(System.Int32)">
            <summary>
                <para>Get the edge specified by edgeId (range 0 to 2) and return that edge's coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.SetOutput(vtk.vtkDataObject)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGridAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetCollection.GetDataSet(System.Int32)">
            <summary>
                <para>Get the ith dataset in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetCollection.GetItem(System.Int32)">
            <summary>
                <para>Get the ith dataset in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetCollection.GetNextDataSet">
            <summary>
                <para>Get the next dataset in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetCollection.GetNextItem">
            <summary>
                <para>Get the next dataset in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetCollection.AddItem(vtk.vtkDataSet)">
            <summary>
                <para>Add a dataset to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellLocator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellLocator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellLocator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellLocator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellLocator.GenerateRepresentation(System.Int32,vtk.vtkPolyData)">
            <summary>
                <para>Satisfy vtkLocator abstract interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.BuildLocator">
            <summary>
                <para>Satisfy vtkLocator abstract interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.FreeSearchStructure">
            <summary>
                <para>Satisfy vtkLocator abstract interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.GetNumberOfBuckets">
            <summary>
                <para>Return number of buckets available. Insure that the locator has been  built before attempting to access buckets (octants).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.GetCells(System.Int32)">
            <summary>
                <para>Get the cells in a particular bucket.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.FindClosestPointWithinRadius(System.Double[],System.Double,System.Double[],vtk.vtkGenericCell,System.Int32@,System.Int32@,System.Double@,System.Int32@)">
            <summary>
                <para>Return the closest point within a specified radius and the cell which is closest to the point x. The closest point is somewhere on a cell, it need not be one of the vertices of the cell. This method returns 1 if a point is found within the specified radius. If there are no cells within the specified radius, the method returns 0 and the values of closestPoint, cellId, subId, and dist2 are undefined. This version takes in a vtkGenericCell to avoid allocating and deallocating the cell.  This is much faster than the version which does not take a *cell, especially when this function is called many times in a row such as by a for loop, where the allocation and dealloction can be done only once outside the for loop.  If a closest point is found, "cell" contains the points and ptIds for the cell "cellId" upon exit.  If a closest point is found, inside returns the return value of the EvaluatePosition call to the closest cell; inside(=1) or outside(=0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.FindClosestPointWithinRadius(System.Double[],System.Double,System.Double[],vtk.vtkGenericCell,System.Int32@,System.Int32@,System.Double@)">
            <summary>
                <para>Return the closest point within a specified radius and the cell which is closest to the point x. The closest point is somewhere on a cell, it need not be one of the vertices of the cell. This method returns 1 if a point is found within the specified radius. If there are no cells within the specified radius, the method returns 0 and the values of closestPoint, cellId, subId, and dist2 are undefined. This version takes in a vtkGenericCell to avoid allocating and deallocating the cell.  This is much faster than the version which does not take a *cell, especially when this function is called many times in a row such as by a for loop, where the allocation and deallocation can be done only once outside the for loop.  If a closest point is found, "cell" contains the points and ptIds for the cell "cellId" upon exit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.FindClosestPointWithinRadius(System.Double[],System.Double,System.Double[],System.Int32@,System.Int32@,System.Double@)">
            <summary>
                <para>Return the closest point within a specified radius and the cell which is closest to the point x. The closest point is somewhere on a cell, it need not be one of the vertices of the cell. This method returns 1 if a point is found within the specified radius. If there are no cells within the specified radius, the method returns 0 and the values of closestPoint, cellId, subId, and dist2 are undefined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.FindClosestPoint(System.Double[],System.Double[],vtk.vtkGenericCell,System.Int32@,System.Int32@,System.Double@)">
            <summary>
                <para>Return the closest point and the cell which is closest to the point x. The closest point is somewhere on a cell, it need not be one of the vertices of the cell.  This version takes in a vtkGenericCell to avoid allocating and deallocating the cell.  This is much faster than the version which does not take a *cell, especially when this function is called many times in a row such as by a for loop, where the allocation and deallocation can be done only once outside the for loop.  If a cell is found, "cell" contains the points and ptIds for the cell "cellId" upon exit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.FindClosestPoint(System.Double[],System.Double[],System.Int32@,System.Int32@,System.Double@)">
            <summary>
                <para>Return the closest point and the cell which is closest to the point x. The closest point is somewhere on a cell, it need not be one of the vertices of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@,System.Int32@,vtk.vtkGenericCell)">
            <summary>
                <para>Return intersection point (if any) AND the cell which was intersected by the finite line. The cell is returned as a cell id and as a generic cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@,System.Int32@)">
            <summary>
                <para>Return intersection point (if any) AND the cell which was intersected by the finite line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Return intersection point (if any) of finite line with cells contained in cell locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.CacheCellBoundsOff">
            <summary>
                <para>Boolean controls whether the bounds of each cell are computed only once and then saved.  Should be 10 to 20% faster if repeatedly  calling any of the FindClosestPoint routines and the extra memory won't cause disk caching (24 extra bytes per cell are required to save the bounds).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.CacheCellBoundsOn">
            <summary>
                <para>Boolean controls whether the bounds of each cell are computed only once and then saved.  Should be 10 to 20% faster if repeatedly  calling any of the FindClosestPoint routines and the extra memory won't cause disk caching (24 extra bytes per cell are required to save the bounds).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.GetCacheCellBounds">
            <summary>
                <para>Boolean controls whether the bounds of each cell are computed only once and then saved.  Should be 10 to 20% faster if repeatedly  calling any of the FindClosestPoint routines and the extra memory won't cause disk caching (24 extra bytes per cell are required to save the bounds).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.SetCacheCellBounds(System.Int32)">
            <summary>
                <para>Boolean controls whether the bounds of each cell are computed only once and then saved.  Should be 10 to 20% faster if repeatedly  calling any of the FindClosestPoint routines and the extra memory won't cause disk caching (24 extra bytes per cell are required to save the bounds).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.GetNumberOfCellsPerBucket">
            <summary>
                <para>Specify the average number of cells in each octant.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.GetNumberOfCellsPerBucketMaxValue">
            <summary>
                <para>Specify the average number of cells in each octant.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.GetNumberOfCellsPerBucketMinValue">
            <summary>
                <para>Specify the average number of cells in each octant.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellLocator.SetNumberOfCellsPerBucket(System.Int32)">
            <summary>
                <para>Specify the average number of cells in each octant.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyVertex.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the point cloud in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.IsPrimaryCell">
            <summary>
                <para>Return the center of the point cloud in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyVertex.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.ComputeInputUpdateExtents(vtk.vtkDataObject)">
            <summary>
                <para>Do not let images return more than requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToPolyDataFilter.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataSource.SetOutput(vtk.vtkPolyData)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataSource.GetOutput(System.Int32)">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataSource.GetOutput">
            <summary>
                <para>Get the output of this source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSource.SetExecutive(vtk.vtkExecutive)">
            <summary>
                <para>Set this algorithm's executive.  This algorithm is removed from any executive to which it has previously been assigned and then assigned to the given executive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.GetOutputIndex(vtk.vtkDataObject)">
            <summary>
                <para>Return what index output the passed in output is, return -1 if it does not match any of the outputs</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.UnRegisterAllOutputs">
            <summary>
                <para>Release/disconnect all outputs of this source. This is intended to be called prior to Delete() if the user is concerned about outputs holding on to the filter/source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.GetNumberOfOutputs">
            <summary>
                <para>Return an array with all the inputs of this process object. This is useful for tracing back in the pipeline to construct graphs etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.ReleaseDataFlagOff">
            <summary>
                <para>Turn on/off flag to control whether this object's data is released after being used by a source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.ReleaseDataFlagOn">
            <summary>
                <para>Turn on/off flag to control whether this object's data is released after being used by a source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.GetReleaseDataFlag">
            <summary>
                <para>Turn on/off flag to control whether this object's data is released after being used by a source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.SetReleaseDataFlag(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether this object's data is released after being used by a source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.ComputeInputUpdateExtents(vtk.vtkDataObject)">
            <summary>
                <para>What is the input update extent that is required to produce the desired output? By default, the whole input is always required but this is overridden in many subclasses. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.UpdateData(vtk.vtkDataObject)">
            <summary />
        </member>
        <member name="M:vtk.vtkSource.TriggerAsynchronousUpdate">
            <summary />
        </member>
        <member name="M:vtk.vtkSource.PropagateUpdateExtent(vtk.vtkDataObject)">
            <summary />
        </member>
        <member name="M:vtk.vtkSource.UpdateInformation">
            <summary>
                <para>Updates any global information about the data  (like spacing for images)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.UpdateWholeExtent">
            <summary>
                <para>Like update, but make sure the update extent is the whole extent in the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSource.Update">
            <summary>
                <para>Bring object up-to-date before execution. Update() checks modified time against last execution time, and re-executes object if necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProcessObject.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAlgorithmOutput.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAlgorithmOutput.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAlgorithmOutput.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAlgorithmOutput.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProcessObject.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProcessObject.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProcessObject.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProcessObject.SetNumberOfInputConnections(System.Int32,System.Int32)">
            <summary>
                <para>Reimplemented from vtkAlgorithm to maintain backward compatibility for vtkProcessObject.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.SetNthInputConnection(System.Int32,System.Int32,vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Reimplemented from vtkAlgorithm to maintain backward compatibility for vtkProcessObject.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.RemoveInputConnection(System.Int32,vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Reimplemented from vtkAlgorithm to maintain backward compatibility for vtkProcessObject.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.AddInputConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Reimplemented from vtkAlgorithm to maintain backward compatibility for vtkProcessObject.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.AddInputConnection(System.Int32,vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Reimplemented from vtkAlgorithm to maintain backward compatibility for vtkProcessObject.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.SetInputConnection(System.Int32,vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Reimplemented from vtkAlgorithm to maintain backward compatibility for vtkProcessObject.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.SetInputConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Reimplemented from vtkAlgorithm to maintain backward compatibility for vtkProcessObject.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.RemoveAllInputs">
            <summary>
                <para>Remove all the input data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.SqueezeInputArray">
            <summary>
                <para>This method will rearrange the input array so that all NULL entries  are removed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcessObject.GetNumberOfInputs">
            <summary>
                <para>Return an array with all the inputs of this process object. This is useful for tracing back in the pipeline to construct graphs etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic triangle specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic triangle specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.GetParametricDistance(System.Double[])">
            <summary>
                <para>Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the quadratic triangle in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Line-edge intersection. Intersection has to occur within [0,1] parametric coordinates and with specified tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this quadratic triangle using scalar value provided. Like  contouring, except that it cuts the triangle to produce linear  triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.GetEdge(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.GetNumberOfFaces">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.GetNumberOfEdges">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.GetCellDimension">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTriangle.GetCellType">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic pyramid specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic pyramid specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the quadratic pyramid in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Line-edge intersection. Intersection has to occur within [0,1] parametric coordinates and with specified tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this quadratic triangle using scalar value provided. Like  contouring, except that it cuts the triangle to produce linear  triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.GetFace(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.GetEdge(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.GetNumberOfFaces">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.GetNumberOfEdges">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.GetCellDimension">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticPyramid.GetCellType">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFieldData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.RemoveGhostCells(System.Int32)">
            <summary>
                <para>This method will remove any cell that has a ghost level array value greater or equal to level.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.IsHomogeneous">
            <summary>
                <para>Traverse cells and determine if cells are all of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetIdsOfCellsOfType(System.Int32,vtk.vtkIdTypeArray)">
            <summary>
                <para>Fill vtkIdTypeArray container with list of cell Ids.  This method traverses all cells and, for a particular cell type, inserts the cell Id into the container.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetActualMemorySize">
            <summary>
                <para>Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetGhostLevel">
            <summary>
                <para>Get the ghost level.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetNumberOfPieces">
            <summary>
                <para>Set / Get the piece and the number of pieces. Similar to extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetPiece">
            <summary>
                <para>Set / Get the piece and the number of pieces. Similar to extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetUpdateExtent(System.Int32[])">
            <summary>
                <para>We need this here to avoid hiding superclass method</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetUpdateExtent(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                <para>We need this here to avoid hiding superclass method</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetUpdateExtent(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                <para>For streaming.  User/next filter specifies which piece the want updated. The source of this poly data has to return exactly this piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetCellNeighbors(System.Int32,vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>Topological inquiry to get all cells using list of points exclusive of cell specified (e.g., cellId). THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.ResizeCellList(System.Int32,System.Int32)">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.AddReferenceToCell(System.Int32,System.Int32)">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.RemoveReferenceToCell(System.Int32,System.Int32)">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.InsertNextLinkedCell(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.ReplaceCell(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetCells">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.SetCells(vtk.vtkUnsignedCharArray,vtk.vtkIdTypeArray,vtk.vtkCellArray)">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.SetCells(System.Int32[],vtk.vtkCellArray)">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.SetCells(System.Int32,vtk.vtkCellArray)">
            <summary>
                <para>Special methods specific to vtkUnstructuredGrid for defining the cells composing the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.InsertNextCell(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Insert/create cell in object by type and list of point ids defining cell topology.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.InsertNextCell(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Insert/create cell in object by type and list of point ids defining cell topology.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnstructuredGrid.GetDataObjectType">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.Crop">
            <summary>
                <para>Reallocates and copies to set the Extent to the UpdateExtent. This is used internally when the exact extent is requested,  and the source generated more than the update extent. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetCellBlanking">
            <summary>
                <para>Returns 1 if there is any visibility constraint on the cells, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetPointBlanking">
            <summary>
                <para>Returns 1 if there is any visibility constraint on the points, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.IsCellVisible(System.Int32)">
            <summary>
                <para>Return non-zero value if specified point is visible. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.IsPointVisible(System.Int32)">
            <summary>
                <para>Return non-zero value if specified point is visible. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.SetCellVisibilityArray(vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Set an array that defines the (blanking) visibility of the cells  in the grid. Make sure that length of the visibility array matches  the number of points in the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetCellVisibilityArray">
            <summary>
                <para>Get the array that defines the blanking (visibility) of each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.SetPointVisibilityArray(vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Set an array that defines the (blanking) visibility of the points  in the grid. Make sure that length of the visibility array matches  the number of points in the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetPointVisibilityArray">
            <summary>
                <para>Get the array that defines the blanking (visibility) of each point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.UnBlankCell(System.Int32)">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off cells in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.BlankCell(System.Int32)">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off cells in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.UnBlankPoint(System.Int32)">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.BlankPoint(System.Int32)">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetExtentType">
            <summary>
                <para>Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetActualMemorySize">
            <summary>
                <para>Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetExtent">
            <summary>
                <para>Different ways to set the extent of the data array.  The extent should be set before the "Scalars" are set or allocated. The Extent is stored  in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.SetExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Different ways to set the extent of the data array.  The extent should be set before the "Scalars" are set or allocated. The Extent is stored  in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.SetExtent(System.Int32[])">
            <summary>
                <para>Different ways to set the extent of the data array.  The extent should be set before the "Scalars" are set or allocated. The Extent is stored  in the order (X, Y, Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetDataDimension">
            <summary>
                <para>Return the dimensionality of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetDimensions(System.Int32[])">
            <summary>
                <para>Get dimensions of this structured points dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetDimensions">
            <summary>
                <para>Get dimensions of this structured points dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.SetDimensions(System.Int32[])">
            <summary>
                <para>following methods are specific to structured grid</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.SetDimensions(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>following methods are specific to structured grid</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetScalarRange">
            <summary>
                <para>following methods are specific to structured grid</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetScalarRange(System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetCellNeighbors(System.Int32,vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetMaxCellSize">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.Initialize">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetPointCells(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetCellPoints(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetNumberOfCells">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetCellType(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetCellBounds(System.Int32,System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetCell(System.Int32,vtk.vtkGenericCell)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetCell(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetPoint(System.Int32,System.Double[])">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetPoint(System.Int32)">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetNumberOfPoints">
            <summary>
                <para>Standard vtkDataSet API methods. See vtkDataSet for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.CopyStructure(vtk.vtkDataSet)">
            <summary>
                <para>Copy the geometric and topological structure of an input poly data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGrid.GetDataObjectType">
            <summary>
                <para>Copy the geometric and topological structure of an input poly data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.AddInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.AddInput(System.Int32,vtk.vtkPointSet)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.AddInput(vtk.vtkPointSet)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.AddInput(vtk.vtkDataObject)">
            <summary>
                <para>Add an input of this algorithm.  Note that these methods support old-style pipeline connections.  When writing new code you should use the more general vtkAlgorithm::AddInputConnection().  See SetInput() for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.SetInput(System.Int32,vtk.vtkPointSet)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.SetInput(vtk.vtkPointSet)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.SetInput(System.Int32,vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-style pipeline connections. When writing new code you should use the more general vtkAlgorithm::SetInputConnection().  These methods transform the input index to the input port index, not an index of a connection within a single port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.GetUnstructuredGridOutput">
            <summary>
                <para>Get the output as vtkUnstructuredGrid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.GetStructuredGridOutput">
            <summary>
                <para>Get the output as vtkStructuredGrid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.GetPolyDataOutput">
            <summary>
                <para>Get the output as vtkPolyData.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.GetOutput(System.Int32)">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSetAlgorithm.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAlgorithm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.UpdateExtentIsEmpty(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>This detects when the UpdateExtent will generate no data This condition is satisfied when the UpdateExtent has  zero volume (0,-1,...) or the UpdateNumberOfPieces is 0. The source uses this call to determine whether to call Execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.UpdateExtentIsEmpty(vtk.vtkDataObject)">
            <summary>
                <para>This detects when the UpdateExtent will generate no data This condition is satisfied when the UpdateExtent has  zero volume (0,-1,...) or the UpdateNumberOfPieces is 0. The source uses this call to determine whether to call Execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.ReleaseDataFlagOff">
            <summary>
                <para>Turn release data flag on or off for all output ports.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.ReleaseDataFlagOn">
            <summary>
                <para>Turn release data flag on or off for all output ports.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetReleaseDataFlag">
            <summary>
                <para>Turn release data flag on or off for all output ports.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetReleaseDataFlag(System.Int32)">
            <summary>
                <para>Turn release data flag on or off for all output ports.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.ConvertTotalInputToPortConnection(System.Int32,System.Int32@,System.Int32@)">
            <summary>
                <para>Convenience routine to convert from a linear ordering of input connections to a port/connection pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.UpdateWholeExtent">
            <summary>
                <para>Bring this algorithm's outputs up-to-date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.UpdateInformation">
            <summary>
                <para>Backward compatibility method to invoke UpdateInformation on executive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.Update">
            <summary>
                <para>Bring this algorithm's outputs up-to-date.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetInputConnection(System.Int32,System.Int32)">
            <summary>
                <para>Get the algorithm output port connected to an input port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetTotalNumberOfInputConnections">
            <summary>
                <para>Get the total number of inputs for this algorithm</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetNumberOfInputConnections(System.Int32)">
            <summary>
                <para>Get the number of inputs currently connected to a port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetOutputPort">
            <summary>
                <para>Get the number of inputs currently connected to a port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetOutputPort(System.Int32)">
            <summary>
                <para>Get a proxy object corresponding to the given output port of this algorithm.  The proxy object can be passed to another algorithm's SetInputConnection(), AddInputConnection(), and RemoveInputConnection() methods to modify pipeline connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.RemoveInputConnection(System.Int32,vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Remove a connection from the given input port index.  See SetInputConnection() for details on input connection.  This method is the complement to AddInputConnection() in that it removes only the connection specified without affecting other connections.  Typical usage is</para>
                <para>filter2-&gt;RemoveInputConnection(0, filter1-&gt;GetOutputPort(0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.AddInputConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Add a connection to the given input port index.  See SetInputConnection() for details on input connections.  This method is the complement to RemoveInputConnection() in that it adds only the connection specified without affecting other connections.  Typical usage is</para>
                <para>filter2-&gt;AddInputConnection(0, filter1-&gt;GetOutputPort(0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.AddInputConnection(System.Int32,vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Add a connection to the given input port index.  See SetInputConnection() for details on input connections.  This method is the complement to RemoveInputConnection() in that it adds only the connection specified without affecting other connections.  Typical usage is</para>
                <para>filter2-&gt;AddInputConnection(0, filter1-&gt;GetOutputPort(0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetInputConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set the connection for the given input port index.  Each input port of a filter has a specific purpose.  A port may have zero or more connections and the required number is specified by each filter.  Setting the connection with this method removes all other connections from the port.  To add more than one connection use AddInputConnection().</para>
                <para>The input for the connection is the output port of another filter, which is obtained with GetOutputPort().  Typical usage is</para>
                <para>filter2-&gt;SetInputConnection(0, filter1-&gt;GetOutputPort(0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetInputConnection(System.Int32,vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set the connection for the given input port index.  Each input port of a filter has a specific purpose.  A port may have zero or more connections and the required number is specified by each filter.  Setting the connection with this method removes all other connections from the port.  To add more than one connection use AddInputConnection().</para>
                <para>The input for the connection is the output port of another filter, which is obtained with GetOutputPort().  Typical usage is</para>
                <para>filter2-&gt;SetInputConnection(0, filter1-&gt;GetOutputPort(0)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetOutputDataObject(System.Int32)">
            <summary>
                <para>Get the data object that will contain the algorithm output for the given port.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.RemoveAllInputs">
            <summary>
                <para>Remove all the input data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetInputArrayInformation(System.Int32)">
            <summary>
                <para>Get the info object for the specified input array to this algorithm</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetInputArrayToProcess(System.Int32,System.Int32,System.Int32,System.String,System.String)">
            <summary>
                <para>String based versions of SetInputArrayToProcess(). Because fieldAssociation and fieldAttributeType are enums, they cannot be easily accessed from scripting language. These methods provides an easy and safe way of passing association and attribute type information. Field association is one of the following: @verbatim vtkDataObject::FIELD_ASSOCIATION_POINTS vtkDataObject::FIELD_ASSOCIATION_CELLS vtkDataObject::FIELD_ASSOCIATION_NONE vtkDataObject::FIELD_ASSOCIATION_POINTS_THEN_CELLS @endverbatim Attribute type is one of the following: @verbatim vtkDataSetAttributes::SCALARS vtkDataSetAttributes::VECTORS vtkDataSetAttributes::NORMALS vtkDataSetAttributes::TCOORDS vtkDataSetAttributes::TENSORS @endverbatim If the last argument is not an attribute type, it is assumed to be an array name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetInputArrayToProcess(System.Int32,vtk.vtkInformation)">
            <summary>
                <para>Set the input data arrays that this algorithm will process. Specifically the idx array that this algorithm will process (starting from 0) is the array on port, connection with the specified association and name or attribute type (such as SCALARS). The fieldAssociation refers to which field in the data object the array is stored. See vtkDataObject::FieldAssociations for detail.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetInputArrayToProcess(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the input data arrays that this algorithm will process. Specifically the idx array that this algorithm will process (starting from 0) is the array on port, connection with the specified association and name or attribute type (such as SCALARS). The fieldAssociation refers to which field in the data object the array is stored. See vtkDataObject::FieldAssociations for detail.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetInputArrayToProcess(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
                <para>Set the input data arrays that this algorithm will process. Specifically the idx array that this algorithm will process (starting from 0) is the array on port, connection with the specified association and name or attribute type (such as SCALARS). The fieldAssociation refers to which field in the data object the array is stored. See vtkDataObject::FieldAssociations for detail.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.INPUT_CONNECTION">
            <summary>
                <para>Keys used to specify input port requirements.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.INPUT_PORT">
            <summary>
                <para>Keys used to specify input port requirements.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.INPUT_ARRAYS_TO_PROCESS">
            <summary>
                <para>Keys used to specify input port requirements.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.INPUT_REQUIRED_DATA_TYPE">
            <summary>
                <para>Keys used to specify input port requirements.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.INPUT_REQUIRED_FIELDS">
            <summary>
                <para>Keys used to specify input port requirements.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.INPUT_IS_REPEATABLE">
            <summary>
                <para>Keys used to specify input port requirements.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.INPUT_IS_OPTIONAL">
            <summary>
                <para>Keys used to specify input port requirements.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetErrorCode">
            <summary>
                <para>The error code contains a possible error that occured while reading or writing the file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetProgressText">
            <summary>
                <para>Set the current text message associated with the progress state. This may be used by a calling process/GUI.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetProgressText(System.String)">
            <summary>
                <para>Set the current text message associated with the progress state. This may be used by a calling process/GUI.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.UpdateProgress(System.Double)">
            <summary>
                <para>Update the progress of the process object. If a ProgressMethod exists, executes it.  Then set the Progress ivar to amount. The parameter amount should range between (0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetProgress">
            <summary>
                <para>Set/Get the execution progress of a process object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetProgressMaxValue">
            <summary>
                <para>Set/Get the execution progress of a process object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetProgressMinValue">
            <summary>
                <para>Set/Get the execution progress of a process object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetProgress(System.Double)">
            <summary>
                <para>Set/Get the execution progress of a process object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.AbortExecuteOff">
            <summary>
                <para>Set/Get the AbortExecute flag for the process object. Process objects may handle premature termination of execution in different ways.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.AbortExecuteOn">
            <summary>
                <para>Set/Get the AbortExecute flag for the process object. Process objects may handle premature termination of execution in different ways.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetAbortExecute">
            <summary>
                <para>Set/Get the AbortExecute flag for the process object. Process objects may handle premature termination of execution in different ways.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetAbortExecute(System.Int32)">
            <summary>
                <para>Set/Get the AbortExecute flag for the process object. Process objects may handle premature termination of execution in different ways.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Participate in garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Participate in garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetNumberOfOutputPorts">
            <summary>
                <para>Get the number of output ports provided by the algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetNumberOfInputPorts">
            <summary>
                <para>Get the number of input ports used by the algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetInformation(vtk.vtkInformation)">
            <summary>
                <para>Set/Get the information object associated with this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetInformation">
            <summary>
                <para>Set/Get the information object associated with this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetOutputPortInformation(System.Int32)">
            <summary>
                <para>Get the information object associated with an output port.  There is one output port per output from the algorithm.  Each output port tells executives what kind of upstream requests this algorithm can handle for that output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetInputPortInformation(System.Int32)">
            <summary>
                <para>Get the information object associated with an input port.  There is one input port per kind of input to the algorithm.  Each input port tells executives what kind of data and downstream requests this algorithm can handle for that input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.ModifyRequest(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>This method gives the algorithm a chance to modify the contents of a request before or after (specified in the when argument) it is forwarded. The default implementation is empty. Returns 1 on success, 0 on failure. When can be either vtkExecutive::BeforeForward or vtkExecutive::AfterForward.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.SetExecutive(vtk.vtkExecutive)">
            <summary>
                <para>Set this algorithm's executive.  This algorithm is removed from any executive to which it has previously been assigned and then assigned to the given executive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.GetExecutive">
            <summary>
                <para>Get this algorithm's executive.  If it has none, a default executive will be created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAlgorithm.HasExecutive">
            <summary>
                <para>Check whether this algorithm has an assigned executive.  This will NOT create a default executive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.InterpolationDerivs(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic tetra specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.InterpolationFunctions(System.Double[],System.Double[])">
            <summary>
                <para>Quadratic tetra specific methods. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.GetParametricDistance(System.Double[])">
            <summary>
                <para>Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the quadratic tetra in parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Line-edge intersection. Intersection has to occur within [0,1] parametric coordinates and with specified tolerance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Clip this edge using scalar value provided. Like contouring, except that it cuts the tetra to produce new tetras.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.GetFace(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.GetEdge(System.Int32)">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.GetNumberOfFaces">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.GetNumberOfEdges">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.GetCellDimension">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadraticTetra.GetCellType">
            <summary>
                <para>Implement the vtkCell API. See the vtkCell API for descriptions  of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkNonLinearCell.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.Tessellate(System.Int32,vtk.vtkDataSet,vtk.vtkUnstructuredGrid,vtk.vtkPointLocator)">
            <summary>
                <para>This method tessellates the cell returning unstructured grid. (The Error ivar controls the tessellation depth.) The new dataset will contain unstructured grid primitives, possibly new points as well as interpolated point and cell data.  The user must provide (the output) unstructured grid which is filled in by the method. If the optional PointLocator is supplied, then any new points that are created are inserted through the vtkPointLocator, rather than directly in the vtkUnstructuredGrid.  (Note: the input dataset and cellId are used if the cell requires access to its owning dataset.) This method is called when the topological dimension of the cell is 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.Tessellate(System.Int32,vtk.vtkDataSet,vtk.vtkPolyData,vtk.vtkPointLocator)">
            <summary>
                <para>This method tessellates the cell returning polydata. (The Error ivar controls the tessellation depth.) The new dataset will contain polydata primitives, possibly new points as well as interpolated point and cell data.  The user must provide (the output) polydata which is filled in by the method. If the optional PointLocator is supplied, then any new points that are created are inserted through the vtkPointLocator, rather than directly in the vtkPolyData.  (Note: the input dataset and cellId are used if the cell requires access to its owning dataset.) This method is called when the topological dimension of the cell is 2D or less.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.IsLinear">
            <summary>
                <para>This method tessellates the cell returning polydata. (The Error ivar controls the tessellation depth.) The new dataset will contain polydata primitives, possibly new points as well as interpolated point and cell data.  The user must provide (the output) polydata which is filled in by the method. If the optional PointLocator is supplied, then any new points that are created are inserted through the vtkPointLocator, rather than directly in the vtkPolyData.  (Note: the input dataset and cellId are used if the cell requires access to its owning dataset.) This method is called when the topological dimension of the cell is 2D or less.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.GetError">
            <summary>
                <para>Set/Get the normalized error measure used to control the  tessellation of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.GetErrorMaxValue">
            <summary>
                <para>Set/Get the normalized error measure used to control the  tessellation of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.GetErrorMinValue">
            <summary>
                <para>Set/Get the normalized error measure used to control the  tessellation of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkNonLinearCell.SetError(System.Double)">
            <summary>
                <para>Set/Get the normalized error measure used to control the  tessellation of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetLongAttributeTypeAsString(System.Int32)">
            <summary>
                <para>Given an integer attribute type, this static method returns a string type for the attribute (i.e. type = 0: returns "Scalars").</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetAttributeTypeAsString(System.Int32)">
            <summary>
                <para>Given an integer attribute type, this static method returns a string type for the attribute (i.e. type = 0: returns "Scalars").</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.RemoveArray(System.String)">
            <summary>
                <para>Remove an array (with the given name) from the list of arrays.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetAttribute(System.Int32)">
            <summary>
                <para>Return an attribute given the attribute type (see vtkDataSetAttributes::AttributeTypes).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.IsArrayAnAttribute(System.Int32)">
            <summary>
                <para>Determine whether a data array of index idx is considered a data set attribute (i.e., scalar, vector, tensor, etc). Return less-than zero  if it is, otherwise an index 0&lt;=idx&lt;NUM_ATTRIBUTES to indicate  which attribute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetAttributeIndices(System.Int32[])">
            <summary>
                <para>Get the field data array indices corresponding to scalars,  vectors, tensors, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyTuple(vtk.vtkDataArray,vtk.vtkDataArray,System.Int32,System.Int32)">
            <summary>
                <para>Copy a tuple of data from one data array to another. This method (and following ones) assume that the fromData and toData objects are of the same type, and have the same number of components. This is true if you invoke CopyAllocate() or InterpolateAllocate().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyAllOff">
            <summary>
                <para>Turn off copying of all data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyAllOn">
            <summary>
                <para>Turn on copying of all data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyTensorsOff">
            <summary>
                <para>Turn on/off the copying of tensor data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyTensorsOn">
            <summary>
                <para>Turn on/off the copying of tensor data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetCopyTensors">
            <summary>
                <para>Turn on/off the copying of tensor data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetCopyTensors(System.Int32)">
            <summary>
                <para>Turn on/off the copying of tensor data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyTCoordsOff">
            <summary>
                <para>Turn on/off the copying of texture coordinates data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyTCoordsOn">
            <summary>
                <para>Turn on/off the copying of texture coordinates data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetCopyTCoords">
            <summary>
                <para>Turn on/off the copying of texture coordinates data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetCopyTCoords(System.Int32)">
            <summary>
                <para>Turn on/off the copying of texture coordinates data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyNormalsOff">
            <summary>
                <para>Turn on/off the copying of normals data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyNormalsOn">
            <summary>
                <para>Turn on/off the copying of normals data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetCopyNormals">
            <summary>
                <para>Turn on/off the copying of normals data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetCopyNormals(System.Int32)">
            <summary>
                <para>Turn on/off the copying of normals data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyVectorsOff">
            <summary>
                <para>Turn on/off the copying of vector data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyVectorsOn">
            <summary>
                <para>Turn on/off the copying of vector data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetCopyVectors">
            <summary>
                <para>Turn on/off the copying of vector data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetCopyVectors(System.Int32)">
            <summary>
                <para>Turn on/off the copying of vector data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyScalarsOff">
            <summary>
                <para>Turn on/off the copying of scalar data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyScalarsOn">
            <summary>
                <para>Turn on/off the copying of scalar data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetCopyScalars">
            <summary>
                <para>Turn on/off the copying of scalar data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetCopyScalars(System.Int32)">
            <summary>
                <para>Turn on/off the copying of scalar data. During the copy/pass, the following rules are followed for each array: 1. If the copy flag for an attribute is set (on or off), it is applied.    This overrides rules 2 and 3. 2. If the copy flag for an array is set (on or off), it is applied    This overrides rule 3. 3. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetCopyAttribute(System.Int32,System.Int32)">
            <summary>
                <para>Specify whether to copy the data attribute referred to by index i.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetActiveAttribute(System.Int32,System.Int32)">
            <summary>
                <para>Make the array with the given index the active attribute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetActiveAttribute(System.String,System.Int32)">
            <summary>
                <para>Make the array with the given name the active attribute. Attribute types are:  vtkDataSetAttributes::SCALARS = 0  vtkDataSetAttributes::VECTORS = 1  vtkDataSetAttributes::NORMALS = 2  vtkDataSetAttributes::TCOORDS = 3  vtkDataSetAttributes::TENSORS = 4 Returns the index of the array if succesful, -1 if the array  is not in the list of arrays.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetTensors(System.String)">
            <summary>
                <para>This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetTCoords(System.String)">
            <summary>
                <para>This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetNormals(System.String)">
            <summary>
                <para>This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetVectors(System.String)">
            <summary>
                <para>This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetScalars(System.String)">
            <summary>
                <para>This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetTensors">
            <summary>
                <para>Set/Get the tensor data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetActiveTensors(System.String)">
            <summary>
                <para>Set/Get the tensor data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetTensors(vtk.vtkDataArray)">
            <summary>
                <para>Set/Get the tensor data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetTCoords">
            <summary>
                <para>Set/Get the texture coordinate data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetActiveTCoords(System.String)">
            <summary>
                <para>Set/Get the texture coordinate data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetTCoords(vtk.vtkDataArray)">
            <summary>
                <para>Set/Get the texture coordinate data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetNormals">
            <summary>
                <para>Set/get the normal data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetActiveNormals(System.String)">
            <summary>
                <para>Set/get the normal data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetNormals(vtk.vtkDataArray)">
            <summary>
                <para>Set/get the normal data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetVectors">
            <summary>
                <para>Set/Get the vector data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetActiveVectors(System.String)">
            <summary>
                <para>Set/Get the vector data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetVectors(vtk.vtkDataArray)">
            <summary>
                <para>Set/Get the vector data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.GetScalars">
            <summary>
                <para>Set/Get the scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetActiveScalars(System.String)">
            <summary>
                <para>Set/Get the scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.SetScalars(vtk.vtkDataArray)">
            <summary>
                <para>Set/Get the scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.ShallowCopy(vtk.vtkFieldData)">
            <summary>
                <para>Shallow copy of data (i.e., use reference counting).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.DeepCopy(vtk.vtkFieldData)">
            <summary>
                <para>Deep copy of data (i.e., create new data arrays and copy from input data).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.InterpolateTime(vtk.vtkDataSetAttributes,vtk.vtkDataSetAttributes,System.Int32,System.Double)">
            <summary>
                <para>Interpolate data from the same id (point or cell) at different points in time (parameter t). Two input data set attributes objects are input. The parameter t lies between (0&lt;=t&lt;=1). IMPORTANT: it is assumed that the number of attributes and number of components is the same for both from1 and from2, and the type of data for from1 and from2 are the same. Make sure that the method InterpolateAllocate() has been invoked before  using this method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.InterpolateEdge(vtk.vtkDataSetAttributes,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Interpolate data from the two points p1,p2 (forming an edge) and an  interpolation factor, t, along the edge. The weight ranges from (0,1),  with t=0 located at p1. Make sure that the method InterpolateAllocate()  has been invoked before using this method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.InterpolatePoint(vtk.vtkDataSetAttributes,System.Int32,vtk.vtkIdList,System.Double[])">
            <summary>
                <para>Interpolate data set attributes from other data set attributes given cell or point ids and associated interpolation weights.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyStructuredData(vtk.vtkDataSetAttributes,System.Int32[],System.Int32[])">
            <summary>
                <para>This method is used to copy data arrays in images. You should not call "CopyAllocate" before calling this method. This method is called once to copy all of the data. If the two extents are the same, this method calls "PassData".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.InterpolateAllocate(vtk.vtkDataSetAttributes,System.Int32,System.Int32)">
            <summary>
                <para>Initialize point interpolation method. Note that pd HAS to be the vtkDataSetAttributes object which will later be used with InterpolatePoint or InterpolateEdge. ext is no longer used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyData(vtk.vtkDataSetAttributes,System.Int32,System.Int32)">
            <summary>
                <para>Copy the attribute data from one id to another. Make sure CopyAllocate() has been invoked before using this method. When copying a field,   the following copying rules are  followed: 1) Check if a field is an attribute, if yes and if there is a copy flag for that attribute (on or off), obey the  flag for  that attribute, ignore (2) and (3), 2) if there is a copy field for that field (on or off), obey the flag, ignore (3) 3) obey CopyAllOn/Off</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.CopyAllocate(vtk.vtkDataSetAttributes,System.Int32,System.Int32)">
            <summary>
                <para>Allocates point data for point-by-point (or cell-by-cell) copy operation. If sze=0, then use the input DataSetAttributes to create (i.e., find  initial size of) new objects; otherwise use the sze variable. Note that pd HAS to be the vtkDataSetAttributes object which will later be used with CopyData. If this is not the case, consider using the alternative forms of CopyAllocate and CopyData. ext is no longer used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.PassData(vtk.vtkFieldData)">
            <summary>
                <para>Pass entire arrays of input data through to output. Obey the "copy" flags. When passing a field,  the following copying rules are  followed: 1) Check if a field is an attribute, if yes and if there is a copy flag for that attribute (on or off), obey the  flag for  that attribute, ignore (2) and (3), 2) if there is a copy field for that field (on or off), obey the flag, ignore (3) 3) obey CopyAllOn/Off</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.Update">
            <summary>
                <para>Pass entire arrays of input data through to output. Obey the "copy" flags. When passing a field,  the following copying rules are  followed: 1) Check if a field is an attribute, if yes and if there is a copy flag for that attribute (on or off), obey the  flag for  that attribute, ignore (2) and (3), 2) if there is a copy field for that field (on or off), obey the flag, ignore (3) 3) obey CopyAllOn/Off</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetAttributes.Initialize">
            <summary>
                <para>Initialize all of the object's data to NULL Also, clear the copy flags.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFieldData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFieldData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFieldData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFieldData.InsertComponent(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Insert the component value at the ith tuple (or row) and jth component (or column).  Range checking is performed and memory allocated as necessary o hold data. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.SetComponent(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Set the component value at the ith tuple (or row) and jth component (or column).  Range checking is not performed, so set the object up properly before invoking. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetComponent(System.Int32,System.Int32)">
            <summary>
                <para>Get the component value at the ith tuple (or row) and jth component (or column). This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.InsertNextTuple(System.Double[])">
            <summary>
                <para>Insert the tuple value at the end of the tuple matrix. Range checking is performed and memory is allocated as necessary. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.InsertTuple(System.Int32,System.Double[])">
            <summary>
                <para>Insert the tuple value at the ith location. Range checking is performed and memory allocates as necessary. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.SetTuple(System.Int32,System.Double[])">
            <summary>
                <para>Set the tuple value at the ith location. Set operations mean that no range checking is performed, so they're faster. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetTuple(System.Int32,System.Double[])">
            <summary>
                <para>Copy the ith tuple value into a user provided tuple array. Make sure that you've allocated enough space for the copy. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.SetNumberOfTuples(System.Int32)">
            <summary>
                <para>Set the number of tuples for each data array in the field. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetNumberOfTuples">
            <summary>
                <para>Get the number of tuples in the field. Note: some fields have arrays with different numbers of tuples; this method returns the number of tuples in the first array. Mixed-length arrays may have to be treated specially. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetNumberOfComponents">
            <summary>
                <para>Get the number of components in the field. This is determined by adding up the components in each non-NULL array. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetArrayContainingComponent(System.Int32,System.Int32@)">
            <summary>
                <para>Return the array containing the ith component of the field. The return value is an integer number n 0&lt;=n&lt;this-&gt;NumberOfArrays. Also, an integer value is returned indicating the component in the array is returned. Method returns -1 if specified component is not in the field. This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData). This is because in those cases, the attribute data is  stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetField(vtk.vtkIdList,vtk.vtkFieldData)">
            <summary>
                <para>Get a field from a list of ids. Supplied field f should have same types and number of data arrays as this one (i.e., like CopyStructure() creates).  This method should not be used if the instance is from a subclass of vtkFieldData (vtkPointData or vtkCellData).  This is because in those cases, the attribute data is stored with the other fields and will cause the method to behave in an unexpected way.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetMTime">
            <summary>
                <para>Check object's components for modified times.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetActualMemorySize">
            <summary>
                <para>Return the memory in kilobytes consumed by this field data. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.Reset">
            <summary>
                <para>Resets each data array in the field (Reset() does not release memory but it makes the arrays look like they are empty.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.Squeeze">
            <summary>
                <para>Squeezes each data array in the field (Squeeze() reclaims unused memory.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.ShallowCopy(vtk.vtkFieldData)">
            <summary>
                <para>Copy a field by reference counting the data arrays.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.DeepCopy(vtk.vtkFieldData)">
            <summary>
                <para>Copy a field by creating new data arrays (i.e., duplicate storage).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.CopyAllOff">
            <summary>
                <para>Turn off copying of all data. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.CopyAllOn">
            <summary>
                <para>Turn on copying of all data. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.CopyFieldOff(System.String)">
            <summary>
                <para>Turn on copying of all data. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.CopyFieldOn(System.String)">
            <summary>
                <para>Turn on/off the copying of the field specified by name. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.PassData(vtk.vtkFieldData)">
            <summary>
                <para>Pass entire arrays of input data through to output. Obey the "copy" flags.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetArrayName(System.Int32)">
            <summary>
                <para>Pass entire arrays of input data through to output. Obey the "copy" flags.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.HasArray(System.String)">
            <summary>
                <para>Get the name of ith array. Note that this is equivalent to: GetArray(i)-&gt;GetName() if ith array pointer is not NULL</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetArray(System.String)">
            <summary>
                <para>Return 1 if an array with the given name could be found. 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetArray(System.String,System.Int32@)">
            <summary>
                <para>Return the array with the name given. Returns NULL is array not found. Also returns index of array if found, -1 otherwise</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetArray(System.Int32)">
            <summary>
                <para>Return the ith array in the field. A NULL is returned if the index i is out of range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.RemoveArray(System.String)">
            <summary>
                <para>Return the ith array in the field. A NULL is returned if the index i is out of range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.AddArray(vtk.vtkDataArray)">
            <summary>
                <para>Add an array to the array list. If an array with the same name already exists - then the added array will replace it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.GetNumberOfArrays">
            <summary>
                <para>Add an array to the array list. If an array with the same name already exists - then the added array will replace it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.AllocateArrays(System.Int32)">
            <summary>
                <para>AllocateOfArrays actually sets the number of vtkDataArray pointers in the vtkFieldData object, not the number of used pointers (arrays). Adding more arrays will cause the object to dynamically adjust the number of pointers if it needs to extend. Although AllocateArrays can be used if the number of arrays which will be added is known, it can be omitted with a small computation cost.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.CopyStructure(vtk.vtkFieldData)">
            <summary>
                <para>Copy data array structure from a given field.  The same arrays will exist with the same types, but will contain nothing in the copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate data for each array. Note that ext is no longer used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldData.Initialize">
            <summary>
                <para>Release all data but do not delete object. Also, clear the copy flags.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkConvexPointSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return the center of the cell in parametric coordinates. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>Returns the set of points forming a face of the triangulation of these points that are on the boundary of the cell that are closest  parametrically to the point specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>Computes derivatives by triangulating and from subId and pcoords, evaluating derivatives on the resulting tetrahedron.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>Triangulate using methods of vtkOrderedTriangulator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Triangulates the cells and then intersects them to determine the intersection point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>The inverse of EvaluatePosition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>Satisfy the vtkCell API. This method determines the subId, pcoords, and weights by triangulating the convex point set, and then  determining which tetrahedron the point lies in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Satisfy the vtkCell API. This method contours by triangulating the cell and then adding clip-edge intersection points into the triangulation; extracting the clipped region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>Satisfy the vtkCell API. This method contours by triangulating the cell and then contouring the resulting tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.GetFace(System.Int32)">
            <summary>
                <para>A convex point set has no explicit cell edge or faces; however implicitly (after triangulation) it does. Currently the method GetNumberOfEdges() always returns 0 while the GetNumberOfFaces() returns the number of boundary triangles of the triangulation of the convex point set. The method GetNumberOfFaces() triggers a triangulation of the convex point set; repeated calls to GetFace() then return the boundary faces. (Note: GetNumberOfEdges() currently returns 0 because it is a  rarely used method and hard to implement. It can be changed in the future.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.GetNumberOfFaces">
            <summary>
                <para>A convex point set has no explicit cell edge or faces; however implicitly (after triangulation) it does. Currently the method GetNumberOfEdges() always returns 0 while the GetNumberOfFaces() returns the number of boundary triangles of the triangulation of the convex point set. The method GetNumberOfFaces() triggers a triangulation of the convex point set; repeated calls to GetFace() then return the boundary faces. (Note: GetNumberOfEdges() currently returns 0 because it is a  rarely used method and hard to implement. It can be changed in the future.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.GetEdge(System.Int32)">
            <summary>
                <para>A convex point set has no explicit cell edge or faces; however implicitly (after triangulation) it does. Currently the method GetNumberOfEdges() always returns 0 while the GetNumberOfFaces() returns the number of boundary triangles of the triangulation of the convex point set. The method GetNumberOfFaces() triggers a triangulation of the convex point set; repeated calls to GetFace() then return the boundary faces. (Note: GetNumberOfEdges() currently returns 0 because it is a  rarely used method and hard to implement. It can be changed in the future.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.GetNumberOfEdges">
            <summary>
                <para>A convex point set has no explicit cell edge or faces; however implicitly (after triangulation) it does. Currently the method GetNumberOfEdges() always returns 0 while the GetNumberOfFaces() returns the number of boundary triangles of the triangulation of the convex point set. The method GetNumberOfFaces() triggers a triangulation of the convex point set; repeated calls to GetFace() then return the boundary faces. (Note: GetNumberOfEdges() currently returns 0 because it is a  rarely used method and hard to implement. It can be changed in the future.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.Initialize">
            <summary>
                <para>This cell requires that it be initialized prior to access.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.RequiresInitialization">
            <summary>
                <para>This cell requires that it be initialized prior to access.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.GetCellType">
            <summary>
                <para>This cell requires that it be initialized prior to access.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConvexPointSet.HasFixedTopology">
            <summary>
                <para>See vtkCell3D API for description of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCell3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCell3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCell3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCell3D.GetMergeTolerance">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell3D.GetMergeToleranceMaxValue">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell3D.GetMergeToleranceMinValue">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell3D.SetMergeTolerance(System.Double)">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell3D.GetCellDimension">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell3D.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Cut (or clip) the cell based on the input cellScalars and the specified value. The output of the clip operation will be one or more cells of the same topological dimension as the original cell.  The flag insideOut controls what part of the cell is considered inside - normally cell points whose scalar value is greater than "value" are considered inside. If insideOut is on, this is reversed. Also, if the output cell data is non-NULL, the cell data from the clipped cell is passed to the generated contouring primitives. (Note: the CopyAllocate() method must be invoked on both the output cell and point data. The cellId refers to the cell from which the cell data is copied.)  (Satisfies vtkCell API.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.Length(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.RemoveItem(vtk.vtkInformation,vtk.vtkInformationKey)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.AppendUnique(vtk.vtkInformation,vtk.vtkInformationKey)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKeyVectorKey.Append(vtk.vtkInformation,vtk.vtkInformationKey)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.MapScalarsThroughTable2(System.IntPtr,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>map a set of scalars through the lookup table</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.FillFromDataPointer(System.Int32,System.Double[])">
            <summary>
                <para>Returns a list of all nodes Fills from a pointer to data stored in a similar list of nodes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.SetColorSpaceToHSVNoWrap">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.HSVWrapOff">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.HSVWrapOn">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetHSVWrap">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.SetHSVWrap(System.Int32)">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetColorSpace">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.SetColorSpaceToHSV">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.SetColorSpaceToRGB">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetColorSpaceMaxValue">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetColorSpaceMinValue">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.SetColorSpace(System.Int32)">
            <summary>
                <para>Set/Get the color space used for interpolation: RGB, or HSV. In HSV mode, if HSVWrap is on, it  will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if HSVWrap is off it will not go through 0 (in order the match the current functionality of vtkLookupTable)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.ClampingOff">
            <summary>
                <para>Sets and gets the clamping value for this transfer function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.ClampingOn">
            <summary>
                <para>Sets and gets the clamping value for this transfer function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetClamping">
            <summary>
                <para>Sets and gets the clamping value for this transfer function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetClampingMaxValue">
            <summary>
                <para>Sets and gets the clamping value for this transfer function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetClampingMinValue">
            <summary>
                <para>Sets and gets the clamping value for this transfer function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.SetClamping(System.Int32)">
            <summary>
                <para>Sets and gets the clamping value for this transfer function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.BuildFunctionFromTable(System.Double,System.Double,System.Int32,System.Double[])">
            <summary>
                <para>Construct a color transfer function from a table. Function range is is set to [x1, x2], each function size is set to size, and function  points are regularly spaced between x1 and x2. Parameter "table" is  assumed to be a block of memory of size [3*size]</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetTable(System.Double,System.Double,System.Int32,System.Single[])">
            <summary>
                <para>Fills in a table of n function values between x1 and x2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetTable(System.Double,System.Double,System.Int32,System.Double[])">
            <summary>
                <para>Fills in a table of n function values between x1 and x2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.AdjustRange(System.Double[])">
            <summary>
                <para>Remove all points out of the new range, and make sure there is a point at each end of that range. Return 1 on success, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetRange">
            <summary>
                <para>Returns min and max position of all function points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetBlueValue(System.Double)">
            <summary>
                <para>Get the color components individually.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetGreenValue(System.Double)">
            <summary>
                <para>Get the color components individually.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetRedValue(System.Double)">
            <summary>
                <para>Get the color components individually.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetColor(System.Double,System.Double[])">
            <summary>
                <para>Returns an RGB color for the specified scalar value </para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetColor(System.Double)">
            <summary>
                <para>Returns an RGB color for the specified scalar value </para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.RemoveAllPoints">
            <summary>
                <para>Remove all points</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.AddHSVSegment(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Add two points to the function and remove all the points  between them</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.AddRGBSegment(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Add two points to the function and remove all the points  between them</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.RemovePoint(System.Double)">
            <summary>
                <para>Add/Remove a point to/from the function defined in RGB or HSV Return the index of the point (0 based), or -1 on error.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.AddHSVPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Add/Remove a point to/from the function defined in RGB or HSV Return the index of the point (0 based), or -1 on error.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.AddRGBPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Add/Remove a point to/from the function defined in RGB or HSV Return the index of the point (0 based), or -1 on error.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkColorTransferFunction.GetSize">
            <summary>
                <para>How many points are there defining this function?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.Clear">
            <summary>
                <para>Initializes the data structure to empty.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.DeepCopy(vtk.vtkHierarchicalDataInformation)">
            <summary>
                <para>Creates a duplicate hierarchy and calls Copy() on each information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.HasInformation(System.UInt32,System.UInt32)">
            <summary>
                <para>Returns 1 if information exists, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.GetInformation(System.UInt32,System.UInt32)">
            <summary>
                <para>Given a level and a dataset id, returns the corresponding information object. If the information does not exist, one is created. Use HasInformation() to check whether the information already exists.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.SetNumberOfDataSets(System.UInt32,System.UInt32)">
            <summary>
                <para>Given a level, sets the number of datasets.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.GetNumberOfDataSets(System.UInt32)">
            <summary>
                <para>Given a level, returns the number of datasets.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.SetNumberOfLevels(System.UInt32)">
            <summary>
                <para>Set the number of hierarchy levels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataInformation.GetNumberOfLevels">
            <summary>
                <para>Returns the number of hierarchy levels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInformation.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformation.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformation.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformation.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformation.SetRequest(vtk.vtkInformationRequestKey)">
            <summary>
                <para>Get/Set the Request ivar</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Initiate garbage collection when a reference is removed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Initiate garbage collection when a reference is removed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationUnsignedLongKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationStringKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationRequestKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationIntegerVectorKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationIntegerKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationInformationVectorKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationInformationKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationExecutivePortKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationDoubleVectorKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationDoubleKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetKey(vtk.vtkInformationDataObjectKey)">
            <summary>
                <para>Upcast the given key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationExecutivePortVectorKey)">
            <summary>
                <para>Get/Set an entry storing a vector of vtkExecutive/port number pairs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationExecutivePortVectorKey)">
            <summary>
                <para>Get/Set an entry storing a vector of vtkExecutive/port number pairs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Length(vtk.vtkInformationExecutivePortVectorKey)">
            <summary>
                <para>Get/Set an entry storing a vector of vtkExecutive/port number pairs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationExecutivePortVectorKey,vtk.vtkExecutive,System.Int32)">
            <summary>
                <para>Get/Set an entry storing a vector of vtkExecutive/port number pairs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Append(vtk.vtkInformationExecutivePortVectorKey,vtk.vtkExecutive,System.Int32)">
            <summary>
                <para>Get/Set an entry storing a vector of vtkExecutive/port number pairs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationExecutivePortKey)">
            <summary>
                <para>Get/Set an entry storing a vtkExecutive/port number pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationExecutivePortKey)">
            <summary>
                <para>Get/Set an entry storing a vtkExecutive/port number pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetPort(vtk.vtkInformationExecutivePortKey)">
            <summary>
                <para>Get/Set an entry storing a vtkExecutive/port number pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.GetExecutive(vtk.vtkInformationExecutivePortKey)">
            <summary>
                <para>Get/Set an entry storing a vtkExecutive/port number pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationExecutivePortKey,vtk.vtkExecutive,System.Int32)">
            <summary>
                <para>Get/Set an entry storing a vtkExecutive/port number pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationDataObjectKey)">
            <summary>
                <para>Get/Set an entry storing a vtkDataObject instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationDataObjectKey)">
            <summary>
                <para>Get/Set an entry storing a vtkDataObject instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationDataObjectKey)">
            <summary>
                <para>Get/Set an entry storing a vtkDataObject instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationDataObjectKey,vtk.vtkDataObject)">
            <summary>
                <para>Get/Set an entry storing a vtkDataObject instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationObjectBaseKey)">
            <summary>
                <para>Get/Set an entry storing a vtkObjectBase instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationObjectBaseKey)">
            <summary>
                <para>Get/Set an entry storing a vtkObjectBase instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationObjectBaseKey)">
            <summary>
                <para>Get/Set an entry storing a vtkObjectBase instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationObjectBaseKey,vtk.vtkObjectBase)">
            <summary>
                <para>Get/Set an entry storing a vtkObjectBase instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationInformationVectorKey)">
            <summary>
                <para>Get/Set an entry storing a vtkInformationVector instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationInformationVectorKey)">
            <summary>
                <para>Get/Set an entry storing a vtkInformationVector instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationInformationVectorKey)">
            <summary>
                <para>Get/Set an entry storing a vtkInformationVector instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationInformationVectorKey,vtk.vtkInformationVector)">
            <summary>
                <para>Get/Set an entry storing a vtkInformationVector instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationInformationKey)">
            <summary>
                <para>Get/Set an entry storing another vtkInformation instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationInformationKey)">
            <summary>
                <para>Get/Set an entry storing another vtkInformation instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationInformationKey)">
            <summary>
                <para>Get/Set an entry storing another vtkInformation instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationInformationKey,vtk.vtkInformation)">
            <summary>
                <para>Get/Set an entry storing another vtkInformation instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationStringKey)">
            <summary>
                <para>Get/Set a string-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationStringKey)">
            <summary>
                <para>Get/Set a string-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationStringKey)">
            <summary>
                <para>Get/Set a string-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationStringKey,System.String)">
            <summary>
                <para>Get/Set a string-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationKeyVectorKey)">
            <summary>
                <para>Get/Set an InformationKey-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationKeyVectorKey)">
            <summary>
                <para>Get/Set an InformationKey-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Length(vtk.vtkInformationKeyVectorKey)">
            <summary>
                <para>Get/Set an InformationKey-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationKeyVectorKey,vtk.vtkInformationKey)">
            <summary>
                <para>Get/Set an InformationKey-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.AppendUnique(vtk.vtkInformationKeyVectorKey,vtk.vtkInformationKey)">
            <summary>
                <para>Get/Set an InformationKey-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Append(vtk.vtkInformationKeyVectorKey,vtk.vtkInformationKey)">
            <summary>
                <para>Get/Set an InformationKey-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationDoubleVectorKey)">
            <summary>
                <para>Get/Set an double-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationDoubleVectorKey)">
            <summary>
                <para>Get/Set an double-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Length(vtk.vtkInformationDoubleVectorKey)">
            <summary>
                <para>Get/Set an double-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationDoubleVectorKey,System.Double[])">
            <summary>
                <para>Get/Set an double-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationDoubleVectorKey,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Get/Set an double-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationDoubleVectorKey,System.Double,System.Double,System.Double)">
            <summary>
                <para>Get/Set an double-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationDoubleVectorKey,System.Double[],System.Int32)">
            <summary>
                <para>Get/Set an double-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Append(vtk.vtkInformationDoubleVectorKey,System.Double)">
            <summary>
                <para>Get/Set an double-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationUnsignedLongKey)">
            <summary>
                <para>Get/Set an unsigned-long-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationUnsignedLongKey)">
            <summary>
                <para>Get/Set an unsigned-long-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationUnsignedLongKey)">
            <summary>
                <para>Get/Set an unsigned-long-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationUnsignedLongKey,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Get/Set an unsigned-long-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationIntegerPointerKey)">
            <summary>
                <para>Get/Set an integer-pointer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationIntegerPointerKey)">
            <summary>
                <para>Get/Set an integer-pointer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Length(vtk.vtkInformationIntegerPointerKey)">
            <summary>
                <para>Get/Set an integer-pointer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationIntegerPointerKey,System.Int32[])">
            <summary>
                <para>Get/Set an integer-pointer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationIntegerPointerKey,System.Int32[],System.Int32)">
            <summary>
                <para>Get/Set an integer-pointer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationIntegerVectorKey)">
            <summary>
                <para>Get/Set an integer-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationIntegerVectorKey)">
            <summary>
                <para>Get/Set an integer-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Length(vtk.vtkInformationIntegerVectorKey)">
            <summary>
                <para>Get/Set an integer-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationIntegerVectorKey,System.Int32[])">
            <summary>
                <para>Get/Set an integer-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationIntegerVectorKey,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Get/Set an integer-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationIntegerVectorKey,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Get/Set an integer-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationIntegerVectorKey,System.Int32[],System.Int32)">
            <summary>
                <para>Get/Set an integer-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Append(vtk.vtkInformationIntegerVectorKey,System.Int32)">
            <summary>
                <para>Get/Set an integer-vector-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationDoubleKey)">
            <summary>
                <para>Get/Set an double-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationDoubleKey)">
            <summary>
                <para>Get/Set an double-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationDoubleKey)">
            <summary>
                <para>Get/Set an double-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationDoubleKey,System.Double)">
            <summary>
                <para>Get/Set an double-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationIdTypeKey)">
            <summary>
                <para>Get/Set a vtkIdType-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationIdTypeKey)">
            <summary>
                <para>Get/Set a vtkIdType-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationIdTypeKey)">
            <summary>
                <para>Get/Set a vtkIdType-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationIdTypeKey,System.Int32)">
            <summary>
                <para>Get/Set a vtkIdType-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationIntegerKey)">
            <summary>
                <para>Get/Set an integer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationIntegerKey)">
            <summary>
                <para>Get/Set an integer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Get(vtk.vtkInformationIntegerKey)">
            <summary>
                <para>Get/Set an integer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationIntegerKey,System.Int32)">
            <summary>
                <para>Get/Set an integer-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Has(vtk.vtkInformationRequestKey)">
            <summary>
                <para>Get/Set a request-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Remove(vtk.vtkInformationRequestKey)">
            <summary>
                <para>Get/Set a request-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Set(vtk.vtkInformationRequestKey)">
            <summary>
                <para>Get/Set a request-valued entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntries(vtk.vtkInformation,vtk.vtkInformationKeyVectorKey,System.Int32)">
            <summary>
                <para>Use the given key to lookup a list of other keys in the given information object.  The key/value pairs associated with these other keys will be copied.  If deep==1, a deep copy of the information structure is performed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationUnsignedLongKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationStringKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationRequestKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationIntegerVectorKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationIntegerKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationInformationVectorKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationInformationKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationExecutivePortKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationDoubleVectorKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationDataObjectKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.CopyEntry(vtk.vtkInformation,vtk.vtkInformationKey,System.Int32)">
            <summary>
                <para>Copy the key/value pair associated with the given key in the given information object.  If deep=1, a deep copy of the information structure is performed (new instances of any contained vtkInformation and  vtkInformationVector objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Copy(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>Copy all information entries from the given vtkInformation instance.  Any previously existing entries are removed.  If  deep==1, a deep copy of the information structure is performed (new  instances of any contained vtkInformation and vtkInformationVector  objects are created).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformation.Clear">
            <summary>
                <para>Clear all information entries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.Has(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.Length(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.Get(vtk.vtkInformation,System.Int32[])">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.Set(vtk.vtkInformation,System.Int32[],System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationIntegerVectorKey.Append(vtk.vtkInformation,System.Int32)">
            <summary>
                <para>Get/Set the value associated with this key in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInformationKey.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInformationKey.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInformationKey.Print(vtk.vtkInformation)">
            <summary>
                <para>Print the key's value in an information object to a stream.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.Report(vtk.vtkInformation,vtk.vtkGarbageCollector)">
            <summary>
                <para>Report a reference this key has in the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.Remove(vtk.vtkInformation)">
            <summary>
                <para>Remove this key from the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.DeepCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Remove this key from the given information object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.ShallowCopy(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy the entry associated with this key from one information object to another.  If there is no entry in the first information object for this key, the value is removed from the second.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.GetLocation">
            <summary>
                <para>Get the location of the key.  This is the name of the class in which the key is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.GetName">
            <summary>
                <para>Get the name of the key.  This is not the type of the key, but the name of the key instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Prevent normal vtkObject reference counting behavior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInformationKey.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Prevent normal vtkObject reference counting behavior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointLocator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointLocator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointLocator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPointLocator.GenerateRepresentation(System.Int32,vtk.vtkPolyData)">
            <summary>
                <para>See vtkLocator interface documentation. These methods are not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.BuildLocator">
            <summary>
                <para>See vtkLocator interface documentation. These methods are not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FreeSearchStructure">
            <summary>
                <para>See vtkLocator interface documentation. These methods are not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.Initialize">
            <summary>
                <para>See vtkLocator interface documentation. These methods are not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.GetPoints">
            <summary>
                <para>Provide an accessor to the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.GetPointsInBucket(System.Double[],System.Int32[])">
            <summary>
                <para>Given a position x, return the list of points in the bucket that contains the point. It is possible that NULL is returned. The user provides an ijk array that is the indices into the locator. This method is thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindPointsWithinRadius(System.Double,System.Double,System.Double,System.Double,vtk.vtkIdList)">
            <summary>
                <para>Find all points within a specified radius R of position x. The result is not sorted in any specific manner. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindPointsWithinRadius(System.Double,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>Find all points within a specified radius R of position x. The result is not sorted in any specific manner. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindDistributedPoints(System.Int32,System.Double,System.Double,System.Double,vtk.vtkIdList,System.Int32)">
            <summary>
                <para>Find the closest points to a position such that each octant of space around the position contains at least N points. Loosely  limit the search to a maximum number of points evaluated, M.  These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindDistributedPoints(System.Int32,System.Double[],vtk.vtkIdList,System.Int32)">
            <summary>
                <para>Find the closest points to a position such that each octant of space around the position contains at least N points. Loosely  limit the search to a maximum number of points evaluated, M.  These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindClosestNPoints(System.Int32,System.Double,System.Double,System.Double,vtk.vtkIdList)">
            <summary>
                <para>Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindClosestNPoints(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindClosestInsertedPoint(System.Double[])">
            <summary>
                <para>Given a position x, return the id of the point closest to it. This method is used when performing incremental point insertion. Note that -1  indicates that no point was found. This method is thread safe if  BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.InsertUniquePoint(System.Double[],System.Int32@)">
            <summary>
                <para>Determine whether point given by x[3] has been inserted into points list. Return 0 if point was already in the list, otherwise return 1. If the point was not in the list, it will be ADDED.  In either case, the id of the point (newly inserted or not) is returned in the ptId argument. Note this combines the functionality of IsInsertedPoint() followed by a call to InsertNextPoint(). This method is not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.IsInsertedPoint(System.Double[])">
            <summary>
                <para>Determine whether point given by x[3] has been inserted into points list. Return id of previously inserted point if this is true, otherwise return -1. This method is thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.IsInsertedPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Determine whether point given by x[3] has been inserted into points list. Return id of previously inserted point if this is true, otherwise return -1. This method is thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.InsertNextPoint(System.Double[])">
            <summary>
                <para>Incrementally insert a point into search structure. The method returns the insertion location (i.e., point id). You should use the method  IsInsertedPoint() to see whether this point has already been inserted (that is, if you desire to prevent duplicate points). Before using this method you must make sure that newPts have been supplied, the bounds has been set properly, and that divs are  properly set. (See InitPointInsertion().) Not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.InsertPoint(System.Int32,System.Double[])">
            <summary>
                <para>Incrementally insert a point into search structure with a particular index value. You should use the method IsInsertedPoint() to see whether  this point has already been inserted (that is, if you desire to prevent duplicate points). Before using this method you must make sure that  newPts have been supplied, the bounds has been set properly, and that  divs are properly set. (See InitPointInsertion().) Not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.InitPointInsertion(vtk.vtkPoints,System.Double[],System.Int32)">
            <summary>
                <para>Initialize the point insertion process. The newPts is an object representing point coordinates into which incremental insertion methods place their data. Bounds are the box that the points lie in. Not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.InitPointInsertion(vtk.vtkPoints,System.Double[])">
            <summary>
                <para>Initialize the point insertion process. The newPts is an object representing point coordinates into which incremental insertion methods place their data. Bounds are the box that the points lie in. Not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindClosestPointWithinRadius(System.Double,System.Double[],System.Double,System.Double@)">
            <summary>
                <para>Given a position x and a radius r, return the id of the point  closest to the point in that radius. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first. dist2 returns the squared distance to the point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindClosestPointWithinRadius(System.Double,System.Double[],System.Double@)">
            <summary>
                <para>Given a position x and a radius r, return the id of the point  closest to the point in that radius. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first. dist2 returns the squared distance to the point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindClosestPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Given a position x, return the id of the point closest to it. Alternative method requires separate x-y-z values. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.FindClosestPoint(System.Double[])">
            <summary>
                <para>Given a position x, return the id of the point closest to it. Alternative method requires separate x-y-z values. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.GetNumberOfPointsPerBucket">
            <summary>
                <para>Specify the average number of points in each bucket.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.GetNumberOfPointsPerBucketMaxValue">
            <summary>
                <para>Specify the average number of points in each bucket.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.GetNumberOfPointsPerBucketMinValue">
            <summary>
                <para>Specify the average number of points in each bucket.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.SetNumberOfPointsPerBucket(System.Int32)">
            <summary>
                <para>Specify the average number of points in each bucket.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.GetDivisions">
            <summary>
                <para>Set the number of divisions in x-y-z directions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.SetDivisions(System.Int32[])">
            <summary>
                <para>Set the number of divisions in x-y-z directions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointLocator.SetDivisions(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the number of divisions in x-y-z directions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLocator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLocator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLocator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLocator.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Handle the PointSet &lt;-&gt; Locator loop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Handle the PointSet &lt;-&gt; Locator loop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetBuildTime">
            <summary>
                <para>Return the time of the last data structure build.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GenerateRepresentation(System.Int32,vtk.vtkPolyData)">
            <summary>
                <para>Method to build a representation at a particular level. Note that the  method GetLevel() returns the maximum number of levels available for the tree. You must provide a vtkPolyData object into which to place the  data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.FreeSearchStructure">
            <summary>
                <para>Free the memory required for the spatial data structure.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.BuildLocator">
            <summary>
                <para>Build the locator from the input dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.Initialize">
            <summary>
                <para>Initialize locator. Frees memory and resets object as appropriate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.Update">
            <summary>
                <para>Cause the locator to rebuild itself if it or its input dataset has  changed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.RetainCellListsOff">
            <summary>
                <para>Boolean controls whether to maintain list of entities in each bucket. Normally the lists are maintained, but if the locator is being used as a geometry simplification technique, there is no need to keep them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.RetainCellListsOn">
            <summary>
                <para>Boolean controls whether to maintain list of entities in each bucket. Normally the lists are maintained, but if the locator is being used as a geometry simplification technique, there is no need to keep them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetRetainCellLists">
            <summary>
                <para>Boolean controls whether to maintain list of entities in each bucket. Normally the lists are maintained, but if the locator is being used as a geometry simplification technique, there is no need to keep them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.SetRetainCellLists(System.Int32)">
            <summary>
                <para>Boolean controls whether to maintain list of entities in each bucket. Normally the lists are maintained, but if the locator is being used as a geometry simplification technique, there is no need to keep them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetTolerance">
            <summary>
                <para>Specify absolute tolerance (in world coordinates) for performing geometric operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetToleranceMaxValue">
            <summary>
                <para>Specify absolute tolerance (in world coordinates) for performing geometric operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetToleranceMinValue">
            <summary>
                <para>Specify absolute tolerance (in world coordinates) for performing geometric operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.SetTolerance(System.Double)">
            <summary>
                <para>Specify absolute tolerance (in world coordinates) for performing geometric operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.AutomaticOff">
            <summary>
                <para>Boolean controls whether locator depth/resolution of locator is computed automatically from average number of entities in bucket. If not set, there will be an explicit method to control the construction of the locator (found in the subclass).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.AutomaticOn">
            <summary>
                <para>Boolean controls whether locator depth/resolution of locator is computed automatically from average number of entities in bucket. If not set, there will be an explicit method to control the construction of the locator (found in the subclass).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetAutomatic">
            <summary>
                <para>Boolean controls whether locator depth/resolution of locator is computed automatically from average number of entities in bucket. If not set, there will be an explicit method to control the construction of the locator (found in the subclass).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.SetAutomatic(System.Int32)">
            <summary>
                <para>Boolean controls whether locator depth/resolution of locator is computed automatically from average number of entities in bucket. If not set, there will be an explicit method to control the construction of the locator (found in the subclass).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetLevel">
            <summary>
                <para>Get the level of the locator (determined automatically if Automatic is  true). The value of this ivar may change each time the locator is built.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetMaxLevel">
            <summary>
                <para>Set the maximum allowable level for the tree. If the Automatic ivar is  off, this will be the target depth of the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetMaxLevelMaxValue">
            <summary>
                <para>Set the maximum allowable level for the tree. If the Automatic ivar is  off, this will be the target depth of the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetMaxLevelMinValue">
            <summary>
                <para>Set the maximum allowable level for the tree. If the Automatic ivar is  off, this will be the target depth of the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.SetMaxLevel(System.Int32)">
            <summary>
                <para>Set the maximum allowable level for the tree. If the Automatic ivar is  off, this will be the target depth of the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.GetDataSet">
            <summary>
                <para>Build the locator from the points/cells defining this dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLocator.SetDataSet(vtk.vtkDataSet)">
            <summary>
                <para>Build the locator from the points/cells defining this dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericCell.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCell.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToQuadraticWedge">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToQuadraticHexahedron">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToQuadraticTetra">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToQuadraticQuad">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToQuadraticTriangle">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToQuadraticEdge">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToConvexPointSet">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToHexagonalPrism">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToPentagonalPrism">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToPyramid">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToWedge">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToHexahedron">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToVoxel">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToTetra">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToQuad">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToPixel">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToPolygon">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToTriangleStrip">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToTriangle">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToPolyLine">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToLine">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToPolyVertex">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToVertex">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellTypeToEmptyCell">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.SetCellType(System.Int32)">
            <summary>
                <para>This method is used to support the vtkDataSet::GetCell(vtkGenericCell *) method. It allows vtkGenericCell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.IsPrimaryCell">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.GetParametricCenter(System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.GetFace(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.GetEdge(System.Int32)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.GetNumberOfFaces">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.GetNumberOfEdges">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.Initialize">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.RequiresInitialization">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.IsLinear">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.GetCellDimension">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.GetCellType">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.DeepCopy(vtk.vtkCell)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericCell.ShallowCopy(vtk.vtkCell)">
            <summary>
                <para>See the vtkCell API for descriptions of these methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetActualMemorySize">
            <summary>
                <para>Return the memory in kilobytes consumed by this cell array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The  information returned is valid only after the pipeline has  been updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.Squeeze">
            <summary>
                <para>Return the memory in kilobytes consumed by this cell array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The  information returned is valid only after the pipeline has  been updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.Reset">
            <summary>
                <para>Reuse list. Reset to initial condition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetData">
            <summary>
                <para>Reuse list. Reset to initial condition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.DeepCopy(vtk.vtkCellArray)">
            <summary>
                <para>Perform a deep copy (no reference counting) of the given cell array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.SetCells(System.Int32,vtk.vtkIdTypeArray)">
            <summary>
                <para>Define multiple cells by providing a connectivity list. The list is in the form (npts,p0,p1,...p(npts-1), repeated for each cell). Be careful using this method because it discards the old cells, and anything referring these cells becomes invalid (for example, if BuildCells() has been called see vtkPolyData).  The traversal location is reset to the beginning of the list; the insertion location is set to the end of the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetMaxCellSize">
            <summary>
                <para>Returns the size of the largest cell. The size is the number of points defining the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.ReplaceCell(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Replace the point ids of the cell with a different list of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.ReverseCell(System.Int32)">
            <summary>
                <para>Special method inverts ordering of current cell. Must be called carefully or the cell topology may be corrupted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetTraversalLocation(System.Int32)">
            <summary>
                <para>Special method inverts ordering of current cell. Must be called carefully or the cell topology may be corrupted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.SetTraversalLocation(System.Int32)">
            <summary>
                <para>Computes the current traversal location within the internal array. Used  in conjunction with GetCell(int loc,...).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetTraversalLocation">
            <summary>
                <para>Get/Set the current traversal location.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetInsertLocation(System.Int32)">
            <summary>
                <para>Computes the current insertion location within the internal array.  Used in conjunction with GetCell(int loc,...).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.UpdateCellCount(System.Int32)">
            <summary>
                <para>Used in conjunction with InsertNextCell(int npts) and InsertCellPoint() to update the number of points defining the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.InsertCellPoint(System.Int32)">
            <summary>
                <para>Used in conjunction with InsertNextCell(int npts) to add another point to the list of cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.InsertNextCell(System.Int32)">
            <summary>
                <para>Create cells by specifying count, and then adding points one at a time using method InsertCellPoint(). If you don't know the count initially, use the method UpdateCellCount() to complete the cell. Return the cell id of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.InsertNextCell(vtk.vtkIdList)">
            <summary>
                <para>Create a cell by specifying a list of point ids. Return the cell id of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.InsertNextCell(System.Int32,System.Int32[])">
            <summary>
                <para>Create a cell by specifying the number of points and an array of point id's.  Return the cell id of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.InsertNextCell(vtk.vtkCell)">
            <summary>
                <para>Insert a cell object. Return the cell id of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetNumberOfConnectivityEntries">
            <summary>
                <para>Internal method used to retrieve a cell given an offset into the internal array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetSize">
            <summary>
                <para>Get the total number of entries (i.e., data values) in the connectivity  array. This may be much less than the allocated size (i.e., return value  from GetSize().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.InitTraversal">
            <summary>
                <para>A cell traversal methods that is more efficient than vtkDataSet traversal methods.  InitTraversal() initializes the traversal of the list of cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.EstimateSize(System.Int32,System.Int32)">
            <summary>
                <para>A cell traversal methods that is more efficient than vtkDataSet traversal methods.  InitTraversal() initializes the traversal of the list of cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.SetNumberOfCells(System.Int32)">
            <summary>
                <para>Set the number of cells in the array. DO NOT do any kind of allocation, advanced use only.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.GetNumberOfCells">
            <summary>
                <para>Get the number of cells in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.Initialize">
            <summary>
                <para>Get the number of cells in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellArray.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Free any memory and reset to an empty state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCell.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCell.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCell.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCell.IsPrimaryCell">
            <summary>
                <para>Return a contiguous array of parametric coordinates of the points defining this cell. In other words, (px,py,pz, px,py,pz, etc..)  The coordinates are ordered consistent with the definition of the point ordering for the cell. This method returns a non-NULL pointer when the cell is a primary type (i.e., IsPrimaryCell() is true). Note that 3D parametric coordinates are returned no matter what the topological dimension of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetParametricDistance(System.Double[])">
            <summary>
                <para>Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned. This is used during picking to get the correct cell picked. (The tolerance will occasionally allow cells to be picked who are not really intersected "inside" the cell.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetParametricCenter(System.Double[])">
            <summary>
                <para>Return center of the cell in parametric coordinates.  Note that the parametric center is not always located at (0.5,0.5,0.5). The return value is the subId that the center is in (if a composite cell). If you want the center in x-y-z space, invoke the EvaluateLocation() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetLength2">
            <summary>
                <para>Compute Length squared of cell (i.e., bounding box diagonal squared).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetBounds">
            <summary>
                <para>Compute cell bounding box (xmin,xmax,ymin,ymax,zmin,zmax). Return pointer to array of six double values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetBounds(System.Double[])">
            <summary>
                <para>Compute cell bounding box (xmin,xmax,ymin,ymax,zmin,zmax). Copy result into user provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.Derivatives(System.Int32,System.Double[],System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>Compute derivatives given cell subId and parametric coordinates. The values array is a series of data value(s) at the cell points. There is a one-to-one correspondence between cell point and data value(s). Dim is the number of data values per cell point. Derivs are derivatives in the x-y-z coordinate directions for each data value. Thus, if computing derivatives for a scalar function in a hexahedron, dim=1, 8 values are supplied, and 3 deriv values are returned (i.e., derivatives in x-y-z directions). On the other hand, if computing derivatives of velocity (vx,vy,vz) dim=3, 24 values are supplied ((vx,vy,vz)1, (vx,vy,vz)2, ....()8), and 9 deriv values are returned ((d(vx)/dx),(d(vx)/dy),(d(vx)/dz), (d(vy)/dx),(d(vy)/dy), (d(vy)/dz), (d(vz)/dx),(d(vz)/dy),(d(vz)/dz)).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.Triangulate(System.Int32,vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>Generate simplices of proper dimension. If cell is 3D, tetrahedron are  generated; if 2D triangles; if 1D lines; if 0D points. The form of the output is a sequence of points, each n+1 points (where n is topological  cell dimension) defining a simplex. The index is a parameter that controls which triangulation to use (if more than one is possible). If numerical degeneracy encountered, 0 is returned, otherwise 1 is returned. This method does not insert new points: all the points that define the simplices are the points that define the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Intersect with a ray. Return parametric coordinates (both line and cell) and global intersection coordinates, given ray definition and tolerance.  The method returns non-zero value if intersection occurs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.Clip(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData,System.Int32)">
            <summary>
                <para>Cut (or clip) the cell based on the input cellScalars and the specified value. The output of the clip operation will be one or more cells of the same topological dimension as the original cell.  The flag insideOut controls what part of the cell is considered inside -  normally cell points whose scalar value is greater than "value" are considered inside. If insideOut is on, this is reversed. Also, if the  output cell data is non-NULL, the cell data from the clipped cell is  passed to the generated contouring primitives. (Note: the CopyAllocate()  method must be invoked on both the output cell and point data. The cellId refers to the cell from which the cell data is copied.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.Contour(System.Double,vtk.vtkDataArray,vtk.vtkPointLocator,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkCellArray,vtk.vtkPointData,vtk.vtkPointData,vtk.vtkCellData,System.Int32,vtk.vtkCellData)">
            <summary>
                <para>Generate contouring primitives. The scalar list cellScalars are scalar values at each cell point. The point locator is essentially a  points list that merges points as they are inserted (i.e., prevents  duplicates). Contouring primitives can be vertices, lines, or polygons. It is possible to interpolate point data along the edge by providing input and output point data - if outPd is NULL, then no interpolation is performed. Also, if the output cell data is non-NULL, the cell data from the contoured cell is passed to the generated contouring primitives. (Note: the CopyAllocate() method must be invoked on both the output cell and point data. The  cellId refers to the cell from which the cell data is copied.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.EvaluateLocation(System.Int32@,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Determine global coordinate (x[3]) from subId and parametric coordinates. Also returns interpolation weights. (The number of weights is equal to the number of points in the cell.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.EvaluatePosition(System.Double[],System.Double[],System.Int32@,System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>Given a point x[3] return inside(=1) or outside(=0) cell; evaluate parametric coordinates, sub-cell id (!=0 only if cell is composite), distance squared of point x[3] to cell (in particular, the sub-cell indicated), closest point on cell to x[3] (unless closestPoint is null, in which case, the closest point and dist2 are not found), and interpolation weights in cell. (The number of weights is equal to the number of points defining the cell). Note: on rare occasions a -1 is returned from the method. This means that numerical error has occurred and all data returned from this method should be ignored. Also, inside/outside is determine parametrically. That is, a point is inside if it satisfies parametric limits. This can cause problems for cells of topological dimension 2 or less, since a point in 3D can project onto the cell within parametric limits but be "far" from the cell.  Thus the value dist2 may be checked to determine true in/out.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.CellBoundary(System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>Given parametric coordinates of a point, return the closest cell boundary, and whether the point is inside or outside of the cell. The cell boundary is defined by a list of points (pts) that specify a face (3D cell), edge (2D cell), or vertex (1D cell). If the return value of the method is != 0, then the point is inside the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetFace(System.Int32)">
            <summary>
                <para>Return the face cell from the faceId of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetEdge(System.Int32)">
            <summary>
                <para>Return the edge cell from the edgeId of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetPointId(System.Int32)">
            <summary>
                <para>Return the edge cell from the edgeId of the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetPointIds">
            <summary>
                <para>For cell point i, return the actual point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetNumberOfFaces">
            <summary>
                <para>Return the number of faces in the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetNumberOfEdges">
            <summary>
                <para>Return the number of edges in the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetNumberOfPoints">
            <summary>
                <para>Return the number of edges in the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetPoints">
            <summary>
                <para>Return the number of points in the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.IsExplicitCell">
            <summary>
                <para>Get the point coordinates for the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.Initialize">
            <summary>
                <para>Explicit cells require additional representational information beyond the usual cell type and connectivity list information. Most cells in VTK are implicit cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.RequiresInitialization">
            <summary>
                <para>Some cells require initialization prior to access. For example, they may have to triangulate themselves or set up internal data structures.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.IsLinear">
            <summary>
                <para>Some cells require initialization prior to access. For example, they may have to triangulate themselves or set up internal data structures.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetCellDimension">
            <summary>
                <para>Return the topological dimensional of the cell (0,1,2, or 3).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.GetCellType">
            <summary>
                <para>Return the type of cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.DeepCopy(vtk.vtkCell)">
            <summary>
                <para>Copy this cell by completely copying internal data structures. This is slower but safer than ShallowCopy().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.ShallowCopy(vtk.vtkCell)">
            <summary>
                <para>Copy this cell by reference counting the internal data structures.  This is safe if you want a "read-only" copy. If you modify the cell you might wish to use DeepCopy().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCell.Initialize(System.Int32,System.Int32[],vtk.vtkPoints)">
            <summary>
                <para>Initialize cell from outside with point ids and point coordinates specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyData.RemoveGhostCells(System.Int32)">
            <summary>
                <para>This method will remove any cell that has a ghost level array value greater or equal to level.  It does not remove unused points (yet).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetActualMemorySize">
            <summary>
                <para>Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetGhostLevel">
            <summary>
                <para>Get the ghost level.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetNumberOfPieces">
            <summary>
                <para>Get the piece and the number of pieces. Similar to extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetPiece">
            <summary>
                <para>Get the piece and the number of pieces. Similar to extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetUpdateExtent(System.Int32[])">
            <summary>
                <para>We need this here to avoid hiding superclass method</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetUpdateExtent(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                <para>We need this here to avoid hiding superclass method</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetUpdateExtent(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                <para>For streaming.  User/next filter specifies which piece they want updated. The source of this poly data has to return exactly this piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.Initialize">
            <summary>
                <para>Restore object to initial state. Release memory back to system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.ResizeCellList(System.Int32,System.Int32)">
            <summary>
                <para>Resize the list of cells using a particular point. (This operator assumes that BuildLinks() has been called.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.AddReferenceToCell(System.Int32,System.Int32)">
            <summary>
                <para>Add a reference to a cell in a particular point's link list. (You may also consider using AddCellReference() to add the references from all the  cell's points to the cell.) This operator does not realloc memory; use the operator ResizeCellList() to do this if necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.RemoveReferenceToCell(System.Int32,System.Int32)">
            <summary>
                <para>Remove a reference to a cell in a particular point's link list. You may also consider using RemoveCellReference() to remove the references from all the cell's points to the cell. This operator does not reallocate memory; use the operator ResizeCellList() to do this if necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.AddCellReference(System.Int32)">
            <summary>
                <para>Add references to cell in cell structure. This means the links from the cell's points to the cell are modified. Memory is not extended. Use the method ResizeCellList() to resize the link list from a point to its using  cells. (This operator assumes BuildLinks() has been called.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.RemoveCellReference(System.Int32)">
            <summary>
                <para>Remove all references to cell in cell structure. This means the links from the cell's points to the cell are deleted. Memory is not reclaimed. Use the method ResizeCellList() to resize the link list from a point to its using  cells. (This operator assumes BuildLinks() has been called.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.ReplaceLinkedCell(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Replace one cell with another in cell structure. This operator updates the connectivity list and the point's link list. It does not delete references to the old cell in the point's link list. Use the operator  RemoveCellReference() to delete all references from points to (old) cell. You may also want to consider using the operator ResizeCellList() if the  link list is changing size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.InsertNextLinkedCell(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Add a new cell to the cell data structure (after cell pointers have been built). This method adds the cell and then updates the links from the points to the cells. (Memory is allocated as necessary.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.InsertNextLinkedPoint(System.Double[],System.Int32)">
            <summary>
                <para>Add a point to the cell data structure (after cell pointers have been built). This method adds the point and then allocates memory for the links to the cells.  (To use this method, make sure points are available and BuildLinks() has been invoked.) Of the two methods below, one inserts a point coordinate and the other just makes room for cell links.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.InsertNextLinkedPoint(System.Int32)">
            <summary>
                <para>Add a point to the cell data structure (after cell pointers have been built). This method adds the point and then allocates memory for the links to the cells.  (To use this method, make sure points are available and BuildLinks() has been invoked.) Of the two methods below, one inserts a point coordinate and the other just makes room for cell links.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.DeleteCell(System.Int32)">
            <summary>
                <para>Mark a point/cell as deleted from this vtkPolyData.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.DeletePoint(System.Int32)">
            <summary>
                <para>Mark a point/cell as deleted from this vtkPolyData.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.ReverseCell(System.Int32)">
            <summary>
                <para>Reverse the order of point ids defining the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.ReplaceCellPoint(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Replace a point in the cell connectivity list with a different point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.ReplaceCell(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Replace the points defining cell "cellId" with a new set of points. This operator is (typically) used when links from points to cells have not been  built (i.e., BuildLinks() has not been executed). Use the operator  ReplaceLinkedCell() to replace a cell when cell structure has been built.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.IsPointUsedByCell(System.Int32,System.Int32)">
            <summary>
                <para>Determine whether a point is used by a particular cell. If it is, return non-zero. Make sure BuildCells() has been called first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.IsEdge(System.Int32,System.Int32)">
            <summary>
                <para>Determine whether two points form an edge. If they do, return non-zero. By definition PolyVertex and PolyLine have no edges since 1-dimensional  edges are only found on cells 2D and higher.  Edges are defined as 1-D boundary entities to cells. Make sure BuildLinks() has been called first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.IsTriangle(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Given three vertices, determine whether it's a triangle. Make sure  BuildLinks() has been called first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetCellEdgeNeighbors(System.Int32,System.Int32,System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Get the neighbors at an edge. More efficient than the general  GetCellNeighbors(). Assumes links have been built (with BuildLinks()),  and looks specifically for edge neighbors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.DeleteLinks">
            <summary>
                <para>Release the upward links from point to cells that use each point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.DeleteCells">
            <summary>
                <para>Release data structure that allows random access of the cells. This must be done before a 2nd call to BuildLinks(). DeleteCells implicitly deletes the links as well since they are no longer valid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.BuildLinks(System.Int32)">
            <summary>
                <para>Create upward links from points to cells that use each point. Enables topologically complex queries. Normally the links array is allocated based on the number of points in the vtkPolyData. The optional  initialSize parameter can be used to allocate a larger size initially.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.BuildCells">
            <summary>
                <para>Create data structure that allows random access of cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.Reset">
            <summary>
                <para>Begin inserting data all over again. Memory is not freed but otherwise objects are returned to their initial state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.InsertNextCell(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Insert a cell of type VTK_VERTEX, VTK_POLY_VERTEX, VTK_LINE, VTK_POLY_LINE, VTK_TRIANGLE, VTK_QUAD, VTK_POLYGON, or VTK_TRIANGLE_STRIP.  Make sure that the PolyData::Allocate() function has been called first or that vertex, line, polygon, and triangle strip arrays have been supplied. Note: will also insert VTK_PIXEL, but converts it to VTK_QUAD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.InsertNextCell(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Insert a cell of type VTK_VERTEX, VTK_POLY_VERTEX, VTK_LINE, VTK_POLY_LINE, VTK_TRIANGLE, VTK_QUAD, VTK_POLYGON, or VTK_TRIANGLE_STRIP.  Make sure that the PolyData::Allocate() function has been called first or that vertex, line, polygon, and triangle strip arrays have been supplied. Note: will also insert VTK_PIXEL, but converts it to VTK_QUAD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.Allocate(vtk.vtkPolyData,System.Int32,System.Int32)">
            <summary>
                <para>Similar to the method above, this method allocates initial storage for vertex, line, polygon, and triangle strip arrays. It does this more intelligently, examining the supplied inPolyData to determine whether to allocate the verts, lines, polys, and strips arrays.  (These arrays are allocated only if there is data in the corresponding arrays in the inPolyData.)  Caution: if the inPolyData has no verts, and after allocating with this method an PolyData::InsertNextCell() is invoked where a vertex is inserted, bad things will happen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Method allocates initial storage for vertex, line, polygon, and  triangle strip arrays. Use this method before the method  PolyData::InsertNextCell(). (Or, provide vertex, line, polygon, and triangle strip cell arrays.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetNumberOfStrips">
            <summary>
                <para>Return the number of primitives of a particular type held..</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetNumberOfPolys">
            <summary>
                <para>Return the number of primitives of a particular type held..</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetNumberOfLines">
            <summary>
                <para>Return the number of primitives of a particular type held..</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetNumberOfVerts">
            <summary>
                <para>Return the number of primitives of a particular type held..</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetStrips">
            <summary>
                <para>Get the cell array defining triangle strips. If there are no triangle strips, an empty array will be returned (convenience to  simplify traversal).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.SetStrips(vtk.vtkCellArray)">
            <summary>
                <para>Set the cell array defining triangle strips.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetPolys">
            <summary>
                <para>Get the cell array defining polygons. If there are no polygons, an empty array will be returned (convenience to simplify traversal).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.SetPolys(vtk.vtkCellArray)">
            <summary>
                <para>Set the cell array defining polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetLines">
            <summary>
                <para>Get the cell array defining lines. If there are no lines, an empty array will be returned (convenience to simplify traversal).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.SetLines(vtk.vtkCellArray)">
            <summary>
                <para>Set the cell array defining lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetVerts">
            <summary>
                <para>Get the cell array defining vertices. If there are no vertices, an empty array will be returned (convenience to simplify traversal).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.SetVerts(vtk.vtkCellArray)">
            <summary>
                <para>Set the cell array defining vertices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetMaxCellSize">
            <summary>
                <para>Return the maximum cell size in this poly data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.Squeeze">
            <summary>
                <para>Recover extra allocated memory when creating data whose initial size is unknown. Examples include using the InsertNextCell() method, or when using the CellArray::EstimateSize() method to create vertices, lines, polygons, or triangle strips.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.ComputeBounds">
            <summary>
                <para>Compute the (X, Y, Z)  bounds of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetPointCells(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Efficient method to obtain cells using a particular point. Make sure that routine BuildLinks() has been called.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetCellPoints(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Copy a cells point ids into list provided. (Less efficient.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.CopyCells(vtk.vtkPolyData,vtk.vtkIdList,vtk.vtkPointLocator)">
            <summary>
                <para>Copy cells listed in idList from pd, including points, point data, and cell data.  This method assumes that point and cell data have been allocated.  If you pass in a point locator, then the points won't be duplicated in the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetCellNeighbors(System.Int32,vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>Standard vtkDataSet interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetCellBounds(System.Int32,System.Double[])">
            <summary>
                <para>Standard vtkDataSet interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetCellType(System.Int32)">
            <summary>
                <para>Standard vtkDataSet interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetCell(System.Int32,vtk.vtkGenericCell)">
            <summary>
                <para>Standard vtkDataSet interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetCell(System.Int32)">
            <summary>
                <para>Standard vtkDataSet interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetNumberOfCells">
            <summary>
                <para>Standard vtkDataSet interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.CopyStructure(vtk.vtkDataSet)">
            <summary>
                <para>Copy the geometric and topological structure of an input poly data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyData.GetDataObjectType">
            <summary>
                <para>Copy the geometric and topological structure of an input poly data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPointSet.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.GetActualMemorySize">
            <summary>
                <para>Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.GetPoints">
            <summary>
                <para>Specify point array to define point coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.SetPoints(vtk.vtkPoints)">
            <summary>
                <para>Specify point array to define point coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.Squeeze">
            <summary>
                <para>Reclaim any unused memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.ComputeBounds">
            <summary>
                <para>Compute the (X, Y, Z)  bounds of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.GetMTime">
            <summary>
                <para>Get MTime which also considers its vtkPoints MTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.FindCell(System.Double[],vtk.vtkCell,vtk.vtkGenericCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>See vtkDataSet for additional information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.FindCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>See vtkDataSet for additional information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.FindPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>See vtkDataSet for additional information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.FindPoint(System.Double[])">
            <summary>
                <para>See vtkDataSet for additional information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.GetPoint(System.Int32,System.Double[])">
            <summary>
                <para>See vtkDataSet for additional information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.GetPoint(System.Int32)">
            <summary>
                <para>See vtkDataSet for additional information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.GetNumberOfPoints">
            <summary>
                <para>See vtkDataSet for additional information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.CopyStructure(vtk.vtkDataSet)">
            <summary>
                <para>Copy the geometric structure of an input point set object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSet.Initialize">
            <summary>
                <para>Reset to an empty state and free any memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSet.GenerateGhostLevelArray">
            <summary>
                <para>Normally called by pipeline executives or algoritgms only. This method computes the ghost arrays for a given dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.CheckAttributes">
            <summary>
                <para>This method checks to see if the cell and point attributes match the geometry.  Many filters will crash if the number of  tupples in an array is less than the number of points/cells. This method returns 1 if there is a mismatch,  and 0 if everything is ok.  It prints an error if an array is too short, and a warning if an array is too long.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetDataObjectType">
            <summary>
                <para>Shallow and Deep copy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetActualMemorySize">
            <summary>
                <para>Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetMaxCellSize">
            <summary>
                <para>Convenience method returns largest cell size in dataset. This is generally used to allocate memory for supporting data structures. THIS METHOD IS THREAD SAFE</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetScalarRange">
            <summary>
                <para>Convenience method to get the range of the scalar data (if there is any  scalar data).  THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetScalarRange(System.Double[])">
            <summary>
                <para>Convenience method to get the range of the scalar data (if there is any  scalar data). Returns the (min/max) range of combined point and cell data. If there are no point or cell scalars the method will return (0,1). Note: Update needs to be called to create the scalars. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.Initialize">
            <summary>
                <para>Restore data object to initial state, THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetLength">
            <summary>
                <para>Return the length of the diagonal of the bounding box. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCenter(System.Double[])">
            <summary>
                <para>Get the center of the bounding box. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCenter">
            <summary>
                <para>Get the center of the bounding box. THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetBounds(System.Double[])">
            <summary>
                <para>Return a pointer to the geometry bounding box in the form (xmin,xmax, ymin,ymax, zmin,zmax). THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetBounds">
            <summary>
                <para>Return a pointer to the geometry bounding box in the form (xmin,xmax, ymin,ymax, zmin,zmax). THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.ComputeBounds">
            <summary>
                <para>Compute the data bounding box from data points. THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.Squeeze">
            <summary>
                <para>Reclaim any extra memory used to store data. THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetPointData">
            <summary>
                <para>return pointer to this dataset's point data THIS METHOD IS THREAD SAFE</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCellData">
            <summary>
                <para>return pointer to this dataset's point data THIS METHOD IS THREAD SAFE</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetMTime">
            <summary>
                <para>Datasets are composite objects and need to check each part for MTime THIS METHOD IS THREAD SAFE</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.FindAndGetCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Locate the cell that contains a point and return the cell. Also returns the subcell id, parametric coordinates and weights for subsequent interpolation. This method combines the derived class methods int FindCell and vtkCell *GetCell. Derived classes may provide a more  efficient implementation. See for example vtkStructuredPoints. THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.FindCell(System.Double[],vtk.vtkCell,vtk.vtkGenericCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>This is a version of the above method that can be used with  multithreaded applications. A vtkGenericCell must be passed in to be used in internal calls that might be made to GetCell() THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.FindCell(System.Double[],vtk.vtkCell,System.Int32,System.Double,System.Int32@,System.Double[],System.Double[])">
            <summary>
                <para>Locate cell based on global coordinate x and tolerance squared. If cell and cellId is non-NULL, then search starts from this cell and looks at immediate neighbors.  Returns cellId &gt;= 0 if inside, &lt; 0 otherwise.  The parametric coordinates are provided in pcoords[3]. The interpolation weights are returned in weights[]. (The number of weights is equal to the number of points in the found cell). Tolerance is used to control how close the point is to be considered "in" the cell. THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.FindPoint(System.Double[])">
            <summary>
                <para>Locate the closest point to the global coordinate x. Return the point id. If point id &lt; 0; then no point found. (This may arise when point is outside of dataset.) THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.FindPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Locate the closest point to the global coordinate x. Return the point id. If point id &lt; 0; then no point found. (This may arise when point is outside of dataset.) THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCellNeighbors(System.Int32,vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>Topological inquiry to get all cells using list of points exclusive of cell specified (e.g., cellId). Note that the list consists of only cells that use ALL the points provided. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetPointCells(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Topological inquiry to get cells using point. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCellPoints(System.Int32,vtk.vtkIdList)">
            <summary>
                <para>Topological inquiry to get points defining cell. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCellTypes(vtk.vtkCellTypes)">
            <summary>
                <para>Get a list of types of cells in a dataset. The list consists of an array of types (not necessarily in any order), with a single entry per type. For example a dataset 5 triangles, 3 lines, and 100 hexahedra would result a list of three entries, corresponding to the types VTK_TRIANGLE, VTK_LINE, and VTK_HEXAHEDRON. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCellType(System.Int32)">
            <summary>
                <para>Get type of cell with cellId such that: 0 &lt;= cellId &lt; NumberOfCells. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCellBounds(System.Int32,System.Double[])">
            <summary>
                <para>Get the bounds of the cell with cellId such that:     0 &lt;= cellId &lt; NumberOfCells. A subclass may be able to determine the bounds of cell without using an expensive GetCell() method. A default implementation is provided that actually uses a GetCell() call.  This is to ensure the method is available to all datasets.  Subclasses should override this method to provide an efficient implementation. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCell(System.Int32,vtk.vtkGenericCell)">
            <summary>
                <para>Get cell with cellId such that: 0 &lt;= cellId &lt; NumberOfCells.  This is a thread-safe alternative to the previous GetCell() method. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetCell(System.Int32)">
            <summary>
                <para>Get cell with cellId such that: 0 &lt;= cellId &lt; NumberOfCells. THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetPoint(System.Int32,System.Double[])">
            <summary>
                <para>Copy point coordinates into user provided array x[3] for specified point id. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetPoint(System.Int32)">
            <summary>
                <para>Get point coordinates with ptId such that: 0 &lt;= ptId &lt; NumberOfPoints. THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetNumberOfCells">
            <summary>
                <para>Determine the number of cells composing the dataset. THIS METHOD IS THREAD SAFE</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.GetNumberOfPoints">
            <summary>
                <para>Determine the number of points composing the dataset. THIS METHOD IS THREAD SAFE</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSet.CopyStructure(vtk.vtkDataSet)">
            <summary>
                <para>Copy the geometric and topological structure of an object. Note that the invoking object and the object pointed to by the parameter ds must be of the same type. THIS METHOD IS NOT THREAD SAFE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataObject.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataObject.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataObject.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetAssociationTypeAsString(System.Int32)">
            <summary>
                <para>Given an integer association type, this static method returns a string type for the attribute (i.e. type = 0: returns "Points").</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.Crop">
            <summary>
                <para>This method crops the data object (if necesary) so that the extent matches the update extent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetExtentType">
            <summary>
                <para>The ExtentType will be left as VTK_PIECES_EXTENT for data objects  such as vtkPolyData and vtkUnstructuredGrid. The ExtentType will be  changed to VTK_3D_EXTENT for data objects with 3D structure such as  vtkImageData (and its subclass vtkStructuredPoints), vtkRectilinearGrid, and vtkStructuredGrid. The default is the have an extent in pieces, with only one piece (no streaming possible).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetExtentTranslator">
            <summary>
                <para>An object that will translate pieces into structured extents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetExtentTranslator(vtk.vtkExtentTranslator)">
            <summary>
                <para>An object that will translate pieces into structured extents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.DeepCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.  These copy the data, but not any of the  pipeline connections.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.ShallowCopy(vtk.vtkDataObject)">
            <summary>
                <para>Shallow and Deep copy.  These copy the data, but not any of the  pipeline connections.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.PrepareForNewData">
            <summary>
                <para>make the output data ready for new data to be inserted. For most  objects we just call Initialize. But for vtkImageData we leave the old data in case the memory can be reused.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.DataHasBeenGenerated">
            <summary>
                <para>This method is called by the source when it executes to generate data. It is sort of the opposite of ReleaseData. It sets the DataReleased flag to 0, and sets a new UpdateTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetPointDataActiveScalarInfo(vtk.vtkInformation,System.Int32,System.Int32)">
            <summary>
                <para>Convenience version of previous method for use (primarily) by the Imaging filters. If arrayType or numComponents == -1, the value is not changed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetActiveAttributeInfo(vtk.vtkInformation,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the name, array type, number of components, and number of tuples within the passed information object for the active attribute of type attributeType (in specified association, FIELD_ASSOCIATION_POINTS or FIELD_ASSOCIATION_CELLS).  If there is not an active attribute of the specified type, an entry in the information object is created.  If arrayType, numComponents, or numTuples equal to -1, or name=NULL the  value is not changed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetActiveAttribute(vtk.vtkInformation,System.Int32,System.String,System.Int32)">
            <summary>
                <para>Set the named array to be the active field for the specified type (SCALARS, VECTORS, NORMALS, TCOORDS, or TENSORS) and association (FIELD_ASSOCIATION_POINTS or FIELD_ASSOCIATION_CELLS).  Returns the  active field information object and creates on entry if one not found.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.RemoveNamedFieldInformation(vtk.vtkInformation,System.Int32,System.String)">
            <summary>
                <para>Remove the info associated with an array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetNamedFieldInformation(vtk.vtkInformation,System.Int32,System.String)">
            <summary>
                <para>Return the information object within the input information object's field data corresponding to the specified association  (FIELD_ASSOCIATION_POINTS or FIELD_ASSOCIATION_CELLS) and name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetActiveFieldInformation(vtk.vtkInformation,System.Int32,System.Int32)">
            <summary>
                <para>Return the information object within the input information object's field data corresponding to the specified association  (FIELD_ASSOCIATION_POINTS or FIELD_ASSOCIATION_CELLS) and attribute (SCALARS, VECTORS, NORMALS, TCOORDS, or TENSORS)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.CopyInformationFromPipeline(vtk.vtkInformation)">
            <summary>
                <para>Copy information about this data object from the PipelineInformation to its own Information for the given request.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.CopyInformationToPipeline(vtk.vtkInformation,vtk.vtkInformation)">
            <summary>
                <para>Copy information about this data object to its PipelineInformation from its own Information for the given request.  If the second argument is not NULL then it is the pipeline information object for the input to this data object's producer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetMaximumNumberOfPieces">
            <summary>
                <para>Set/Get the maximum number of pieces that can be requested.   The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -1 indicates that there is no maximum.  A value of</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetMaximumNumberOfPieces(System.Int32)">
            <summary>
                <para>Set/Get the maximum number of pieces that can be requested.   The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -1 indicates that there is no maximum.  A value of</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetWholeBoundingBox(System.Double[])">
            <summary>
                <para>Set/Get the whole bounding box of this data object.   The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetWholeBoundingBox(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>Set/Get the whole bounding box of this data object.   The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetWholeBoundingBox(System.Double[])">
            <summary>
                <para>Set/Get the whole bounding box of this data object.   The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetWholeBoundingBox(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the whole bounding box of this data object.   The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetWholeExtent(System.Int32[])">
            <summary>
                <para>Set/Get the whole extent of this data object.   The whole extent is meta data for structured data sets. It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetWholeExtent(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                <para>Set/Get the whole extent of this data object.   The whole extent is meta data for structured data sets. It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetWholeExtent">
            <summary>
                <para>Set/Get the whole extent of this data object.   The whole extent is meta data for structured data sets. It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetWholeExtent(System.Int32[])">
            <summary>
                <para>Set/Get the whole extent of this data object.   The whole extent is meta data for structured data sets. It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetWholeExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the whole extent of this data object.   The whole extent is meta data for structured data sets. It gets set by the source during the update information call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.RequestExactExtentOff">
            <summary>
                <para>This request flag indicates whether the requester can handle  more data than requested.  Right now it is used in vtkImageData. Image filters can return more data than requested.  The the  consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself.  This functionality used to be in  ImageToStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.RequestExactExtentOn">
            <summary>
                <para>This request flag indicates whether the requester can handle  more data than requested.  Right now it is used in vtkImageData. Image filters can return more data than requested.  The the  consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself.  This functionality used to be in  ImageToStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetRequestExactExtent">
            <summary>
                <para>This request flag indicates whether the requester can handle  more data than requested.  Right now it is used in vtkImageData. Image filters can return more data than requested.  The the  consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself.  This functionality used to be in  ImageToStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetRequestExactExtent(System.Int32)">
            <summary>
                <para>This request flag indicates whether the requester can handle  more data than requested.  Right now it is used in vtkImageData. Image filters can return more data than requested.  The the  consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself.  This functionality used to be in  ImageToStructuredPoints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetUpdateGhostLevel">
            <summary>
                <para>Set / Get the update ghost level and the update number of ghost levels. Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetUpdateGhostLevel(System.Int32)">
            <summary>
                <para>Set / Get the update ghost level and the update number of ghost levels. Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetUpdateNumberOfPieces">
            <summary>
                <para>Set / Get the update piece and the update number of pieces. Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetUpdatePiece">
            <summary>
                <para>Set / Get the update piece and the update number of pieces. Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetUpdateNumberOfPieces(System.Int32)">
            <summary>
                <para>Set / Get the update piece and the update number of pieces. Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetUpdatePiece(System.Int32)">
            <summary>
                <para>Set / Get the update piece and the update number of pieces. Similar to update extent in 3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.CopyTypeSpecificInformation(vtk.vtkDataObject)">
            <summary>
                <para>By default, there is no type specific information</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.CopyInformation(vtk.vtkDataObject)">
            <summary>
                <para>Copy the generic information (WholeExtent ...)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetActualMemorySize">
            <summary>
                <para>Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetPipelineMTime">
            <summary>
                <para>Get the cumulative modified time of everything upstream.  Does not include the MTime of this object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetUpdateExtentToWholeExtent">
            <summary>
                <para>If the whole input extent is required to generate the requested output extent, this method can be called to set the input update extent to the whole input extent. This method assumes that the whole extent is known (that UpdateInformation has been called)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetUpdateTime">
            <summary>
                <para>Used by Threaded ports to determine if they should initiate an asynchronous update (still in development).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetDataObjectType">
            <summary>
                <para>Used by Threaded ports to determine if they should initiate an asynchronous update (still in development).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetUpdateExtent(System.Int32[])">
            <summary>
                <para>Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..),  then no data is requested, and the source will not execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetUpdateExtent(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                <para>Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..),  then no data is requested, and the source will not execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetUpdateExtent">
            <summary>
                <para>Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..),  then no data is requested, and the source will not execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetUpdateExtent(System.Int32[])">
            <summary>
                <para>Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..),  then no data is requested, and the source will not execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetUpdateExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..),  then no data is requested, and the source will not execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetUpdateExtent(System.Int32,System.Int32)">
            <summary>
                <para>Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..),  then no data is requested, and the source will not execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetUpdateExtent(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>A generic way of specifying an update extent.  Subclasses must decide what a piece is.  When the NumberOfPieces is zero, then no data is requested, and the source will not execute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetEstimatedMemorySize">
            <summary>
                <para>Get the estimated size of this data object itself. Should be called after UpdateInformation() and PropagateUpdateExtent() have both been  called. Should be overridden in a subclass - otherwise the default is to assume that this data object requires no memory. The size is returned in kilobytes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.UpdateData">
            <summary>
                <para>WARNING: INTERNAL METHOD - NOT FOR GENERAL USE.  THIS METHOD IS PART OF THE PIPELINE UPDATE FUNCTIONALITY. Propagate the update back up the pipeline, and perform the actual  work of updating on the way down. When the propagate arrives at a port, block and wait for the asynchronous update to finish on the other side. This propagation may early terminate based on the PipelineMTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.TriggerAsynchronousUpdate">
            <summary>
                <para>WARNING: INTERNAL METHOD - NOT FOR GENERAL USE.  THIS METHOD IS PART OF THE PIPELINE UPDATE FUNCTIONALITY. Propagate back up the pipeline for ports and trigger the update on the other side of the port to allow for asynchronous parallel processing in the pipeline. This propagation may early terminate based on the PipelineMTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.PropagateUpdateExtent">
            <summary>
                <para>WARNING: INTERNAL METHOD - NOT FOR GENERAL USE.  THIS METHOD IS PART OF THE PIPELINE UPDATE FUNCTIONALITY. The update extent for this object is propagated up the pipeline. This propagation may early terminate based on the PipelineMTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.UpdateInformation">
            <summary>
                <para>WARNING: INTERNAL METHOD - NOT FOR GENERAL USE.  THIS METHOD IS PART OF THE PIPELINE UPDATE FUNCTIONALITY. Update all the "easy to update" information about the object such as the extent which will be used to control the update. This propagates all the way up then back down the pipeline. As a by-product the PipelineMTime is updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.Update">
            <summary>
                <para>Provides opportunity for the data object to insure internal  consistency before access. Also causes owning source/filter  (if any) to update itself. The Update() method is composed of  UpdateInformation(), PropagateUpdateExtent(),  TriggerAsynchronousUpdate(), and UpdateData().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetFieldData">
            <summary>
                <para>Assign or retrieve field data to this data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetFieldData(vtk.vtkFieldData)">
            <summary>
                <para>Assign or retrieve field data to this data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetGlobalReleaseDataFlag">
            <summary>
                <para>Turn on/off flag to control whether every object releases its data after being used by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GlobalReleaseDataFlagOff">
            <summary>
                <para>Turn on/off flag to control whether every object releases its data after being used by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GlobalReleaseDataFlagOn">
            <summary>
                <para>Turn on/off flag to control whether every object releases its data after being used by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetGlobalReleaseDataFlag(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether every object releases its data after being used by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.ReleaseDataFlagOff">
            <summary>
                <para>Turn on/off flag to control whether this object's data is released after being used by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.ReleaseDataFlagOn">
            <summary>
                <para>Turn on/off flag to control whether this object's data is released after being used by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetReleaseDataFlag">
            <summary>
                <para>Turn on/off flag to control whether this object's data is released after being used by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetReleaseDataFlag(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether this object's data is released after being used by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetDataReleased">
            <summary>
                <para>Get the flag indicating the data has been released.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.ShouldIReleaseData">
            <summary>
                <para>Return flag indicating whether data should be released after use   by a filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.ReleaseData">
            <summary>
                <para>Release data back to system to conserve memory resource. Used during visualization network execution.  Releasing this data does not make  down-stream data invalid, so it does not modify the MTime of this  data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.Initialize">
            <summary>
                <para>Restore data object to initial state,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetMTime">
            <summary>
                <para>Data objects are composite objects and need to check each part for MTime. The information object also needs to be considered.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetProducerPort">
            <summary>
                <para>Get the port currently producing this object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetPipelineInformation(vtk.vtkInformation)">
            <summary>
                <para>Get/Set the pipeline information object that owns this data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetPipelineInformation">
            <summary>
                <para>Get/Set the pipeline information object that owns this data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetInformation(vtk.vtkInformation)">
            <summary>
                <para>Set/Get the information object associated with this data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetInformation">
            <summary>
                <para>Set/Get the information object associated with this data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.SetSource(vtk.vtkSource)">
            <summary>
                <para>Set/Get the source object creating this data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObject.GetSource">
            <summary>
                <para>Set/Get the source object creating this data object.</para>
            </summary>
        </member>
    </members>
</doc>