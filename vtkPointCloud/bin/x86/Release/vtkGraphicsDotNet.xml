<?xml version="1.0"?>
<doc>
    <assembly>
        "vtkGraphicsDotNet"
    </assembly>
    <members>
        <member name="M:vtk.vtkExtractCells.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractCells.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractCells.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractCells.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractCells.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractCells.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GenerateErrorVectorsOff">
            <summary>
                <para>Turn on/off the generation of error vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GenerateErrorVectorsOn">
            <summary>
                <para>Turn on/off the generation of error vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetGenerateErrorVectors">
            <summary>
                <para>Turn on/off the generation of error vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetGenerateErrorVectors(System.Int32)">
            <summary>
                <para>Turn on/off the generation of error vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GenerateErrorScalarsOff">
            <summary>
                <para>Turn on/off the generation of scalar distance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GenerateErrorScalarsOn">
            <summary>
                <para>Turn on/off the generation of scalar distance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetGenerateErrorScalars">
            <summary>
                <para>Turn on/off the generation of scalar distance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetGenerateErrorScalars(System.Int32)">
            <summary>
                <para>Turn on/off the generation of scalar distance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.NonManifoldSmoothingOff">
            <summary>
                <para>Smooth non-manifold vertices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.NonManifoldSmoothingOn">
            <summary>
                <para>Smooth non-manifold vertices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetNonManifoldSmoothing">
            <summary>
                <para>Smooth non-manifold vertices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetNonManifoldSmoothing(System.Int32)">
            <summary>
                <para>Smooth non-manifold vertices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.BoundarySmoothingOff">
            <summary>
                <para>Turn on/off the smoothing of vertices on the boundary of the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.BoundarySmoothingOn">
            <summary>
                <para>Turn on/off the smoothing of vertices on the boundary of the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetBoundarySmoothing">
            <summary>
                <para>Turn on/off the smoothing of vertices on the boundary of the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetBoundarySmoothing(System.Int32)">
            <summary>
                <para>Turn on/off the smoothing of vertices on the boundary of the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetEdgeAngle">
            <summary>
                <para>Specify the edge angle to control smoothing along edges (either interior or boundary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetEdgeAngleMaxValue">
            <summary>
                <para>Specify the edge angle to control smoothing along edges (either interior or boundary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetEdgeAngleMinValue">
            <summary>
                <para>Specify the edge angle to control smoothing along edges (either interior or boundary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetEdgeAngle(System.Double)">
            <summary>
                <para>Specify the edge angle to control smoothing along edges (either interior or boundary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetFeatureAngle">
            <summary>
                <para>Specify the feature angle for sharp edge identification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetFeatureAngleMaxValue">
            <summary>
                <para>Specify the feature angle for sharp edge identification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetFeatureAngleMinValue">
            <summary>
                <para>Specify the feature angle for sharp edge identification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetFeatureAngle(System.Double)">
            <summary>
                <para>Specify the feature angle for sharp edge identification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.FeatureEdgeSmoothingOff">
            <summary>
                <para>Turn on/off smoothing along sharp interior edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.FeatureEdgeSmoothingOn">
            <summary>
                <para>Turn on/off smoothing along sharp interior edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetFeatureEdgeSmoothing">
            <summary>
                <para>Turn on/off smoothing along sharp interior edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetFeatureEdgeSmoothing(System.Int32)">
            <summary>
                <para>Turn on/off smoothing along sharp interior edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.NormalizeCoordinatesOff">
            <summary>
                <para>Turn on/off coordinate normalization.  The positions can be translated and scaled such that they fit within a [-1, 1] prior to the smoothing computation. The default is off.  The numerical stability of the solution can be improved by turning normalization on.  If normalization is on, the coordinates will be rescaled to the original coordinate system after smoothing has completed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.NormalizeCoordinatesOn">
            <summary>
                <para>Turn on/off coordinate normalization.  The positions can be translated and scaled such that they fit within a [-1, 1] prior to the smoothing computation. The default is off.  The numerical stability of the solution can be improved by turning normalization on.  If normalization is on, the coordinates will be rescaled to the original coordinate system after smoothing has completed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetNormalizeCoordinates">
            <summary>
                <para>Turn on/off coordinate normalization.  The positions can be translated and scaled such that they fit within a [-1, 1] prior to the smoothing computation. The default is off.  The numerical stability of the solution can be improved by turning normalization on.  If normalization is on, the coordinates will be rescaled to the original coordinate system after smoothing has completed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetNormalizeCoordinates(System.Int32)">
            <summary>
                <para>Turn on/off coordinate normalization.  The positions can be translated and scaled such that they fit within a [-1, 1] prior to the smoothing computation. The default is off.  The numerical stability of the solution can be improved by turning normalization on.  If normalization is on, the coordinates will be rescaled to the original coordinate system after smoothing has completed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetPassBand">
            <summary>
                <para>Set the passband value for the windowed sinc filter</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetPassBandMaxValue">
            <summary>
                <para>Set the passband value for the windowed sinc filter</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetPassBandMinValue">
            <summary>
                <para>Set the passband value for the windowed sinc filter</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetPassBand(System.Double)">
            <summary>
                <para>Set the passband value for the windowed sinc filter</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetNumberOfIterations">
            <summary>
                <para>Specify the number of iterations (or degree of the polynomial approximating the windowed sinc function).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetNumberOfIterationsMaxValue">
            <summary>
                <para>Specify the number of iterations (or degree of the polynomial approximating the windowed sinc function).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.GetNumberOfIterationsMinValue">
            <summary>
                <para>Specify the number of iterations (or degree of the polynomial approximating the windowed sinc function).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowedSincPolyDataFilter.SetNumberOfIterations(System.Int32)">
            <summary>
                <para>Specify the number of iterations (or degree of the polynomial approximating the windowed sinc function).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMergeFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.AddField(System.String,vtk.vtkDataSet)">
            <summary>
                <para>Set the object from which to extract a field and the name of the field. Note that this does not create pipeline connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetTensorsConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set the object from which to extract a field and the name of the field. Note that this does not create pipeline connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.GetTensors">
            <summary>
                <para>Set / get the object from which to extract tensor data. Old style. Use SetTensorsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetTensors(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the object from which to extract tensor data. Old style. Use SetTensorsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetTCoordsConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set / get the object from which to extract tensor data. Old style. Use SetTensorsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.GetTCoords">
            <summary>
                <para>Set / get the object from which to extract texture coordinates information. Old style. Use SetTCoordsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetTCoords(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the object from which to extract texture coordinates information. Old style. Use SetTCoordsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetNormalsConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set / get the object from which to extract texture coordinates information. Old style. Use SetTCoordsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.GetNormals">
            <summary>
                <para>Set / get the object from which to extract normal information. Old style. Use SetNormalsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetNormals(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the object from which to extract normal information. Old style. Use SetNormalsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetVectorsConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set / get the object from which to extract normal information. Old style. Use SetNormalsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.GetVectors">
            <summary>
                <para>Set / get the object from which to extract vector information. Old style. Use SetVectorsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetVectors(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the object from which to extract vector information. Old style. Use SetVectorsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetScalarsConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set / get the object from which to extract vector information. Old style. Use SetVectorsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.GetScalars">
            <summary>
                <para>Specify object from which to extract scalar information. Old style. Use SetScalarsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetScalars(vtk.vtkDataSet)">
            <summary>
                <para>Specify object from which to extract scalar information. Old style. Use SetScalarsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetGeometryConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Specify object from which to extract scalar information. Old style. Use SetScalarsConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.GetGeometry">
            <summary>
                <para>Specify object from which to extract geometry information. Old style. Use SetGeometryConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFilter.SetGeometry(vtk.vtkDataSet)">
            <summary>
                <para>Specify object from which to extract geometry information. Old style. Use SetGeometryConnection() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetToroidal(System.Int32)">
            <summary>
                <para>Set/Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetToroidal">
            <summary>
                <para>Set/Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.ToroidalOff">
            <summary>
                <para>Set/Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.ToroidalOn">
            <summary>
                <para>Set/Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetSize">
            <summary>
                <para>Set/Get Superquadric isotropic size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetSize(System.Double)">
            <summary>
                <para>Set/Get Superquadric isotropic size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetThetaRoundness(System.Double)">
            <summary>
                <para>Set/Get Superquadric east/west roundness. Values range from 0 (rectangular) to 1 (circular) to higher orders.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetThetaRoundness">
            <summary>
                <para>Set/Get Superquadric east/west roundness. Values range from 0 (rectangular) to 1 (circular) to higher orders.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetPhiRoundness(System.Double)">
            <summary>
                <para>Set/Get Superquadric north/south roundness.  Values range from 0 (rectangular) to 1 (circular) to higher orders.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetPhiRoundness">
            <summary>
                <para>Set/Get Superquadric north/south roundness.  Values range from 0 (rectangular) to 1 (circular) to higher orders.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetThicknessMaxValue">
            <summary>
                <para>Set/Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetThicknessMinValue">
            <summary>
                <para>Set/Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetThickness(System.Double)">
            <summary>
                <para>Set/Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetThickness">
            <summary>
                <para>Set/Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetPhiResolution(System.Int32)">
            <summary>
                <para>Set the number of points in the latitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetPhiResolution">
            <summary>
                <para>Set the number of points in the latitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetThetaResolution(System.Int32)">
            <summary>
                <para>Set the number of points in the longitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetThetaResolution">
            <summary>
                <para>Set the number of points in the longitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetScale">
            <summary>
                <para>Set the scale factors of the superquadric. Default is 1,1,1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetScale(System.Double[])">
            <summary>
                <para>Set the scale factors of the superquadric. Default is 1,1,1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetScale(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the scale factors of the superquadric. Default is 1,1,1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.GetCenter">
            <summary>
                <para>Set the center of the superquadric. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetCenter(System.Double[])">
            <summary>
                <para>Set the center of the superquadric. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSuperquadricSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the center of the superquadric. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.GetNumberOfTimeSteps">
            <summary>
                <para>Get the number of time steps</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.GetPointIndex">
            <summary>
                <para>Index of point to extract at each time step</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractDataOverTime.SetPointIndex(System.Int32)">
            <summary>
                <para>Index of point to extract at each time step</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellDerivatives.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.GetTensorModeAsString">
            <summary>
                <para>Control how the filter works to generate tensor cell data. You can choose to pass the input cell tensors, compute the gradient of the input vectors, or compute the strain tensor of the vector gradient tensor. By default (TensorModeToComputeGradient), the filter will take the gradient of the vector data to construct a tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.SetTensorModeToComputeStrain">
            <summary>
                <para>Control how the filter works to generate tensor cell data. You can choose to pass the input cell tensors, compute the gradient of the input vectors, or compute the strain tensor of the vector gradient tensor. By default (TensorModeToComputeGradient), the filter will take the gradient of the vector data to construct a tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.SetTensorModeToComputeGradient">
            <summary>
                <para>Control how the filter works to generate tensor cell data. You can choose to pass the input cell tensors, compute the gradient of the input vectors, or compute the strain tensor of the vector gradient tensor. By default (TensorModeToComputeGradient), the filter will take the gradient of the vector data to construct a tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.SetTensorModeToPassTensors">
            <summary>
                <para>Control how the filter works to generate tensor cell data. You can choose to pass the input cell tensors, compute the gradient of the input vectors, or compute the strain tensor of the vector gradient tensor. By default (TensorModeToComputeGradient), the filter will take the gradient of the vector data to construct a tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.GetTensorMode">
            <summary>
                <para>Control how the filter works to generate tensor cell data. You can choose to pass the input cell tensors, compute the gradient of the input vectors, or compute the strain tensor of the vector gradient tensor. By default (TensorModeToComputeGradient), the filter will take the gradient of the vector data to construct a tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.SetTensorMode(System.Int32)">
            <summary>
                <para>Control how the filter works to generate tensor cell data. You can choose to pass the input cell tensors, compute the gradient of the input vectors, or compute the strain tensor of the vector gradient tensor. By default (TensorModeToComputeGradient), the filter will take the gradient of the vector data to construct a tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.GetVectorModeAsString">
            <summary>
                <para>Control how the filter works to generate vector cell data. You can choose to pass the input cell vectors, compute the gradient of the input scalars, or extract the vorticity of the computed vector gradient tensor. By default (VectorModeToComputeGradient), the filter will take the gradient of the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.SetVectorModeToComputeVorticity">
            <summary>
                <para>Control how the filter works to generate vector cell data. You can choose to pass the input cell vectors, compute the gradient of the input scalars, or extract the vorticity of the computed vector gradient tensor. By default (VectorModeToComputeGradient), the filter will take the gradient of the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.SetVectorModeToComputeGradient">
            <summary>
                <para>Control how the filter works to generate vector cell data. You can choose to pass the input cell vectors, compute the gradient of the input scalars, or extract the vorticity of the computed vector gradient tensor. By default (VectorModeToComputeGradient), the filter will take the gradient of the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.SetVectorModeToPassVectors">
            <summary>
                <para>Control how the filter works to generate vector cell data. You can choose to pass the input cell vectors, compute the gradient of the input scalars, or extract the vorticity of the computed vector gradient tensor. By default (VectorModeToComputeGradient), the filter will take the gradient of the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.GetVectorMode">
            <summary>
                <para>Control how the filter works to generate vector cell data. You can choose to pass the input cell vectors, compute the gradient of the input scalars, or extract the vorticity of the computed vector gradient tensor. By default (VectorModeToComputeGradient), the filter will take the gradient of the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDerivatives.SetVectorMode(System.Int32)">
            <summary>
                <para>Control how the filter works to generate vector cell data. You can choose to pass the input cell vectors, compute the gradient of the input scalars, or extract the vorticity of the computed vector gradient tensor. By default (VectorModeToComputeGradient), the filter will take the gradient of the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAppendFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAppendFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAppendFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAppendFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAppendFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAppendFilter.GetInputList">
            <summary>
                <para>Returns a copy of the input array.  Modifications to this list will not be reflected in the actual inputs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendFilter.RemoveInput(vtk.vtkDataSet)">
            <summary>
                <para>Remove a dataset from the list of data to append.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GetInputMemoryLimit">
            <summary>
                <para>The InputMemoryLimit determines the chunk size (the number of slices requested at each iteration).  The units of this limit is KiloBytes. For now, only the Z axis is split.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.SetInputMemoryLimit(System.Int32)">
            <summary>
                <para>The InputMemoryLimit determines the chunk size (the number of slices requested at each iteration).  The units of this limit is KiloBytes. For now, only the Z axis is split.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.ComputeGradientsOff">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.ComputeGradientsOn">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GetComputeGradients">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.SetComputeGradients(System.Int32)">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.ComputeScalarsOff">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.ComputeScalarsOn">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GetComputeScalars">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.SetComputeScalars(System.Int32)">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GetMTime">
            <summary>
                <para>Because we delegate to vtkContourValues &amp; refer to vtkImplicitFunction</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GetNumberOfContours">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GetValues(System.Double[])">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.GetValue(System.Int32)">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMarchingCubes.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.GetInputList">
            <summary>
                <para>Return the list of inputs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.RemoveInput(vtk.vtkDataSet)">
            <summary>
                <para>Remove a dataset from the list of data to process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableAttributeDataFilter.AddInput(vtk.vtkDataSet)">
            <summary>
                <para>Add a dataset to the list of data to process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.SetInputMemoryLimit(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>This filter will initiate streaming so that no piece requested from the input will be larger than this value (KiloBytes).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GetExecuteExtent">
            <summary>
                <para>Needed by templated functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Needed by templated functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GetNumberOfContours">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Get the number of contours in the list of contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GetValues(System.Double[])">
            <summary>
                <para>Set the number of contours to place into the list. You only really need to use this method to reduce list size. The method SetValue() will automatically increase list size as needed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GetValue(System.Int32)">
            <summary>
                <para>Get a pointer to an array of contour values. There will be GetNumberOfContours() values in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Get the ith contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.ComputeScalarsOff">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.ComputeScalarsOn">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GetComputeScalars">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.SetComputeScalars(System.Int32)">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.ComputeGradientsOff">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.ComputeGradientsOn">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GetComputeGradients">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.SetComputeGradients(System.Int32)">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridSynchronizedTemplates3D.GetMTime">
            <summary>
                <para>Because we delegate to vtkContourValues</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCutter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCutter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCutter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCutter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCutter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCutter.GetCellTypeDimensions(System.Byte[])">
            <summary>
                <para>Normally I would put this in a different class, but since This is a temporary fix until we convert this class and contour filter to generate unstructured grid output instead of poly data, I am leaving it here.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The  locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetSortByAsString">
            <summary>
                <para>Set the sorting order for the generated polydata. There are two possibilities:   Sort by value = 0 - This is the most efficient sort. For each cell,      all contour values are processed. This is the default.   Sort by cell = 1 - For each contour value, all cells are processed.      This order should be used if the extracted polygons must be rendered      in a back-to-front or front-to-back order. This is very problem       dependent. For most applications, the default order is fine (and faster).</para>
                <para>Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with  vtkPolyData output, verts and lines have lower cell ids than triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.SetSortByToSortByCell">
            <summary>
                <para>Set the sorting order for the generated polydata. There are two possibilities:   Sort by value = 0 - This is the most efficient sort. For each cell,      all contour values are processed. This is the default.   Sort by cell = 1 - For each contour value, all cells are processed.      This order should be used if the extracted polygons must be rendered      in a back-to-front or front-to-back order. This is very problem       dependent. For most applications, the default order is fine (and faster).</para>
                <para>Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with  vtkPolyData output, verts and lines have lower cell ids than triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.SetSortByToSortByValue">
            <summary>
                <para>Set the sorting order for the generated polydata. There are two possibilities:   Sort by value = 0 - This is the most efficient sort. For each cell,      all contour values are processed. This is the default.   Sort by cell = 1 - For each contour value, all cells are processed.      This order should be used if the extracted polygons must be rendered      in a back-to-front or front-to-back order. This is very problem       dependent. For most applications, the default order is fine (and faster).</para>
                <para>Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with  vtkPolyData output, verts and lines have lower cell ids than triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetSortBy">
            <summary>
                <para>Set the sorting order for the generated polydata. There are two possibilities:   Sort by value = 0 - This is the most efficient sort. For each cell,      all contour values are processed. This is the default.   Sort by cell = 1 - For each contour value, all cells are processed.      This order should be used if the extracted polygons must be rendered      in a back-to-front or front-to-back order. This is very problem       dependent. For most applications, the default order is fine (and faster).</para>
                <para>Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with  vtkPolyData output, verts and lines have lower cell ids than triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetSortByMaxValue">
            <summary>
                <para>Set the sorting order for the generated polydata. There are two possibilities:   Sort by value = 0 - This is the most efficient sort. For each cell,      all contour values are processed. This is the default.   Sort by cell = 1 - For each contour value, all cells are processed.      This order should be used if the extracted polygons must be rendered      in a back-to-front or front-to-back order. This is very problem       dependent. For most applications, the default order is fine (and faster).</para>
                <para>Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with  vtkPolyData output, verts and lines have lower cell ids than triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetSortByMinValue">
            <summary>
                <para>Set the sorting order for the generated polydata. There are two possibilities:   Sort by value = 0 - This is the most efficient sort. For each cell,      all contour values are processed. This is the default.   Sort by cell = 1 - For each contour value, all cells are processed.      This order should be used if the extracted polygons must be rendered      in a back-to-front or front-to-back order. This is very problem       dependent. For most applications, the default order is fine (and faster).</para>
                <para>Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with  vtkPolyData output, verts and lines have lower cell ids than triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.SetSortBy(System.Int32)">
            <summary>
                <para>Set the sorting order for the generated polydata. There are two possibilities:   Sort by value = 0 - This is the most efficient sort. For each cell,      all contour values are processed. This is the default.   Sort by cell = 1 - For each contour value, all cells are processed.      This order should be used if the extracted polygons must be rendered      in a back-to-front or front-to-back order. This is very problem       dependent. For most applications, the default order is fine (and faster).</para>
                <para>Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with  vtkPolyData output, verts and lines have lower cell ids than triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetLocator">
            <summary>
                <para>Specify a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Specify a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GenerateCutScalarsOff">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be interpolated from the implicit function values, and not the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GenerateCutScalarsOn">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be interpolated from the implicit function values, and not the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetGenerateCutScalars">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be interpolated from the implicit function values, and not the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.SetGenerateCutScalars(System.Int32)">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be interpolated from the implicit function values, and not the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetMTime">
            <summary>
                <para>Override GetMTime because we delegate to vtkContourValues and refer to vtkImplicitFunction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Override GetMTime because we delegate to vtkContourValues and refer to vtkImplicitFunction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetNumberOfContours">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Get the number of contours in the list of contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetValues(System.Double[])">
            <summary>
                <para>Set the number of contours to place into the list. You only really need to use this method to reduce list size. The method SetValue() will automatically increase list size as needed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.GetValue(System.Int32)">
            <summary>
                <para>Get a pointer to an array of contour values. There will be GetNumberOfContours() values in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCutter.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Get the ith contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHedgeHog.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.GetVectorModeAsString">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.SetVectorModeToUseNormal">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.SetVectorModeToUseVector">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.GetVectorMode">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.SetVectorMode(System.Int32)">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.GetScaleFactor">
            <summary>
                <para>Set scale factor to control size of oriented lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHedgeHog.SetScaleFactor(System.Double)">
            <summary>
                <para>Set scale factor to control size of oriented lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.OperateOnBounds(System.Double[],System.Double[])">
            <summary>
                <para>Perform quantization on bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.OperateOnPoint(System.Double[],System.Double[])">
            <summary>
                <para>Perform quantization on a point</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.GetQFactor">
            <summary>
                <para>Specify quantization grain size</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.GetQFactorMaxValue">
            <summary>
                <para>Specify quantization grain size</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.GetQFactorMinValue">
            <summary>
                <para>Specify quantization grain size</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuantizePolyDataPoints.SetQFactor(System.Double)">
            <summary>
                <para>Specify quantization grain size</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTriangleFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.GetPassLines">
            <summary>
                <para>Turn on/off passing lines through filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.SetPassLines(System.Int32)">
            <summary>
                <para>Turn on/off passing lines through filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.PassLinesOff">
            <summary>
                <para>Turn on/off passing lines through filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.PassLinesOn">
            <summary>
                <para>Turn on/off passing lines through filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.GetPassVerts">
            <summary>
                <para>Turn on/off passing vertices through filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.SetPassVerts(System.Int32)">
            <summary>
                <para>Turn on/off passing vertices through filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.PassVertsOff">
            <summary>
                <para>Turn on/off passing vertices through filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangleFilter.PassVertsOn">
            <summary>
                <para>Turn on/off passing vertices through filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.CellDataOff">
            <summary>
                <para>Turn on/off the conversion of dataset cell data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.CellDataOn">
            <summary>
                <para>Turn on/off the conversion of dataset cell data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.GetCellData">
            <summary>
                <para>Turn on/off the conversion of dataset cell data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.SetCellData(System.Int32)">
            <summary>
                <para>Turn on/off the conversion of dataset cell data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.PointDataOff">
            <summary>
                <para>Turn on/off the conversion of dataset point data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.PointDataOn">
            <summary>
                <para>Turn on/off the conversion of dataset point data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.GetPointData">
            <summary>
                <para>Turn on/off the conversion of dataset point data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.SetPointData(System.Int32)">
            <summary>
                <para>Turn on/off the conversion of dataset point data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.FieldDataOff">
            <summary>
                <para>Turn on/off the conversion of dataset field data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.FieldDataOn">
            <summary>
                <para>Turn on/off the conversion of dataset field data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.GetFieldData">
            <summary>
                <para>Turn on/off the conversion of dataset field data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.SetFieldData(System.Int32)">
            <summary>
                <para>Turn on/off the conversion of dataset field data to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.TopologyOff">
            <summary>
                <para>Turn on/off the conversion of dataset topology to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.TopologyOn">
            <summary>
                <para>Turn on/off the conversion of dataset topology to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.GetTopology">
            <summary>
                <para>Turn on/off the conversion of dataset topology to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.SetTopology(System.Int32)">
            <summary>
                <para>Turn on/off the conversion of dataset topology to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.GeometryOff">
            <summary>
                <para>Turn on/off the conversion of dataset geometry to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.GeometryOn">
            <summary>
                <para>Turn on/off the conversion of dataset geometry to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.GetGeometry">
            <summary>
                <para>Turn on/off the conversion of dataset geometry to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetToDataObjectFilter.SetGeometry(System.Int32)">
            <summary>
                <para>Turn on/off the conversion of dataset geometry to a data object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetTextureHeightRatio">
            <summary>
                <para>Set/Get the ratio of the height of the texture region to the shoulder height. Values greater than 1.0 yield convex buttons with the texture region raised above the shoulder. Values less than 1.0 yield concave buttons with the texture region below the shoulder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetTextureHeightRatioMaxValue">
            <summary>
                <para>Set/Get the ratio of the height of the texture region to the shoulder height. Values greater than 1.0 yield convex buttons with the texture region raised above the shoulder. Values less than 1.0 yield concave buttons with the texture region below the shoulder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetTextureHeightRatioMinValue">
            <summary>
                <para>Set/Get the ratio of the height of the texture region to the shoulder height. Values greater than 1.0 yield convex buttons with the texture region raised above the shoulder. Values less than 1.0 yield concave buttons with the texture region below the shoulder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.SetTextureHeightRatio(System.Double)">
            <summary>
                <para>Set/Get the ratio of the height of the texture region to the shoulder height. Values greater than 1.0 yield convex buttons with the texture region raised above the shoulder. Values less than 1.0 yield concave buttons with the texture region below the shoulder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetTextureRatio">
            <summary>
                <para>Set/Get the ratio of the texture region to the shoulder region. This number must be 0&lt;=tr&lt;=1. If the texture style is to fit the image, then satisfying the texture ratio may only be possible in one of the two directions (length or width) depending on the  dimensions of the texture.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetTextureRatioMaxValue">
            <summary>
                <para>Set/Get the ratio of the texture region to the shoulder region. This number must be 0&lt;=tr&lt;=1. If the texture style is to fit the image, then satisfying the texture ratio may only be possible in one of the two directions (length or width) depending on the  dimensions of the texture.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetTextureRatioMinValue">
            <summary>
                <para>Set/Get the ratio of the texture region to the shoulder region. This number must be 0&lt;=tr&lt;=1. If the texture style is to fit the image, then satisfying the texture ratio may only be possible in one of the two directions (length or width) depending on the  dimensions of the texture.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.SetTextureRatio(System.Double)">
            <summary>
                <para>Set/Get the ratio of the texture region to the shoulder region. This number must be 0&lt;=tr&lt;=1. If the texture style is to fit the image, then satisfying the texture ratio may only be possible in one of the two directions (length or width) depending on the  dimensions of the texture.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetBoxRatio">
            <summary>
                <para>Set/Get the ratio of the bottom of the button with the shoulder region. Numbers greater than one produce buttons with a wider bottom than shoulder; ratios less than one produce buttons that have a wider shoulder than bottom.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetBoxRatioMaxValue">
            <summary>
                <para>Set/Get the ratio of the bottom of the button with the shoulder region. Numbers greater than one produce buttons with a wider bottom than shoulder; ratios less than one produce buttons that have a wider shoulder than bottom.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetBoxRatioMinValue">
            <summary>
                <para>Set/Get the ratio of the bottom of the button with the shoulder region. Numbers greater than one produce buttons with a wider bottom than shoulder; ratios less than one produce buttons that have a wider shoulder than bottom.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.SetBoxRatio(System.Double)">
            <summary>
                <para>Set/Get the ratio of the bottom of the button with the shoulder region. Numbers greater than one produce buttons with a wider bottom than shoulder; ratios less than one produce buttons that have a wider shoulder than bottom.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetDepth">
            <summary>
                <para>Set/Get the depth of the button (the z-eliipsoid axis length).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetDepthMaxValue">
            <summary>
                <para>Set/Get the depth of the button (the z-eliipsoid axis length).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetDepthMinValue">
            <summary>
                <para>Set/Get the depth of the button (the z-eliipsoid axis length).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.SetDepth(System.Double)">
            <summary>
                <para>Set/Get the depth of the button (the z-eliipsoid axis length).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetHeight">
            <summary>
                <para>Set/Get the height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetHeightMaxValue">
            <summary>
                <para>Set/Get the height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetHeightMinValue">
            <summary>
                <para>Set/Get the height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.SetHeight(System.Double)">
            <summary>
                <para>Set/Get the height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetWidth">
            <summary>
                <para>Set/Get the width of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetWidthMaxValue">
            <summary>
                <para>Set/Get the width of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.GetWidthMinValue">
            <summary>
                <para>Set/Get the width of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectangularButtonSource.SetWidth(System.Double)">
            <summary>
                <para>Set/Get the width of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCurvatures.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCurvatures.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCurvatures.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCurvatures.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCurvatures.InvertMeanCurvatureOff">
            <summary>
                <para>Set/Get the flag which inverts the mean curvature calculation for meshes with inward pointing normals (default false)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.InvertMeanCurvatureOn">
            <summary>
                <para>Set/Get the flag which inverts the mean curvature calculation for meshes with inward pointing normals (default false)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.GetInvertMeanCurvature">
            <summary>
                <para>Set/Get the flag which inverts the mean curvature calculation for meshes with inward pointing normals (default false)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.SetInvertMeanCurvature(System.Int32)">
            <summary>
                <para>Set/Get the flag which inverts the mean curvature calculation for meshes with inward pointing normals (default false)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.SetCurvatureTypeToMinimum">
            <summary>
                <para>Set/Get the flag which inverts the mean curvature calculation for meshes with inward pointing normals (default false)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.SetCurvatureTypeToMaximum">
            <summary>
                <para>Set/Get Curvature type VTK_CURVATURE_GAUSS: Gaussian curvature, stored as DataArray "Gauss_Curvature" VTK_CURVATURE_MEAN : Mean curvature, stored as DataArray "Mean_Curvature"</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.SetCurvatureTypeToMean">
            <summary>
                <para>Set/Get Curvature type VTK_CURVATURE_GAUSS: Gaussian curvature, stored as DataArray "Gauss_Curvature" VTK_CURVATURE_MEAN : Mean curvature, stored as DataArray "Mean_Curvature"</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.SetCurvatureTypeToGaussian">
            <summary>
                <para>Set/Get Curvature type VTK_CURVATURE_GAUSS: Gaussian curvature, stored as DataArray "Gauss_Curvature" VTK_CURVATURE_MEAN : Mean curvature, stored as DataArray "Mean_Curvature"</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.GetCurvatureType">
            <summary>
                <para>Set/Get Curvature type VTK_CURVATURE_GAUSS: Gaussian curvature, stored as DataArray "Gauss_Curvature" VTK_CURVATURE_MEAN : Mean curvature, stored as DataArray "Mean_Curvature"</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCurvatures.SetCurvatureType(System.Int32)">
            <summary>
                <para>Set/Get Curvature type VTK_CURVATURE_GAUSS: Gaussian curvature, stored as DataArray "Gauss_Curvature" VTK_CURVATURE_MEAN : Mean curvature, stored as DataArray "Mean_Curvature"</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkClipDataSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetMTime">
            <summary>
                <para>Return the mtime also considering the locator and clip function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The  locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetLocator">
            <summary>
                <para>Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetClippedOutput">
            <summary>
                <para>Return the Clipped output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetMergeTolerance">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate primitives. Note that only 3D cells actually use this instance variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetMergeToleranceMaxValue">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate primitives. Note that only 3D cells actually use this instance variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetMergeToleranceMinValue">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate primitives. Note that only 3D cells actually use this instance variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.SetMergeTolerance(System.Double)">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate primitives. Note that only 3D cells actually use this instance variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GenerateClippedOutputOff">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GenerateClippedOutputOn">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetGenerateClippedOutput">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.SetGenerateClippedOutput(System.Int32)">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GenerateClipScalarsOff">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GenerateClipScalarsOn">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetGenerateClipScalars">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.SetGenerateClipScalars(System.Int32)">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.InsideOutOff">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.InsideOutOn">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetInsideOut">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.SetInsideOut(System.Int32)">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.GetValue">
            <summary>
                <para>Set the clipping value of the implicit function (if clipping with implicit function) or scalar value (if clipping with scalars). The default value is 0.0. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipDataSet.SetValue(System.Double)">
            <summary>
                <para>Set the clipping value of the implicit function (if clipping with implicit function) or scalar value (if clipping with scalars). The default value is 0.0. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellCenterDepthSort.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellCenterDepthSort.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellCenterDepthSort.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellCenterDepthSort.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellCenterDepthSort.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellCenterDepthSort.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStreamPoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.GetTimeIncrement">
            <summary>
                <para>Specify the separation of points in terms of absolute time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.GetTimeIncrementMaxValue">
            <summary>
                <para>Specify the separation of points in terms of absolute time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.GetTimeIncrementMinValue">
            <summary>
                <para>Specify the separation of points in terms of absolute time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamPoints.SetTimeIncrement(System.Double)">
            <summary>
                <para>Specify the separation of points in terms of absolute time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSphereSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSphereSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSphereSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSphereSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSphereSource.LatLongTessellationOff">
            <summary>
                <para>Cause the sphere to be tessellated with edges along the latitude and longitude lines. If off, triangles are generated at non-polar regions, which results in edges that are not parallel to latitude and longitude lines. If on, quadrilaterals are generated everywhere except at the poles. This can be useful for generating a wireframe sphere with natural latitude and longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.LatLongTessellationOn">
            <summary>
                <para>Cause the sphere to be tessellated with edges along the latitude and longitude lines. If off, triangles are generated at non-polar regions, which results in edges that are not parallel to latitude and longitude lines. If on, quadrilaterals are generated everywhere except at the poles. This can be useful for generating a wireframe sphere with natural latitude and longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetLatLongTessellation">
            <summary>
                <para>Cause the sphere to be tessellated with edges along the latitude and longitude lines. If off, triangles are generated at non-polar regions, which results in edges that are not parallel to latitude and longitude lines. If on, quadrilaterals are generated everywhere except at the poles. This can be useful for generating a wireframe sphere with natural latitude and longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetLatLongTessellation(System.Int32)">
            <summary>
                <para>Cause the sphere to be tessellated with edges along the latitude and longitude lines. If off, triangles are generated at non-polar regions, which results in edges that are not parallel to latitude and longitude lines. If on, quadrilaterals are generated everywhere except at the poles. This can be useful for generating a wireframe sphere with natural latitude and longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetEndPhi">
            <summary>
                <para>Set the ending latitude angle. By default EndPhi=180 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetEndPhiMaxValue">
            <summary>
                <para>Set the ending latitude angle. By default EndPhi=180 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetEndPhiMinValue">
            <summary>
                <para>Set the ending latitude angle. By default EndPhi=180 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetEndPhi(System.Double)">
            <summary>
                <para>Set the ending latitude angle. By default EndPhi=180 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetStartPhi">
            <summary>
                <para>Set the starting latitude angle (0 is at north pole). By default StartPhi=0 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetStartPhiMaxValue">
            <summary>
                <para>Set the starting latitude angle (0 is at north pole). By default StartPhi=0 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetStartPhiMinValue">
            <summary>
                <para>Set the starting latitude angle (0 is at north pole). By default StartPhi=0 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetStartPhi(System.Double)">
            <summary>
                <para>Set the starting latitude angle (0 is at north pole). By default StartPhi=0 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetEndTheta">
            <summary>
                <para>Set the ending longitude angle. By default EndTheta=360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetEndThetaMaxValue">
            <summary>
                <para>Set the ending longitude angle. By default EndTheta=360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetEndThetaMinValue">
            <summary>
                <para>Set the ending longitude angle. By default EndTheta=360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetEndTheta(System.Double)">
            <summary>
                <para>Set the ending longitude angle. By default EndTheta=360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetStartTheta">
            <summary>
                <para>Set the starting longitude angle. By default StartTheta=0 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetStartThetaMaxValue">
            <summary>
                <para>Set the starting longitude angle. By default StartTheta=0 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetStartThetaMinValue">
            <summary>
                <para>Set the starting longitude angle. By default StartTheta=0 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetStartTheta(System.Double)">
            <summary>
                <para>Set the starting longitude angle. By default StartTheta=0 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetPhiResolution">
            <summary>
                <para>Set the number of points in the latitude direction (ranging from StartPhi to EndPhi).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetPhiResolutionMaxValue">
            <summary>
                <para>Set the number of points in the latitude direction (ranging from StartPhi to EndPhi).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetPhiResolutionMinValue">
            <summary>
                <para>Set the number of points in the latitude direction (ranging from StartPhi to EndPhi).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetPhiResolution(System.Int32)">
            <summary>
                <para>Set the number of points in the latitude direction (ranging from StartPhi to EndPhi).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetThetaResolution">
            <summary>
                <para>Set the number of points in the longitude direction (ranging from StartTheta to EndTheta).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetThetaResolutionMaxValue">
            <summary>
                <para>Set the number of points in the longitude direction (ranging from StartTheta to EndTheta).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetThetaResolutionMinValue">
            <summary>
                <para>Set the number of points in the longitude direction (ranging from StartTheta to EndTheta).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetThetaResolution(System.Int32)">
            <summary>
                <para>Set the number of points in the longitude direction (ranging from StartTheta to EndTheta).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetCenter">
            <summary>
                <para>Set the center of the sphere. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetCenter(System.Double[])">
            <summary>
                <para>Set the center of the sphere. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the center of the sphere. Default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetRadius">
            <summary>
                <para>Set radius of sphere. Default is .5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetRadiusMaxValue">
            <summary>
                <para>Set radius of sphere. Default is .5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.GetRadiusMinValue">
            <summary>
                <para>Set radius of sphere. Default is .5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphereSource.SetRadius(System.Double)">
            <summary>
                <para>Set radius of sphere. Default is .5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBDicer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOBBDicer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOBBDicer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOBBDicer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOBBDicer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOBBDicer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTransformFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTransformFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTransformFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTransformFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTransformFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTransformFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTransformFilter.GetTransform">
            <summary>
                <para>Specify the transform object used to transform points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformFilter.SetTransform(vtk.vtkAbstractTransform)">
            <summary>
                <para>Specify the transform object used to transform points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformFilter.GetMTime">
            <summary>
                <para>Return the MTime also considering the transform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetPhi">
            <summary>
                <para>Set the maximum latitude angle (0 is at north pole).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetPhiMaxValue">
            <summary>
                <para>Set the maximum latitude angle (0 is at north pole).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetPhiMinValue">
            <summary>
                <para>Set the maximum latitude angle (0 is at north pole).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.SetPhi(System.Double)">
            <summary>
                <para>Set the maximum latitude angle (0 is at north pole).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetTheta">
            <summary>
                <para>Set the maximum longitude angle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetThetaMaxValue">
            <summary>
                <para>Set the maximum longitude angle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetThetaMinValue">
            <summary>
                <para>Set the maximum longitude angle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.SetTheta(System.Double)">
            <summary>
                <para>Set the maximum longitude angle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetPhiResolution">
            <summary>
                <para>Set the number of points in the latitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetPhiResolutionMaxValue">
            <summary>
                <para>Set the number of points in the latitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetPhiResolutionMinValue">
            <summary>
                <para>Set the number of points in the latitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.SetPhiResolution(System.Int32)">
            <summary>
                <para>Set the number of points in the latitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetThetaResolution">
            <summary>
                <para>Set the number of points in the longitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetThetaResolutionMaxValue">
            <summary>
                <para>Set the number of points in the longitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetThetaResolutionMinValue">
            <summary>
                <para>Set the number of points in the longitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.SetThetaResolution(System.Int32)">
            <summary>
                <para>Set the number of points in the longitude direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetRadius">
            <summary>
                <para>Set radius of sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetRadiusMaxValue">
            <summary>
                <para>Set radius of sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.GetRadiusMinValue">
            <summary>
                <para>Set radius of sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexturedSphereSource.SetRadius(System.Double)">
            <summary>
                <para>Set radius of sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOBBTree.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOBBTree.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOBBTree.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOBBTree.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOBBTree.GenerateRepresentation(System.Int32,vtk.vtkPolyData)">
            <summary>
                <para>Create polygonal representation for OBB tree at specified level. If level &lt; 0, then the leaf OBB nodes will be gathered. The aspect ratio (ar) and line diameter (d) are used to control the building of the representation. If a OBB node edge ratio's are greater than ar, then the dimension of the OBB is collapsed (OBB-&gt;plane-&gt;line). A "line" OBB will be represented either as two crossed polygons, or as a line, depending on the relative diameter of the OBB compared to the diameter (d).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.BuildLocator">
            <summary>
                <para>Satisfy locator's abstract interface, see vtkLocator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.FreeSearchStructure">
            <summary>
                <para>Satisfy locator's abstract interface, see vtkLocator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.IntersectWithLine(System.Double[],System.Double[],System.Double,System.Double@,System.Double[],System.Double[],System.Int32@)">
            <summary>
                <para>Return the first intersection of the specified line segment with the OBB tree, as well as information about the cell which the line segment intersected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.IntersectWithLine(System.Double[],System.Double[],vtk.vtkPoints,vtk.vtkIdList)">
            <summary>
                <para>Take the passed line segment and intersect it with the data set. This method assumes that the data set is a vtkPolyData that describes a closed surface, and the intersection points that are returned in 'points' alternate between entrance points and exit points. The return value of the function is 0 if no intersections were found, -1 if point 'a0' lies inside the closed surface, or +1 if point 'a0' lies outside the closed surface. Either 'points' or 'cellIds' can be set to NULL if you don't want to receive that information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.InsideOrOutside(System.Double[])">
            <summary>
                <para>Determine whether a point is inside or outside the data used to build this OBB tree.  The data must be a closed surface vtkPolyData data set. The return value is +1 if outside, -1 if inside, and 0 if undecided.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.ComputeOBB(vtk.vtkDataSet,System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute an OBB for the input dataset using the cells in the data. Return the corner point and the three axes defining the orientation of the OBB. Also return a sorted list of relative "sizes" of axes for comparison purposes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBBTree.ComputeOBB(vtk.vtkPoints,System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute an OBB from the list of points given. Return the corner point and the three axes defining the orientation of the OBB. Also return a sorted list of relative "sizes" of axes for comparison purposes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCylinderSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.CappingOff">
            <summary>
                <para>Turn on/off whether to cap cylinder with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.CappingOn">
            <summary>
                <para>Turn on/off whether to cap cylinder with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetCapping">
            <summary>
                <para>Turn on/off whether to cap cylinder with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.SetCapping(System.Int32)">
            <summary>
                <para>Turn on/off whether to cap cylinder with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetResolution">
            <summary>
                <para>Set the number of facets used to define cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetResolutionMaxValue">
            <summary>
                <para>Set the number of facets used to define cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetResolutionMinValue">
            <summary>
                <para>Set the number of facets used to define cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.SetResolution(System.Int32)">
            <summary>
                <para>Set the number of facets used to define cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetCenter">
            <summary>
                <para>Set/Get cylinder center</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.SetCenter(System.Double[])">
            <summary>
                <para>Set/Get cylinder center</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get cylinder center</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetRadius">
            <summary>
                <para>Set the radius of the cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetRadiusMaxValue">
            <summary>
                <para>Set the radius of the cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetRadiusMinValue">
            <summary>
                <para>Set the radius of the cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.SetRadius(System.Double)">
            <summary>
                <para>Set the radius of the cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetHeight">
            <summary>
                <para>Set the height of the cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetHeightMaxValue">
            <summary>
                <para>Set the height of the cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.GetHeightMinValue">
            <summary>
                <para>Set the height of the cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylinderSource.SetHeight(System.Double)">
            <summary>
                <para>Set the height of the cylinder.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStreamer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSelectPolyData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetSelectionEdges">
            <summary>
                <para>Return the (mesh) edges of the selection region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetUnselectedOutput">
            <summary>
                <para>Return output that hasn't been selected (if GenreateUnselectedOutput is enabled).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GenerateUnselectedOutputOff">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's not been selected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GenerateUnselectedOutputOn">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's not been selected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetGenerateUnselectedOutput">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's not been selected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.SetGenerateUnselectedOutput(System.Int32)">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's not been selected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetSelectionModeAsString">
            <summary>
                <para>Control how inside/outside of loop is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.SetSelectionModeToClosestPointRegion">
            <summary>
                <para>Control how inside/outside of loop is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.SetSelectionModeToLargestRegion">
            <summary>
                <para>Control how inside/outside of loop is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.SetSelectionModeToSmallestRegion">
            <summary>
                <para>Control how inside/outside of loop is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetSelectionMode">
            <summary>
                <para>Control how inside/outside of loop is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetSelectionModeMaxValue">
            <summary>
                <para>Control how inside/outside of loop is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetSelectionModeMinValue">
            <summary>
                <para>Control how inside/outside of loop is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.SetSelectionMode(System.Int32)">
            <summary>
                <para>Control how inside/outside of loop is defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetLoop">
            <summary>
                <para>Set/Get the array of point coordinates defining the loop. There must be at least three points used to define a loop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.SetLoop(vtk.vtkPoints)">
            <summary>
                <para>Set/Get the array of point coordinates defining the loop. There must be at least three points used to define a loop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.InsideOutOff">
            <summary>
                <para>Set/Get the InsideOut flag. When off, the mesh within the loop is extracted. When on, the mesh outside the loop is extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.InsideOutOn">
            <summary>
                <para>Set/Get the InsideOut flag. When off, the mesh within the loop is extracted. When on, the mesh outside the loop is extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetInsideOut">
            <summary>
                <para>Set/Get the InsideOut flag. When off, the mesh within the loop is extracted. When on, the mesh outside the loop is extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.SetInsideOut(System.Int32)">
            <summary>
                <para>Set/Get the InsideOut flag. When off, the mesh within the loop is extracted. When on, the mesh outside the loop is extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GenerateSelectionScalarsOff">
            <summary>
                <para>Set/Get the flag to control behavior of the filter. If GenerateSelectionScalars is on, then the output of the filter is the same as the input, except that scalars are generated. If off, the filter outputs the cells laying inside the loop, and does not generate scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GenerateSelectionScalarsOn">
            <summary>
                <para>Set/Get the flag to control behavior of the filter. If GenerateSelectionScalars is on, then the output of the filter is the same as the input, except that scalars are generated. If off, the filter outputs the cells laying inside the loop, and does not generate scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.GetGenerateSelectionScalars">
            <summary>
                <para>Set/Get the flag to control behavior of the filter. If GenerateSelectionScalars is on, then the output of the filter is the same as the input, except that scalars are generated. If off, the filter outputs the cells laying inside the loop, and does not generate scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectPolyData.SetGenerateSelectionScalars(System.Int32)">
            <summary>
                <para>Set/Get the flag to control behavior of the filter. If GenerateSelectionScalars is on, then the output of the filter is the same as the input, except that scalars are generated. If off, the filter outputs the cells laying inside the loop, and does not generate scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSliceCubes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.GetLimitsFileName">
            <summary>
                <para>Specify file name of marching cubes limits file. The limits file speeds up subsequent reading of output triangle file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.SetLimitsFileName(System.String)">
            <summary>
                <para>Specify file name of marching cubes limits file. The limits file speeds up subsequent reading of output triangle file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.GetValue">
            <summary>
                <para>Set/get isosurface contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.SetValue(System.Double)">
            <summary>
                <para>Set/get isosurface contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.GetFileName">
            <summary>
                <para>Specify file name of marching cubes output file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSliceCubes.SetFileName(System.String)">
            <summary>
                <para>Specify file name of marching cubes output file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMassProperties.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMassProperties.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMassProperties.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMassProperties.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMassProperties.GetSurfaceArea">
            <summary>
                <para>Compute and return the normalized shape index. This characterizes the deviation of the shape of an object from a sphere. A sphere's NSI is one. This number is always &gt;= 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.GetKz">
            <summary>
                <para>Compute and return the area.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.GetKy">
            <summary>
                <para>Compute and return the weighting factors for the maximum unit normal component (MUNC).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.GetKx">
            <summary>
                <para>Compute and return the weighting factors for the maximum unit normal component (MUNC).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.GetVolumeZ">
            <summary>
                <para>Compute and return the weighting factors for the maximum unit normal component (MUNC).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.GetVolumeY">
            <summary>
                <para>Compute and return the volume projected on to each axis aligned plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.GetVolumeX">
            <summary>
                <para>Compute and return the volume projected on to each axis aligned plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMassProperties.GetVolume">
            <summary>
                <para>Compute and return the volume projected on to each axis aligned plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPCuts.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBSPCuts.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCursor3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCursor3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCursor3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCursor3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCursor3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCursor3D.AllOff">
            <summary>
                <para>Turn every part of the 3D cursor on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.AllOn">
            <summary>
                <para>Turn every part of the 3D cursor on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetFocus">
            <summary>
                <para>Get the focus for this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.WrapOff">
            <summary>
                <para>Turn on/off cursor wrapping. If the cursor focus moves outside the specified bounds, the cursor will either be restrained against the nearest "wall" (Wrap=off), or it will wrap around (Wrap=on).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.WrapOn">
            <summary>
                <para>Turn on/off cursor wrapping. If the cursor focus moves outside the specified bounds, the cursor will either be restrained against the nearest "wall" (Wrap=off), or it will wrap around (Wrap=on).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetWrap">
            <summary>
                <para>Turn on/off cursor wrapping. If the cursor focus moves outside the specified bounds, the cursor will either be restrained against the nearest "wall" (Wrap=off), or it will wrap around (Wrap=on).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetWrap(System.Int32)">
            <summary>
                <para>Turn on/off cursor wrapping. If the cursor focus moves outside the specified bounds, the cursor will either be restrained against the nearest "wall" (Wrap=off), or it will wrap around (Wrap=on).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.TranslationModeOff">
            <summary>
                <para>Enable/disable the translation mode. If on, changes in cursor position cause the entire widget to translate along with the cursor. By default, translation mode is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.TranslationModeOn">
            <summary>
                <para>Enable/disable the translation mode. If on, changes in cursor position cause the entire widget to translate along with the cursor. By default, translation mode is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetTranslationMode">
            <summary>
                <para>Enable/disable the translation mode. If on, changes in cursor position cause the entire widget to translate along with the cursor. By default, translation mode is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetTranslationMode(System.Int32)">
            <summary>
                <para>Enable/disable the translation mode. If on, changes in cursor position cause the entire widget to translate along with the cursor. By default, translation mode is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.ZShadowsOff">
            <summary>
                <para>Turn on/off the wireframe z-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.ZShadowsOn">
            <summary>
                <para>Turn on/off the wireframe z-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetZShadows">
            <summary>
                <para>Turn on/off the wireframe z-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetZShadows(System.Int32)">
            <summary>
                <para>Turn on/off the wireframe z-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.YShadowsOff">
            <summary>
                <para>Turn on/off the wireframe y-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.YShadowsOn">
            <summary>
                <para>Turn on/off the wireframe y-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetYShadows">
            <summary>
                <para>Turn on/off the wireframe y-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetYShadows(System.Int32)">
            <summary>
                <para>Turn on/off the wireframe y-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.XShadowsOff">
            <summary>
                <para>Turn on/off the wireframe x-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.XShadowsOn">
            <summary>
                <para>Turn on/off the wireframe x-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetXShadows">
            <summary>
                <para>Turn on/off the wireframe x-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetXShadows(System.Int32)">
            <summary>
                <para>Turn on/off the wireframe x-shadows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.AxesOff">
            <summary>
                <para>Turn on/off the wireframe axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.AxesOn">
            <summary>
                <para>Turn on/off the wireframe axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetAxes">
            <summary>
                <para>Turn on/off the wireframe axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetAxes(System.Int32)">
            <summary>
                <para>Turn on/off the wireframe axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.OutlineOff">
            <summary>
                <para>Turn on/off the wireframe bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.OutlineOn">
            <summary>
                <para>Turn on/off the wireframe bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetOutline">
            <summary>
                <para>Turn on/off the wireframe bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetOutline(System.Int32)">
            <summary>
                <para>Turn on/off the wireframe bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetFocalPoint">
            <summary>
                <para>Set/Get the position of cursor focus. If translation mode is on, then the entire cursor (including bounding box, cursor, and shadows) is translated. Otherwise, the focal point will either be clamped to the bounding box, or wrapped, if Wrap is on. (Note: this behavior requires that the bounding box is set prior to the focal point.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetFocalPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the position of cursor focus. If translation mode is on, then the entire cursor (including bounding box, cursor, and shadows) is translated. Otherwise, the focal point will either be clamped to the bounding box, or wrapped, if Wrap is on. (Note: this behavior requires that the bounding box is set prior to the focal point.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetFocalPoint(System.Double[])">
            <summary>
                <para>Set/Get the position of cursor focus. If translation mode is on, then the entire cursor (including bounding box, cursor, and shadows) is translated. Otherwise, the focal point will either be clamped to the bounding box, or wrapped, if Wrap is on. (Note: this behavior requires that the bounding box is set prior to the focal point.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.GetModelBounds">
            <summary>
                <para>Set / get the boundary of the 3D cursor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetModelBounds(System.Double[])">
            <summary>
                <para>Set / get the boundary of the 3D cursor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCursor3D.SetModelBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the boundary of the 3D cursor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAxes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAxes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAxes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAxes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAxes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAxes.ComputeNormalsOff">
            <summary>
                <para>Option for computing normals.  By default they are computed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.ComputeNormalsOn">
            <summary>
                <para>Option for computing normals.  By default they are computed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.GetComputeNormals">
            <summary>
                <para>Option for computing normals.  By default they are computed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.SetComputeNormals(System.Int32)">
            <summary>
                <para>Option for computing normals.  By default they are computed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.SymmetricOff">
            <summary>
                <para>If Symetric is on, the the axis continue to negative values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.SymmetricOn">
            <summary>
                <para>If Symetric is on, the the axis continue to negative values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.GetSymmetric">
            <summary>
                <para>If Symetric is on, the the axis continue to negative values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.SetSymmetric(System.Int32)">
            <summary>
                <para>If Symetric is on, the the axis continue to negative values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.GetScaleFactor">
            <summary>
                <para>Set the scale factor of the axes. Used to control size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.SetScaleFactor(System.Double)">
            <summary>
                <para>Set the scale factor of the axes. Used to control size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.GetOrigin">
            <summary>
                <para>Set the origin of the axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.SetOrigin(System.Double[])">
            <summary>
                <para>Set the origin of the axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxes.SetOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the origin of the axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.GetDashFactor">
            <summary>
                <para>For each dash, specify the fraction of the dash that is "on". A factor of 1.0 will result in a continuous line, a factor of 0.5 will result in  dashed that are half on and half off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.GetDashFactorMaxValue">
            <summary>
                <para>For each dash, specify the fraction of the dash that is "on". A factor of 1.0 will result in a continuous line, a factor of 0.5 will result in  dashed that are half on and half off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.GetDashFactorMinValue">
            <summary>
                <para>For each dash, specify the fraction of the dash that is "on". A factor of 1.0 will result in a continuous line, a factor of 0.5 will result in  dashed that are half on and half off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDashedStreamLine.SetDashFactor(System.Double)">
            <summary>
                <para>For each dash, specify the fraction of the dash that is "on". A factor of 1.0 will result in a continuous line, a factor of 0.5 will result in  dashed that are half on and half off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdNode.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkKdNode.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCleanPolyData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.OperateOnBounds(System.Double[],System.Double[])">
            <summary>
                <para>Perform operation on bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.OperateOnPoint(System.Double[],System.Double[])">
            <summary>
                <para>Perform operation on a point</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetMTime">
            <summary>
                <para>Get the MTime of this object also considering the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ReleaseLocator">
            <summary>
                <para>Release locator</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.CreateDefaultLocator(vtk.vtkPolyData)">
            <summary>
                <para>Create default locator. Used to create one when none is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetLocator">
            <summary>
                <para>Set/Get a spatial locator for speeding the search process. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set/Get a spatial locator for speeding the search process. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.PointMergingOff">
            <summary>
                <para>Set/Get a boolean value that controls whether point merging is performed. If on, a locator will be used, and points laying within  the appropriate tolerance may be merged. If off, points are never merged. By default, merging is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.PointMergingOn">
            <summary>
                <para>Set/Get a boolean value that controls whether point merging is performed. If on, a locator will be used, and points laying within  the appropriate tolerance may be merged. If off, points are never merged. By default, merging is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetPointMerging">
            <summary>
                <para>Set/Get a boolean value that controls whether point merging is performed. If on, a locator will be used, and points laying within  the appropriate tolerance may be merged. If off, points are never merged. By default, merging is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.SetPointMerging(System.Int32)">
            <summary>
                <para>Set/Get a boolean value that controls whether point merging is performed. If on, a locator will be used, and points laying within  the appropriate tolerance may be merged. If off, points are never merged. By default, merging is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetConvertStripsToPolys">
            <summary>
                <para>Turn on/off conversion of degenerate strips to polys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ConvertStripsToPolysOff">
            <summary>
                <para>Turn on/off conversion of degenerate strips to polys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ConvertStripsToPolysOn">
            <summary>
                <para>Turn on/off conversion of degenerate strips to polys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.SetConvertStripsToPolys(System.Int32)">
            <summary>
                <para>Turn on/off conversion of degenerate strips to polys</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetConvertPolysToLines">
            <summary>
                <para>Turn on/off conversion of degenerate polys to lines</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ConvertPolysToLinesOff">
            <summary>
                <para>Turn on/off conversion of degenerate polys to lines</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ConvertPolysToLinesOn">
            <summary>
                <para>Turn on/off conversion of degenerate polys to lines</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.SetConvertPolysToLines(System.Int32)">
            <summary>
                <para>Turn on/off conversion of degenerate polys to lines</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetConvertLinesToPoints">
            <summary>
                <para>Turn on/off conversion of degenerate lines to points</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ConvertLinesToPointsOff">
            <summary>
                <para>Turn on/off conversion of degenerate lines to points</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ConvertLinesToPointsOn">
            <summary>
                <para>Turn on/off conversion of degenerate lines to points</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.SetConvertLinesToPoints(System.Int32)">
            <summary>
                <para>Turn on/off conversion of degenerate lines to points</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetAbsoluteTolerance">
            <summary>
                <para>Specify tolerance in absolute terms</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetAbsoluteToleranceMaxValue">
            <summary>
                <para>Specify tolerance in absolute terms</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetAbsoluteToleranceMinValue">
            <summary>
                <para>Specify tolerance in absolute terms</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.SetAbsoluteTolerance(System.Double)">
            <summary>
                <para>Specify tolerance in absolute terms</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetTolerance">
            <summary>
                <para>Specify tolerance in terms of fraction of bounding box length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetToleranceMaxValue">
            <summary>
                <para>Specify tolerance in terms of fraction of bounding box length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetToleranceMinValue">
            <summary>
                <para>Specify tolerance in terms of fraction of bounding box length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.SetTolerance(System.Double)">
            <summary>
                <para>Specify tolerance in terms of fraction of bounding box length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.GetToleranceIsAbsolute">
            <summary>
                <para>By default ToleranceIsAbsolute is false and Tolerance is a fraction of Bounding box diagonal, if true, AbsoluteTolerance is used when adding points to locator (merging)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ToleranceIsAbsoluteOff">
            <summary>
                <para>By default ToleranceIsAbsolute is false and Tolerance is a fraction of Bounding box diagonal, if true, AbsoluteTolerance is used when adding points to locator (merging)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.ToleranceIsAbsoluteOn">
            <summary>
                <para>By default ToleranceIsAbsolute is false and Tolerance is a fraction of Bounding box diagonal, if true, AbsoluteTolerance is used when adding points to locator (merging)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCleanPolyData.SetToleranceIsAbsolute(System.Int32)">
            <summary>
                <para>By default ToleranceIsAbsolute is false and Tolerance is a fraction of Bounding box diagonal, if true, AbsoluteTolerance is used when adding points to locator (merging)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.ExtractToFieldDataOff">
            <summary>
                <para>Determines whether the vector components will be put in separate outputs or in the first output's field data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.ExtractToFieldDataOn">
            <summary>
                <para>Determines whether the vector components will be put in separate outputs or in the first output's field data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.GetExtractToFieldData">
            <summary>
                <para>Determines whether the vector components will be put in separate outputs or in the first output's field data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.SetExtractToFieldData(System.Int32)">
            <summary>
                <para>Determines whether the vector components will be put in separate outputs or in the first output's field data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.GetVzComponent">
            <summary>
                <para>Get the output dataset representing velocity z-component. If output is NULL then input hasn't been set, which is necessary for abstract objects. (Note: this method returns the same information as the GetOutput() method with an index of 2.) Note that if ExtractToFieldData is true, this output will be empty.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.GetVyComponent">
            <summary>
                <para>Get the output dataset representing velocity y-component. If output is NULL then input hasn't been set, which is necessary for abstract objects. (Note: this method returns the same information as the GetOutput() method with an index of 1.) Note that if ExtractToFieldData is true, this output will be empty.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.GetVxComponent">
            <summary>
                <para>Get the output dataset representing velocity x-component. If output is NULL then input hasn't been set, which is necessary for abstract objects. (Note: this method returns the same information as the GetOutput() method with an index of 0.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractVectorComponents.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Specify the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVisibilitySort.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Overwritten to enable garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Overwritten to enable garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.SetDirectionToFrontToBack">
            <summary>
                <para>Overwritten to enable garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.SetDirectionToBackToFront">
            <summary>
                <para>Set/Get the sorting direction.  Be default, the direction is set to back to front.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.SetDirection(System.Int32)">
            <summary>
                <para>Set/Get the sorting direction.  Be default, the direction is set to back to front.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.GetDirection">
            <summary>
                <para>Set/Get the sorting direction.  Be default, the direction is set to back to front.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.GetInput">
            <summary>
                <para>Set/Get the data set containing the cells to sort.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set/Get the data set containing the cells to sort.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.GetModelTransform">
            <summary>
                <para>Set/Get the matrix that transforms from object space to world space. Generally, you get this matrix from a call to GetMatrix of a vtkProp3D (vtkActor).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.SetModelTransform(vtk.vtkMatrix4x4)">
            <summary>
                <para>Set/Get the matrix that transforms from object space to world space. Generally, you get this matrix from a call to GetMatrix of a vtkProp3D (vtkActor).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.GetMaxCellsReturned">
            <summary>
                <para>Set/Get the maximum number of cells that GetNextCells will return in one invocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.GetMaxCellsReturnedMaxValue">
            <summary>
                <para>Set/Get the maximum number of cells that GetNextCells will return in one invocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.GetMaxCellsReturnedMinValue">
            <summary>
                <para>Set/Get the maximum number of cells that GetNextCells will return in one invocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.SetMaxCellsReturned(System.Int32)">
            <summary>
                <para>Set/Get the maximum number of cells that GetNextCells will return in one invocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.GetNextCells">
            <summary>
                <para>To facilitate incremental sorting algorithms, the cells are retrieved in an iteration process.  That is, call InitTraversal to start the iteration and call GetNextCells to get the cell IDs in order. However, for efficiencies sake, GetNextCells returns an ordered list of several id's in once call (but not necessarily all).  GetNextCells will return NULL once the entire sorted list is output.  The vtkIdTypeArray returned from GetNextCells is a cached array, so do not delete it.  At the same note, do not expect the array to be valid after subsequent calls to GetNextCells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVisibilitySort.InitTraversal">
            <summary>
                <para>To facilitate incremental sorting algorithms, the cells are retrieved in an iteration process.  That is, call InitTraversal to start the iteration and call GetNextCells to get the cell IDs in order. However, for efficiencies sake, GetNextCells returns an ordered list of several id's in once call (but not necessarily all).  GetNextCells will return NULL once the entire sorted list is output.  The vtkIdTypeArray returned from GetNextCells is a cached array, so do not delete it.  At the same note, do not expect the array to be valid after subsequent calls to GetNextCells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.PassPointDataOff">
            <summary>
                <para>Control whether the input point data is to be passed to the output. If on, then the input point data is passed through to the output; otherwise, only generated point data is placed into the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.PassPointDataOn">
            <summary>
                <para>Control whether the input point data is to be passed to the output. If on, then the input point data is passed through to the output; otherwise, only generated point data is placed into the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.GetPassPointData">
            <summary>
                <para>Control whether the input point data is to be passed to the output. If on, then the input point data is passed through to the output; otherwise, only generated point data is placed into the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointDataToCellData.SetPassPointData(System.Int32)">
            <summary>
                <para>Control whether the input point data is to be passed to the output. If on, then the input point data is passed through to the output; otherwise, only generated point data is placed into the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToThickArrow">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToArrow">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToDiamond">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToCircle">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToSquare">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToTriangle">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToThickCross">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToCross">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToDash">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToVertex">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphTypeToNone">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetGlyphType">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetGlyphTypeMaxValue">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetGlyphTypeMinValue">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetGlyphType(System.Int32)">
            <summary>
                <para>Specify the type of glyph to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetRotationAngle">
            <summary>
                <para>Specify an angle (in degrees) to rotate the glyph around the z-axis. Using this ivar, it is possible to generate rotated glyphs (e.g., crosses, arrows, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetRotationAngle(System.Double)">
            <summary>
                <para>Specify an angle (in degrees) to rotate the glyph around the z-axis. Using this ivar, it is possible to generate rotated glyphs (e.g., crosses, arrows, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.CrossOff">
            <summary>
                <para>Specify whether a cross is drawn as part of the glyph. (This  is in addition to the glyph. If the glyph type is set to  "Cross" there is no need to enable this flag.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.CrossOn">
            <summary>
                <para>Specify whether a cross is drawn as part of the glyph. (This  is in addition to the glyph. If the glyph type is set to  "Cross" there is no need to enable this flag.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetCross">
            <summary>
                <para>Specify whether a cross is drawn as part of the glyph. (This  is in addition to the glyph. If the glyph type is set to  "Cross" there is no need to enable this flag.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetCross(System.Int32)">
            <summary>
                <para>Specify whether a cross is drawn as part of the glyph. (This  is in addition to the glyph. If the glyph type is set to  "Cross" there is no need to enable this flag.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.DashOff">
            <summary>
                <para>Specify whether a short line segment is drawn through the glyph. (This is in addition to the glyph. If the glyph type is set to "Dash" there is no need to enable this flag.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.DashOn">
            <summary>
                <para>Specify whether a short line segment is drawn through the glyph. (This is in addition to the glyph. If the glyph type is set to "Dash" there is no need to enable this flag.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetDash">
            <summary>
                <para>Specify whether a short line segment is drawn through the glyph. (This is in addition to the glyph. If the glyph type is set to "Dash" there is no need to enable this flag.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetDash(System.Int32)">
            <summary>
                <para>Specify whether a short line segment is drawn through the glyph. (This is in addition to the glyph. If the glyph type is set to "Dash" there is no need to enable this flag.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.FilledOff">
            <summary>
                <para>Specify whether the glyph is filled (a polygon) or not (a closed polygon defined by line segments). This only applies to 2D closed glyphs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.FilledOn">
            <summary>
                <para>Specify whether the glyph is filled (a polygon) or not (a closed polygon defined by line segments). This only applies to 2D closed glyphs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetFilled">
            <summary>
                <para>Specify whether the glyph is filled (a polygon) or not (a closed polygon defined by line segments). This only applies to 2D closed glyphs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetFilled(System.Int32)">
            <summary>
                <para>Specify whether the glyph is filled (a polygon) or not (a closed polygon defined by line segments). This only applies to 2D closed glyphs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetColor">
            <summary>
                <para>Set the color of the glyph. The default color is white.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetColor(System.Double[])">
            <summary>
                <para>Set the color of the glyph. The default color is white.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the color of the glyph. The default color is white.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetScale2">
            <summary>
                <para>Set the scale of optional portions of the glyph (e.g., the dash and cross is DashOn() and CrossOn()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetScale2MaxValue">
            <summary>
                <para>Set the scale of optional portions of the glyph (e.g., the dash and cross is DashOn() and CrossOn()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetScale2MinValue">
            <summary>
                <para>Set the scale of optional portions of the glyph (e.g., the dash and cross is DashOn() and CrossOn()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetScale2(System.Double)">
            <summary>
                <para>Set the scale of optional portions of the glyph (e.g., the dash and cross is DashOn() and CrossOn()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetScale">
            <summary>
                <para>Set the scale of the glyph. Note that the glyphs are designed to fit in the (1,1) rectangle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetScaleMaxValue">
            <summary>
                <para>Set the scale of the glyph. Note that the glyphs are designed to fit in the (1,1) rectangle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetScaleMinValue">
            <summary>
                <para>Set the scale of the glyph. Note that the glyphs are designed to fit in the (1,1) rectangle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetScale(System.Double)">
            <summary>
                <para>Set the scale of the glyph. Note that the glyphs are designed to fit in the (1,1) rectangle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.GetCenter">
            <summary>
                <para>Set the center of the glyph. By default the center is (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetCenter(System.Double[])">
            <summary>
                <para>Set the center of the glyph. By default the center is (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyphSource2D.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the center of the glyph. By default the center is (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMeshQuality.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.CompatibilityModeOff">
            <summary>
                <para>CompatibilityMode governs whether, when both a quality measure and cell volume are to be stored as cell data, the two values are stored in a single array. When compatibility mode is off (the default), two separate arrays are used -- one labeled "Quality" and the other labeled "Volume". When compatibility mode is on, both values are stored in a single array, with volume as the first component and quality as the second component.</para>
                <para>Enabling CompatibilityMode changes the default tetrahedral quality measure to VTK_QUALITY_RADIUS_RATIO and turns volume computation on. (This matches the default behavior of the initial implementation of vtkMeshQuality.) You may change quality measure and volume computation without leaving compatibility mode.</para>
                <para>Disabling compatibility mode does not affect the current volume computation or tetrahedral quality measure settings. </para>
                <para>The final caveat to CompatibilityMode is that regardless of its setting, the resulting array will be of type vtkDoubleArray rather than the original vtkFloatArray. This is a safety measure to keep the authors from diving off of the Combinatorial Coding Cliff into Certain Insanity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.CompatibilityModeOn">
            <summary>
                <para>CompatibilityMode governs whether, when both a quality measure and cell volume are to be stored as cell data, the two values are stored in a single array. When compatibility mode is off (the default), two separate arrays are used -- one labeled "Quality" and the other labeled "Volume". When compatibility mode is on, both values are stored in a single array, with volume as the first component and quality as the second component.</para>
                <para>Enabling CompatibilityMode changes the default tetrahedral quality measure to VTK_QUALITY_RADIUS_RATIO and turns volume computation on. (This matches the default behavior of the initial implementation of vtkMeshQuality.) You may change quality measure and volume computation without leaving compatibility mode.</para>
                <para>Disabling compatibility mode does not affect the current volume computation or tetrahedral quality measure settings. </para>
                <para>The final caveat to CompatibilityMode is that regardless of its setting, the resulting array will be of type vtkDoubleArray rather than the original vtkFloatArray. This is a safety measure to keep the authors from diving off of the Combinatorial Coding Cliff into Certain Insanity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.GetCompatibilityMode">
            <summary>
                <para>CompatibilityMode governs whether, when both a quality measure and cell volume are to be stored as cell data, the two values are stored in a single array. When compatibility mode is off (the default), two separate arrays are used -- one labeled "Quality" and the other labeled "Volume". When compatibility mode is on, both values are stored in a single array, with volume as the first component and quality as the second component.</para>
                <para>Enabling CompatibilityMode changes the default tetrahedral quality measure to VTK_QUALITY_RADIUS_RATIO and turns volume computation on. (This matches the default behavior of the initial implementation of vtkMeshQuality.) You may change quality measure and volume computation without leaving compatibility mode.</para>
                <para>Disabling compatibility mode does not affect the current volume computation or tetrahedral quality measure settings. </para>
                <para>The final caveat to CompatibilityMode is that regardless of its setting, the resulting array will be of type vtkDoubleArray rather than the original vtkFloatArray. This is a safety measure to keep the authors from diving off of the Combinatorial Coding Cliff into Certain Insanity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetCompatibilityMode(System.Int32)">
            <summary>
                <para>CompatibilityMode governs whether, when both a quality measure and cell volume are to be stored as cell data, the two values are stored in a single array. When compatibility mode is off (the default), two separate arrays are used -- one labeled "Quality" and the other labeled "Volume". When compatibility mode is on, both values are stored in a single array, with volume as the first component and quality as the second component.</para>
                <para>Enabling CompatibilityMode changes the default tetrahedral quality measure to VTK_QUALITY_RADIUS_RATIO and turns volume computation on. (This matches the default behavior of the initial implementation of vtkMeshQuality.) You may change quality measure and volume computation without leaving compatibility mode.</para>
                <para>Disabling compatibility mode does not affect the current volume computation or tetrahedral quality measure settings. </para>
                <para>The final caveat to CompatibilityMode is that regardless of its setting, the resulting array will be of type vtkDoubleArray rather than the original vtkFloatArray. This is a safety measure to keep the authors from diving off of the Combinatorial Coding Cliff into Certain Insanity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.VolumeOff">
            <summary>
                <para>These methods are deprecated. The functionality of computing cell volume is being removed until it can be computed for any 3D cell. (The previous implementation only worked for tetrahedra.)</para>
                <para>For now, turning on the volume computation will put this filter into "compatibility mode," where tetrahedral cell volume is stored in first component of each output tuple and the radius ratio is stored in the second component. You may also use CompatibilityModeOn()/Off() to enter this mode. In this mode, cells other than tetrahedra will have report a volume of 0.0 (if volume computation is enabled).</para>
                <para>By default, volume computation is disabled and compatibility mode is off, since it does not make a lot of sense for meshes with non-tetrahedral cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.VolumeOn">
            <summary>
                <para>These methods are deprecated. The functionality of computing cell volume is being removed until it can be computed for any 3D cell. (The previous implementation only worked for tetrahedra.)</para>
                <para>For now, turning on the volume computation will put this filter into "compatibility mode," where tetrahedral cell volume is stored in first component of each output tuple and the radius ratio is stored in the second component. You may also use CompatibilityModeOn()/Off() to enter this mode. In this mode, cells other than tetrahedra will have report a volume of 0.0 (if volume computation is enabled).</para>
                <para>By default, volume computation is disabled and compatibility mode is off, since it does not make a lot of sense for meshes with non-tetrahedral cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.GetVolume">
            <summary>
                <para>These methods are deprecated. The functionality of computing cell volume is being removed until it can be computed for any 3D cell. (The previous implementation only worked for tetrahedra.)</para>
                <para>For now, turning on the volume computation will put this filter into "compatibility mode," where tetrahedral cell volume is stored in first component of each output tuple and the radius ratio is stored in the second component. You may also use CompatibilityModeOn()/Off() to enter this mode. In this mode, cells other than tetrahedra will have report a volume of 0.0 (if volume computation is enabled).</para>
                <para>By default, volume computation is disabled and compatibility mode is off, since it does not make a lot of sense for meshes with non-tetrahedral cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetVolume(System.Int32)">
            <summary>
                <para>These methods are deprecated. The functionality of computing cell volume is being removed until it can be computed for any 3D cell. (The previous implementation only worked for tetrahedra.)</para>
                <para>For now, turning on the volume computation will put this filter into "compatibility mode," where tetrahedral cell volume is stored in first component of each output tuple and the radius ratio is stored in the second component. You may also use CompatibilityModeOn()/Off() to enter this mode. In this mode, cells other than tetrahedra will have report a volume of 0.0 (if volume computation is enabled).</para>
                <para>By default, volume computation is disabled and compatibility mode is off, since it does not make a lot of sense for meshes with non-tetrahedral cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.RatioOff">
            <summary>
                <para>These methods are deprecated. Use Get/SetSaveCellQuality() instead.</para>
                <para>Formerly, SetRatio could be used to disable computation of the tetrahedral radius ratio so that volume alone could be computed. Now, cell quality is always computed, but you may decide not to store the result for each cell. This allows average cell quality of a mesh to be calculated without requiring per-cell storage.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.RatioOn">
            <summary>
                <para>These methods are deprecated. Use Get/SetSaveCellQuality() instead.</para>
                <para>Formerly, SetRatio could be used to disable computation of the tetrahedral radius ratio so that volume alone could be computed. Now, cell quality is always computed, but you may decide not to store the result for each cell. This allows average cell quality of a mesh to be calculated without requiring per-cell storage.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.GetRatio">
            <summary>
                <para>These methods are deprecated. Use Get/SetSaveCellQuality() instead.</para>
                <para>Formerly, SetRatio could be used to disable computation of the tetrahedral radius ratio so that volume alone could be computed. Now, cell quality is always computed, but you may decide not to store the result for each cell. This allows average cell quality of a mesh to be calculated without requiring per-cell storage.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetRatio(System.Int32)">
            <summary>
                <para>These methods are deprecated. Use Get/SetSaveCellQuality() instead.</para>
                <para>Formerly, SetRatio could be used to disable computation of the tetrahedral radius ratio so that volume alone could be computed. Now, cell quality is always computed, but you may decide not to store the result for each cell. This allows average cell quality of a mesh to be calculated without requiring per-cell storage.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.HexEdgeRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the edge ratio of a hexahedron. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The edge ratio of a tetrahedron \f$H\f$ is:  \f$\frac{|H|_\infty}{|H|_0}\f$, where \f$|H|_\infty\f$ and \f$|H|_0\f$ respectively denote the greatest and the smallest edge lengths of \f$H\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TetMinAngle(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the minimal (nonoriented) dihedral angle of a tetrahedron, expressed in degrees. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TetFrobeniusNorm(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the Frobenius norm of a tetrahedron when the reference element is regular. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The Frobenius norm of a tetrahedron \f$K\f$, when the reference element is  regular, is:  \f$\frac{\frac{3}{2}(l_{11}+l_{22}+l_{33}) - (l_{12}+l_{13}+l_{23})} {3(\sqrt{2}\det{T})^\frac{2}{3}}\f$, where \f$T\f$ and \f$l_{ij}\f$ respectively denote the edge matrix of \f$K\f$ and the entries of \f$L=T^t\,T\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TetRadiusRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the radius ratio of a tetrahedron. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The radius ratio of a tetrahedron \f$K\f$ is:  \f$\frac{R}{3r}\f$, where \f$R\f$ and \f$r\f$ respectively denote the circumradius and  the inradius of \f$K\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TetAspectRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the aspect ratio of a tetrahedron. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The aspect ratio of a tetrahedron \f$K\f$ is:  \f$\frac{|K|_\infty}{2\sqrt{6}r}\f$, where \f$|K|_\infty\f$ and \f$r\f$ respectively denote the greatest edge  length and the inradius of \f$K\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TetEdgeRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the edge ratio of a tetrahedron. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The edge ratio of a tetrahedron \f$K\f$ is:  \f$\frac{|K|_\infty}{|K|_0}\f$, where \f$|K|_\infty\f$ and \f$|K|_0\f$ respectively denote the greatest and the smallest edge lengths of \f$K\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.QuadMinAngle(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the minimal (nonoriented) angle of a quadrilateral, expressed in degrees. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.QuadMaxFrobeniusNorm(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the maximal Frobenius norm of the 4 triangles extractable from a planar quadrilateral, when the reference  triangle elements are right isosceles at the quadrangle vertices. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. Use at your own risk with nonplanar quadrilaterals. The Frobenius norm of a triangle \f$t\f$, when the reference element is  right isosceles at vertex \f$V\f$, is:  \f$\frac{f^2+g^2}{4{\cal A}}\f$, where \f$f^2+g^2\f$ and \f$\cal A\f$ respectively denote the sum of the  squared lengths of the edges attached to \f$V\f$ and the area of \f$t\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.QuadMedFrobeniusNorm(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the average Frobenius norm of the 4 triangles extractable from a planar quadrilateral, when the reference  triangle elements are right isosceles at the quadrangle vertices. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. Use at your own risk with nonplanar quadrilaterals. The Frobenius norm of a triangle \f$t\f$, when the reference element is  right isosceles at vertex \f$V\f$, is:  \f$\frac{f^2+g^2}{4{\cal A}}\f$, where \f$f^2+g^2\f$ and \f$\cal A\f$ respectively denote the sum of the  squared lengths of the edges attached to \f$V\f$ and the area of \f$t\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.QuadRadiusRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the radius ratio of a planar  quadrilateral. The name is only used by analogy with the triangle radius  ratio, because in general a quadrilateral does not have a circumcircle nor an incircle.  It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. Use at your own risk with nonplanar quadrilaterals. The radius ratio of a planar quadrilateral \f$q\f$ is:  \f$\frac{|q|_2h_{\max}}{\min_i{\cal A}_i}\f$, where \f$|q|_2\f$, \f$h_{\max}\f$ and \f$\min{\cal A}_i\f$ respectively denote  the sum of the squared edge lengths, the greatest amongst diagonal and edge  lengths and the smallest area of the 4 triangles extractable from \f$q\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.QuadAspectRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the aspect ratio of a planar  quadrilateral. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. Use at your own risk with nonplanar quadrilaterals. The aspect ratio of a planar quadrilateral \f$q\f$ is:  \f$\frac{|q|_1|q|_\infty}{4{\cal A}}\f$, where \f$|q|_1\f$, $|q|_\infty\f$ and \f${\cal A}\f$ respectively denote the  perimeter, the greatest edge length and the area of \f$q\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.QuadEdgeRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the edge ratio of a quadrilateral. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The edge ratio of a quadrilateral \f$q\f$ is:  \f$\frac{|q|_\infty}{|q|_0}\f$, where \f$|q|_\infty\f$ and \f$|q|_0\f$ respectively denote the greatest and the smallest edge lengths of \f$q\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TriangleMinAngle(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the minimal (nonoriented) angle of a triangle, expressed in degrees. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TriangleFrobeniusNorm(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the Frobenius norm of a triangle when the reference element is equilateral. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The Frobenius norm of a triangle \f$t\f$, when the reference element is  equilateral, is:  \f$\frac{|t|^2_2}{2\sqrt{3}{\cal A}}\f$, where \f$|t|^2_2\f$ and \f$\cal A\f$ respectively denote the sum of the  squared edge lengths and the area of \f$t\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TriangleRadiusRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the radius ratio of a triangle. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The radius ratio of a triangle \f$t\f$ is:  \f$\frac{R}{2r}\f$, where \f$R\f$ and \f$r\f$ respectively denote the circumradius and  the inradius of \f$t\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TriangleAspectRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the aspect ratio of a triangle. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The aspect ratio of a triangle \f$t\f$ is:  \f$\frac{|t|_\infty}{2\sqrt{3}r}\f$, where \f$|t|_\infty\f$ and \f$r\f$ respectively denote the greatest edge  length and the inradius of \f$t\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.TriangleEdgeRatio(vtk.vtkCell)">
            <summary>
                <para>This is a static function used to calculate the edge ratio of a triangle. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The edge ratio of a triangle \f$t\f$ is:  \f$\frac{|t|_\infty}{|t|_0}\f$, where \f$|t|_\infty\f$ and \f$|t|_0\f$ respectively denote the greatest and the smallest edge lengths of \f$t\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetHexQualityMeasureToEdgeRatio">
            <summary>
                <para>This is a static function used to calculate the edge ratio of a triangle. It assumes that you pass the correct type of cell -- no type checking is performed because this method is called from the inner loop of the Execute() member function. The edge ratio of a triangle \f$t\f$ is:  \f$\frac{|t|_\infty}{|t|_0}\f$, where \f$|t|_\infty\f$ and \f$|t|_0\f$ respectively denote the greatest and the smallest edge lengths of \f$t\f$.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.GetHexQualityMeasure">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of hexahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetHexQualityMeasure(System.Int32)">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of hexahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTetQualityMeasureToMinAngle">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of hexahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTetQualityMeasureToFrobeniusNorm">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of tetrahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTetQualityMeasureToRadiusRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of tetrahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTetQualityMeasureToAspectRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of tetrahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTetQualityMeasureToEdgeRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of tetrahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.GetTetQualityMeasure">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of tetrahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTetQualityMeasure(System.Int32)">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of tetrahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetQuadQualityMeasureToMinAngle">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of tetrahedra. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetQuadQualityMeasureToMaxFrobeniusNorm">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of quadrilaterals. The default is VTK_QUALITY_EDGE_RATIO and valid values also include VTK_QUALITY_RADIUS_RATIO and VTK_QUALITY_ASPECT_RATIO. Scope: Except for VTK_QUALITY_EDGE_RATIO, these estimators are intended for planar quadrilaterals only; use at your own risk if you really want to assess non-planar quadrilateral quality with those.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetQuadQualityMeasureToMedFrobeniusNorm">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of quadrilaterals. The default is VTK_QUALITY_EDGE_RATIO and valid values also include VTK_QUALITY_RADIUS_RATIO and VTK_QUALITY_ASPECT_RATIO. Scope: Except for VTK_QUALITY_EDGE_RATIO, these estimators are intended for planar quadrilaterals only; use at your own risk if you really want to assess non-planar quadrilateral quality with those.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetQuadQualityMeasureToRadiusRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of quadrilaterals. The default is VTK_QUALITY_EDGE_RATIO and valid values also include VTK_QUALITY_RADIUS_RATIO and VTK_QUALITY_ASPECT_RATIO. Scope: Except for VTK_QUALITY_EDGE_RATIO, these estimators are intended for planar quadrilaterals only; use at your own risk if you really want to assess non-planar quadrilateral quality with those.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetQuadQualityMeasureToAspectRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of quadrilaterals. The default is VTK_QUALITY_EDGE_RATIO and valid values also include VTK_QUALITY_RADIUS_RATIO and VTK_QUALITY_ASPECT_RATIO. Scope: Except for VTK_QUALITY_EDGE_RATIO, these estimators are intended for planar quadrilaterals only; use at your own risk if you really want to assess non-planar quadrilateral quality with those.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetQuadQualityMeasureToEdgeRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of quadrilaterals. The default is VTK_QUALITY_EDGE_RATIO and valid values also include VTK_QUALITY_RADIUS_RATIO and VTK_QUALITY_ASPECT_RATIO. Scope: Except for VTK_QUALITY_EDGE_RATIO, these estimators are intended for planar quadrilaterals only; use at your own risk if you really want to assess non-planar quadrilateral quality with those.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.GetQuadQualityMeasure">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of quadrilaterals. The default is VTK_QUALITY_EDGE_RATIO and valid values also include VTK_QUALITY_RADIUS_RATIO and VTK_QUALITY_ASPECT_RATIO. Scope: Except for VTK_QUALITY_EDGE_RATIO, these estimators are intended for planar quadrilaterals only; use at your own risk if you really want to assess non-planar quadrilateral quality with those.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetQuadQualityMeasure(System.Int32)">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of quadrilaterals. The default is VTK_QUALITY_EDGE_RATIO and valid values also include VTK_QUALITY_RADIUS_RATIO and VTK_QUALITY_ASPECT_RATIO. Scope: Except for VTK_QUALITY_EDGE_RATIO, these estimators are intended for planar quadrilaterals only; use at your own risk if you really want to assess non-planar quadrilateral quality with those.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTriangleQualityMeasureToMinAngle">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of quadrilaterals. The default is VTK_QUALITY_EDGE_RATIO and valid values also include VTK_QUALITY_RADIUS_RATIO and VTK_QUALITY_ASPECT_RATIO. Scope: Except for VTK_QUALITY_EDGE_RATIO, these estimators are intended for planar quadrilaterals only; use at your own risk if you really want to assess non-planar quadrilateral quality with those.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTriangleQualityMeasureToFrobeniusNorm">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of triangles. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTriangleQualityMeasureToRadiusRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of triangles. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTriangleQualityMeasureToAspectRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of triangles. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTriangleQualityMeasureToEdgeRatio">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of triangles. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.GetTriangleQualityMeasure">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of triangles. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetTriangleQualityMeasure(System.Int32)">
            <summary>
                <para>Set/Get the particular estimator used to measure the quality of triangles. The default is VTK_QUALITY_RADIUS_RATIO and valid values also include VTK_QUALITY_ASPECT_RATIO, VTK_QUALITY_FROBENIUS_NORM, and VTK_QUALITY_EDGE_RATIO.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SaveCellQualityOff">
            <summary>
                <para>This variable controls whether or not cell quality is stored as cell data in the resulting mesh or discarded (leaving only the aggregate quality average of the entire mesh, recorded in the FieldData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SaveCellQualityOn">
            <summary>
                <para>This variable controls whether or not cell quality is stored as cell data in the resulting mesh or discarded (leaving only the aggregate quality average of the entire mesh, recorded in the FieldData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.GetSaveCellQuality">
            <summary>
                <para>This variable controls whether or not cell quality is stored as cell data in the resulting mesh or discarded (leaving only the aggregate quality average of the entire mesh, recorded in the FieldData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMeshQuality.SetSaveCellQuality(System.Int32)">
            <summary>
                <para>This variable controls whether or not cell quality is stored as cell data in the resulting mesh or discarded (leaving only the aggregate quality average of the entire mesh, recorded in the FieldData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProgrammableSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProgrammableSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableSource.GetRectilinearGridOutput">
            <summary>
                <para>Get the output as a concrete type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableSource.GetUnstructuredGridOutput">
            <summary>
                <para>Get the output as a concrete type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableSource.GetStructuredGridOutput">
            <summary>
                <para>Get the output as a concrete type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableSource.GetStructuredPointsOutput">
            <summary>
                <para>Get the output as a concrete type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableSource.GetPolyDataOutput">
            <summary>
                <para>Get the output as a concrete type. This method is typically used by the writer of the source function to get the output as a particular type (i.e., it essentially does type casting). It is the users responsibility to know the correct type of the output data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.GetPieceInvariant">
            <summary>
                <para>If PieceInvariant is true, vtkDataSetSurfaceFilter requests 1 ghost level from input in order to remove internal surface that are between processes. False by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.SetPieceInvariant(System.Int32)">
            <summary>
                <para>If PieceInvariant is true, vtkDataSetSurfaceFilter requests 1 ghost level from input in order to remove internal surface that are between processes. False by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.UseStripsOff">
            <summary>
                <para>When input is structured data, this flag will generate faces with triangle strips.  This should render faster and use less memory, but no cell data is copied.  By default, UseStrips is Off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.UseStripsOn">
            <summary>
                <para>When input is structured data, this flag will generate faces with triangle strips.  This should render faster and use less memory, but no cell data is copied.  By default, UseStrips is Off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.GetUseStrips">
            <summary>
                <para>When input is structured data, this flag will generate faces with triangle strips.  This should render faster and use less memory, but no cell data is copied.  By default, UseStrips is Off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetSurfaceFilter.SetUseStrips(System.Int32)">
            <summary>
                <para>When input is structured data, this flag will generate faces with triangle strips.  This should render faster and use less memory, but no cell data is copied.  By default, UseStrips is Off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.GetShrinkFactor">
            <summary>
                <para>Get the fraction of shrink for each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.GetShrinkFactorMaxValue">
            <summary>
                <para>Set the fraction of shrink for each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.GetShrinkFactorMinValue">
            <summary>
                <para>Set the fraction of shrink for each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShrinkPolyData.SetShrinkFactor(System.Double)">
            <summary>
                <para>Set the fraction of shrink for each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamLine.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStreamLine.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStreamLine.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStreamLine.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStreamLine.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStreamLine.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStreamLine.GetStepLength">
            <summary>
                <para>Specify the length of a line segment. The length is expressed in terms of elapsed time. Smaller values result in smoother appearing streamlines, but greater numbers of line primitives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamLine.GetStepLengthMaxValue">
            <summary>
                <para>Specify the length of a line segment. The length is expressed in terms of elapsed time. Smaller values result in smoother appearing streamlines, but greater numbers of line primitives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamLine.GetStepLengthMinValue">
            <summary>
                <para>Specify the length of a line segment. The length is expressed in terms of elapsed time. Smaller values result in smoother appearing streamlines, but greater numbers of line primitives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamLine.SetStepLength(System.Double)">
            <summary>
                <para>Specify the length of a line segment. The length is expressed in terms of elapsed time. Smaller values result in smoother appearing streamlines, but greater numbers of line primitives.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStreamer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStreamer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStreamer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetIntegrator">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance by each thread/process in the process of integration (prototype pattern). The default is  2nd order Runge Kutta.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetIntegrator(vtk.vtkInitialValueProblemSolver)">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance by each thread/process in the process of integration (prototype pattern). The default is  2nd order Runge Kutta.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.VorticityOff">
            <summary>
                <para>Turn on/off the computation of vorticity. Vorticity is an indication of the rotation of the flow. In combination with vtkStreamLine and  vtkTubeFilter can be used to create rotated tubes.  If vorticity is turned on, in the output, the velocity vectors  are replaced by vorticity vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.VorticityOn">
            <summary>
                <para>Turn on/off the computation of vorticity. Vorticity is an indication of the rotation of the flow. In combination with vtkStreamLine and  vtkTubeFilter can be used to create rotated tubes.  If vorticity is turned on, in the output, the velocity vectors  are replaced by vorticity vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetVorticity">
            <summary>
                <para>Turn on/off the computation of vorticity. Vorticity is an indication of the rotation of the flow. In combination with vtkStreamLine and  vtkTubeFilter can be used to create rotated tubes.  If vorticity is turned on, in the output, the velocity vectors  are replaced by vorticity vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetVorticity(System.Int32)">
            <summary>
                <para>Turn on/off the computation of vorticity. Vorticity is an indication of the rotation of the flow. In combination with vtkStreamLine and  vtkTubeFilter can be used to create rotated tubes.  If vorticity is turned on, in the output, the velocity vectors  are replaced by vorticity vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetTerminalSpeed">
            <summary>
                <para>Set/get terminal speed (i.e., speed is velocity magnitude).  Terminal  speed is speed at which streamer will terminate propagation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetTerminalSpeedMaxValue">
            <summary>
                <para>Set/get terminal speed (i.e., speed is velocity magnitude).  Terminal  speed is speed at which streamer will terminate propagation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetTerminalSpeedMinValue">
            <summary>
                <para>Set/get terminal speed (i.e., speed is velocity magnitude).  Terminal  speed is speed at which streamer will terminate propagation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetTerminalSpeed(System.Double)">
            <summary>
                <para>Set/get terminal speed (i.e., speed is velocity magnitude).  Terminal  speed is speed at which streamer will terminate propagation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.OrientationScalarsOff">
            <summary>
                <para>Turn on/off the creation of scalar data from vorticity information.  The scalar information is currently the orientation value "theta" used in rotating stream tubes. If off, and input dataset has scalars, then input dataset scalars are used, unless SpeedScalars is also on. SpeedScalars takes precedence over OrientationScalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.OrientationScalarsOn">
            <summary>
                <para>Turn on/off the creation of scalar data from vorticity information.  The scalar information is currently the orientation value "theta" used in rotating stream tubes. If off, and input dataset has scalars, then input dataset scalars are used, unless SpeedScalars is also on. SpeedScalars takes precedence over OrientationScalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetOrientationScalars">
            <summary>
                <para>Turn on/off the creation of scalar data from vorticity information.  The scalar information is currently the orientation value "theta" used in rotating stream tubes. If off, and input dataset has scalars, then input dataset scalars are used, unless SpeedScalars is also on. SpeedScalars takes precedence over OrientationScalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetOrientationScalars(System.Int32)">
            <summary>
                <para>Turn on/off the creation of scalar data from vorticity information.  The scalar information is currently the orientation value "theta" used in rotating stream tubes. If off, and input dataset has scalars, then input dataset scalars are used, unless SpeedScalars is also on. SpeedScalars takes precedence over OrientationScalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SpeedScalarsOff">
            <summary>
                <para>Turn on/off the creation of scalar data from velocity magnitude. If off, and input dataset has scalars, input dataset scalars are used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SpeedScalarsOn">
            <summary>
                <para>Turn on/off the creation of scalar data from velocity magnitude. If off, and input dataset has scalars, input dataset scalars are used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetSpeedScalars">
            <summary>
                <para>Turn on/off the creation of scalar data from velocity magnitude. If off, and input dataset has scalars, input dataset scalars are used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetSpeedScalars(System.Int32)">
            <summary>
                <para>Turn on/off the creation of scalar data from velocity magnitude. If off, and input dataset has scalars, input dataset scalars are used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetIntegrationStepLength">
            <summary>
                <para>Specify a nominal integration step size (expressed as a fraction of the size of each cell). This value can be larger than 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetIntegrationStepLengthMaxValue">
            <summary>
                <para>Specify a nominal integration step size (expressed as a fraction of the size of each cell). This value can be larger than 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetIntegrationStepLengthMinValue">
            <summary>
                <para>Specify a nominal integration step size (expressed as a fraction of the size of each cell). This value can be larger than 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetIntegrationStepLength(System.Double)">
            <summary>
                <para>Specify a nominal integration step size (expressed as a fraction of the size of each cell). This value can be larger than 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetIntegrationDirectionAsString">
            <summary>
                <para>Specify the direction in which to integrate the Streamer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetIntegrationDirectionToIntegrateBothDirections">
            <summary>
                <para>Specify the direction in which to integrate the Streamer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetIntegrationDirectionToBackward">
            <summary>
                <para>Specify the direction in which to integrate the Streamer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetIntegrationDirectionToForward">
            <summary>
                <para>Specify the direction in which to integrate the Streamer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetIntegrationDirection">
            <summary>
                <para>Specify the direction in which to integrate the Streamer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetIntegrationDirectionMaxValue">
            <summary>
                <para>Specify the direction in which to integrate the Streamer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetIntegrationDirectionMinValue">
            <summary>
                <para>Specify the direction in which to integrate the Streamer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetIntegrationDirection(System.Int32)">
            <summary>
                <para>Specify the direction in which to integrate the Streamer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetMaximumPropagationTime">
            <summary>
                <para>Specify the maximum length of the Streamer expressed in elapsed time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetMaximumPropagationTimeMaxValue">
            <summary>
                <para>Specify the maximum length of the Streamer expressed in elapsed time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetMaximumPropagationTimeMinValue">
            <summary>
                <para>Specify the maximum length of the Streamer expressed in elapsed time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetMaximumPropagationTime(System.Double)">
            <summary>
                <para>Specify the maximum length of the Streamer expressed in elapsed time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetSource">
            <summary>
                <para>Specify the source object used to generate starting points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetSource(vtk.vtkDataSet)">
            <summary>
                <para>Specify the source object used to generate starting points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetStartPosition">
            <summary>
                <para>Get the start position in global x-y-z coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetStartPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the start of the streamline in the global coordinate system. Search must be performed to find initial cell to start integration from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetStartPosition(System.Double[])">
            <summary>
                <para>Specify the start of the streamline in the global coordinate system. Search must be performed to find initial cell to start integration from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.GetStartLocation(System.Int32@,System.Double[])">
            <summary>
                <para>Get the starting location of the streamline in the cell coordinate system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetStartLocation(System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the start of the streamline in the cell coordinate system. That is, cellId and subId (if composite cell), and parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamer.SetStartLocation(System.Int32,System.Int32,System.Double[])">
            <summary>
                <para>Specify the start of the streamline in the cell coordinate system. That is, cellId and subId (if composite cell), and parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkIdFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkIdFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkIdFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkIdFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkIdFilter.GetIdsArrayName">
            <summary>
                <para>Set/Get the name of the Ids array if generated. By default the Ids are named "vtkIdFilter_Ids", but this can be changed with this function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.SetIdsArrayName(System.String)">
            <summary>
                <para>Set/Get the name of the Ids array if generated. By default the Ids are named "vtkIdFilter_Ids", but this can be changed with this function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.FieldDataOff">
            <summary>
                <para>Set/Get the flag which controls whether to generate scalar data or field data. If this flag is off, scalar data is generated. Otherwise, field data is generated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.FieldDataOn">
            <summary>
                <para>Set/Get the flag which controls whether to generate scalar data or field data. If this flag is off, scalar data is generated. Otherwise, field data is generated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.GetFieldData">
            <summary>
                <para>Set/Get the flag which controls whether to generate scalar data or field data. If this flag is off, scalar data is generated. Otherwise, field data is generated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.SetFieldData(System.Int32)">
            <summary>
                <para>Set/Get the flag which controls whether to generate scalar data or field data. If this flag is off, scalar data is generated. Otherwise, field data is generated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.CellIdsOff">
            <summary>
                <para>Enable/disable the generation of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.CellIdsOn">
            <summary>
                <para>Enable/disable the generation of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.GetCellIds">
            <summary>
                <para>Enable/disable the generation of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.SetCellIds(System.Int32)">
            <summary>
                <para>Enable/disable the generation of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.PointIdsOff">
            <summary>
                <para>Enable/disable the generation of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.PointIdsOn">
            <summary>
                <para>Enable/disable the generation of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.GetPointIds">
            <summary>
                <para>Enable/disable the generation of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdFilter.SetPointIds(System.Int32)">
            <summary>
                <para>Enable/disable the generation of point ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.PreventSeamOff">
            <summary>
                <para>Control how the texture coordinates are generated. If PreventSeam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding to the angle variation from 0-&gt;180 and 180-&gt;0. Otherwise, the s-coordinate ranges from 0-&gt;1 from 0-&gt;360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.PreventSeamOn">
            <summary>
                <para>Control how the texture coordinates are generated. If PreventSeam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding to the angle variation from 0-&gt;180 and 180-&gt;0. Otherwise, the s-coordinate ranges from 0-&gt;1 from 0-&gt;360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.GetPreventSeam">
            <summary>
                <para>Control how the texture coordinates are generated. If PreventSeam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding to the angle variation from 0-&gt;180 and 180-&gt;0. Otherwise, the s-coordinate ranges from 0-&gt;1 from 0-&gt;360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.SetPreventSeam(System.Int32)">
            <summary>
                <para>Control how the texture coordinates are generated. If PreventSeam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding to the angle variation from 0-&gt;180 and 180-&gt;0. Otherwise, the s-coordinate ranges from 0-&gt;1 from 0-&gt;360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.AutomaticCylinderGenerationOff">
            <summary>
                <para>Turn on/off automatic cylinder generation. This means it automatically finds the cylinder center and axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.AutomaticCylinderGenerationOn">
            <summary>
                <para>Turn on/off automatic cylinder generation. This means it automatically finds the cylinder center and axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.GetAutomaticCylinderGeneration">
            <summary>
                <para>Turn on/off automatic cylinder generation. This means it automatically finds the cylinder center and axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.SetAutomaticCylinderGeneration(System.Int32)">
            <summary>
                <para>Turn on/off automatic cylinder generation. This means it automatically finds the cylinder center and axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.GetPoint2">
            <summary>
                <para>Specify the second point defining the cylinder axis,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.SetPoint2(System.Double[])">
            <summary>
                <para>Specify the second point defining the cylinder axis,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.SetPoint2(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the second point defining the cylinder axis,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.GetPoint1">
            <summary>
                <para>Specify the first point defining the cylinder axis,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.SetPoint1(System.Double[])">
            <summary>
                <para>Specify the first point defining the cylinder axis,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToCylinder.SetPoint1(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the first point defining the cylinder axis,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.PreventSeamOff">
            <summary>
                <para>Control how the texture coordinates are generated. If PreventSeam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding to the theta angle variation between 0-&gt;180 and 180-&gt;0 degrees. Otherwise, the s-coordinate ranges from 0-&gt;1 between 0-&gt;360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.PreventSeamOn">
            <summary>
                <para>Control how the texture coordinates are generated. If PreventSeam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding to the theta angle variation between 0-&gt;180 and 180-&gt;0 degrees. Otherwise, the s-coordinate ranges from 0-&gt;1 between 0-&gt;360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.GetPreventSeam">
            <summary>
                <para>Control how the texture coordinates are generated. If PreventSeam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding to the theta angle variation between 0-&gt;180 and 180-&gt;0 degrees. Otherwise, the s-coordinate ranges from 0-&gt;1 between 0-&gt;360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.SetPreventSeam(System.Int32)">
            <summary>
                <para>Control how the texture coordinates are generated. If PreventSeam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding to the theta angle variation between 0-&gt;180 and 180-&gt;0 degrees. Otherwise, the s-coordinate ranges from 0-&gt;1 between 0-&gt;360 degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.AutomaticSphereGenerationOff">
            <summary>
                <para>Turn on/off automatic sphere generation. This means it automatically finds the sphere center.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.AutomaticSphereGenerationOn">
            <summary>
                <para>Turn on/off automatic sphere generation. This means it automatically finds the sphere center.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.GetAutomaticSphereGeneration">
            <summary>
                <para>Turn on/off automatic sphere generation. This means it automatically finds the sphere center.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.SetAutomaticSphereGeneration(System.Int32)">
            <summary>
                <para>Turn on/off automatic sphere generation. This means it automatically finds the sphere center.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.GetCenter">
            <summary>
                <para>Specify a point defining the center of the sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.SetCenter(System.Double[])">
            <summary>
                <para>Specify a point defining the center of the sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToSphere.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point defining the center of the sphere.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMaskFields.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMaskFields.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMaskFields.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMaskFields.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyAllOff">
            <summary>
                <para>Turn off copying of all data. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyAllOn">
            <summary>
                <para>Turn on copying of all data. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyFieldOff(System.String,System.String)">
            <summary>
                <para>Helper methods used by other language bindings. Allows the caller to specify arguments as strings instead of enums.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyFieldOn(System.String,System.String)">
            <summary>
                <para>Helper methods used by other language bindings. Allows the caller to specify arguments as strings instead of enums.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyAttributeOff(System.String,System.String)">
            <summary>
                <para>Helper methods used by other language bindings. Allows the caller to specify arguments as strings instead of enums.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyAttributeOn(System.String,System.String)">
            <summary>
                <para>Helper methods used by other language bindings. Allows the caller to specify arguments as strings instead of enums.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyAttributesOn">
            <summary>
                <para>Helper methods used by other language bindings. Allows the caller to specify arguments as strings instead of enums.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyFieldsOff">
            <summary>
                <para>Convenience methods which operate on all field data or  attribute data.  More specific than CopyAllOn or CopyAllOff</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyAttributeOff(System.Int32,System.Int32)">
            <summary>
                <para>Convenience methods which operate on all field data or  attribute data.  More specific than CopyAllOn or CopyAllOff</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyAttributeOn(System.Int32,System.Int32)">
            <summary>
                <para>Turn on/off the copying of the attribute or specified by vtkDataSetAttributes:AttributeTypes. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array An attribute type and a location must be specified. For example: @verbatim maskFields-&gt;CopyAttributeOff(vtkMaskFields::POINT_DATA, vtkDataSetAttributes::SCALARS); @endverbatim causes the scalars on the input point data to not get copied to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyFieldOff(System.Int32,System.String)">
            <summary>
                <para>Turn on/off the copying of the attribute or specified by vtkDataSetAttributes:AttributeTypes. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array An attribute type and a location must be specified. For example: @verbatim maskFields-&gt;CopyAttributeOff(vtkMaskFields::POINT_DATA, vtkDataSetAttributes::SCALARS); @endverbatim causes the scalars on the input point data to not get copied to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskFields.CopyFieldOn(System.Int32,System.String)">
            <summary>
                <para>Turn on/off the copying of the field or specified by name. During the copying/passing, the following rules are followed for each array: 1. If the copy flag for an array is set (on or off), it is applied    This overrides rule 2. 2. If CopyAllOn is set, copy the array.    If CopyAllOff is set, do not copy the array A field name and a location must be specified. For example: @verbatim maskFields-&gt;CopyFieldOff(vtkMaskFields::CELL_DATA, "foo"); @endverbatim causes the field "foo" on the input cell data to not get copied to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeCells.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMergeCells.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMergeCells.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMergeCells.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMergeCells.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMergeCells.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.GetInputLevels">
            <summary>
                <para>Returns input min (always 0) and max levels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.SetLevelRange(System.UInt32,System.UInt32)">
            <summary>
                <para>Returns input min (always 0) and max levels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.GetMaxLevel">
            <summary>
                <para>Maximum level to be extacted</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.SetMaxLevel(System.UInt32)">
            <summary>
                <para>Maximum level to be extacted</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.GetMinLevel">
            <summary>
                <para>Minimum level to be extacted</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractLevel.SetMinLevel(System.UInt32)">
            <summary>
                <para>Minimum level to be extacted</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointsProjectedHull.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointsProjectedHull.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointsProjectedHull.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointsProjectedHull.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointsProjectedHull.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointsProjectedHull.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDelaunay3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetMTime">
            <summary>
                <para>Return the MTime also considering the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.EndPointInsertion">
            <summary>
                <para>Invoke this method after all points have been inserted. The purpose of the method is to clean up internal data structures. Note that the  (vtkUnstructuredGrid *)Mesh returned from InitPointInsertion() is NOT deleted, you still are responsible for cleaning that up.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.InsertPoint(vtk.vtkUnstructuredGrid,vtk.vtkPoints,System.Int32,System.Double[],vtk.vtkIdList)">
            <summary>
                <para>This is a helper method used with InitPointInsertion() to create tetrahedronalizations of points. Its purpose is to inject point at coordinates specified into tetrahedronalization. The point id is an index into the list of points in the mesh structure.  (See vtkDelaunay3D::InitPointInsertion() for more information.)  When you have completed inserting points, traverse the mesh structure to extract desired tetrahedra (or tetra faces and edges).The holeTetras id list lists all the tetrahedra that are deleted (invalid) in the mesh structure.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The  locator is used to eliminate "coincident" points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetLocator">
            <summary>
                <para>Set / get a spatial locator for merging points. By default,  an instance of vtkPointLocator is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / get a spatial locator for merging points. By default,  an instance of vtkPointLocator is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.BoundingTriangulationOff">
            <summary>
                <para>Boolean controls whether bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.BoundingTriangulationOn">
            <summary>
                <para>Boolean controls whether bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetBoundingTriangulation">
            <summary>
                <para>Boolean controls whether bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.SetBoundingTriangulation(System.Int32)">
            <summary>
                <para>Boolean controls whether bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetOffset">
            <summary>
                <para>Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetOffsetMaxValue">
            <summary>
                <para>Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetOffsetMinValue">
            <summary>
                <para>Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.SetOffset(System.Double)">
            <summary>
                <para>Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetTolerance">
            <summary>
                <para>Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetToleranceMaxValue">
            <summary>
                <para>Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetToleranceMinValue">
            <summary>
                <para>Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.SetTolerance(System.Double)">
            <summary>
                <para>Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetAlpha">
            <summary>
                <para>Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges, faces, or tetra contained  within the circumsphere (of radius alpha) will be output. Otherwise, only tetrahedra will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetAlphaMaxValue">
            <summary>
                <para>Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges, faces, or tetra contained  within the circumsphere (of radius alpha) will be output. Otherwise, only tetrahedra will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.GetAlphaMinValue">
            <summary>
                <para>Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges, faces, or tetra contained  within the circumsphere (of radius alpha) will be output. Otherwise, only tetrahedra will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay3D.SetAlpha(System.Double)">
            <summary>
                <para>Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges, faces, or tetra contained  within the circumsphere (of radius alpha) will be output. Otherwise, only tetrahedra will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStripper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStripper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStripper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStripper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStripper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStripper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStripper.GetPassCellDataAsFieldData">
            <summary>
                <para>Enable/Disable passing of the CellData in the input to the output as FieldData. Note the field data is tranformed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStripper.SetPassCellDataAsFieldData(System.Int32)">
            <summary>
                <para>Enable/Disable passing of the CellData in the input to the output as FieldData. Note the field data is tranformed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStripper.PassCellDataAsFieldDataOff">
            <summary>
                <para>Enable/Disable passing of the CellData in the input to the output as FieldData. Note the field data is tranformed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStripper.PassCellDataAsFieldDataOn">
            <summary>
                <para>Enable/Disable passing of the CellData in the input to the output as FieldData. Note the field data is tranformed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStripper.GetMaximumLength">
            <summary>
                <para>Specify the maximum number of triangles in a triangle strip, and/or the maximum number of lines in a poly-line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStripper.GetMaximumLengthMaxValue">
            <summary>
                <para>Specify the maximum number of triangles in a triangle strip, and/or the maximum number of lines in a poly-line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStripper.GetMaximumLengthMinValue">
            <summary>
                <para>Specify the maximum number of triangles in a triangle strip, and/or the maximum number of lines in a poly-line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStripper.SetMaximumLength(System.Int32)">
            <summary>
                <para>Specify the maximum number of triangles in a triangle strip, and/or the maximum number of lines in a poly-line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.GetIncrement">
            <summary>
                <para>Every "Increment" point is added to the list of points. This parameter, if set to a large value, can be used to limit the number of points while retaining good accuracy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.GetIncrementMaxValue">
            <summary>
                <para>Every "Increment" point is added to the list of points. This parameter, if set to a large value, can be used to limit the number of points while retaining good accuracy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.GetIncrementMinValue">
            <summary>
                <para>Every "Increment" point is added to the list of points. This parameter, if set to a large value, can be used to limit the number of points while retaining good accuracy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.SetIncrement(System.Int32)">
            <summary>
                <para>Every "Increment" point is added to the list of points. This parameter, if set to a large value, can be used to limit the number of points while retaining good accuracy.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.GetDistance">
            <summary>
                <para>Specify sub-voxel size at which to generate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.GetDistanceMaxValue">
            <summary>
                <para>Specify sub-voxel size at which to generate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.GetDistanceMinValue">
            <summary>
                <para>Specify sub-voxel size at which to generate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.SetDistance(System.Double)">
            <summary>
                <para>Specify sub-voxel size at which to generate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.GetValue">
            <summary>
                <para>Set isosurface value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRecursiveDividingCubes.SetValue(System.Double)">
            <summary>
                <para>Set isosurface value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSplineFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetTextureLength">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetTextureLengthMaxValue">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetTextureLengthMinValue">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetTextureLength(System.Double)">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetGenerateTCoordsAsString">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetGenerateTCoordsToUseScalars">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetGenerateTCoordsToUseLength">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetGenerateTCoordsToNormalizedLength">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetGenerateTCoordsToOff">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetGenerateTCoords">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetGenerateTCoordsMaxValue">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetGenerateTCoordsMinValue">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetGenerateTCoords(System.Int32)">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the output polyline. The texture coordinates can be generated in three ways: a normalized (0,1) generation; based on the length (divided by the texture length); and by using the input scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetSpline">
            <summary>
                <para>Specify an instance of vtkSpline to use to perform the interpolation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetSpline(vtk.vtkSpline)">
            <summary>
                <para>Specify an instance of vtkSpline to use to perform the interpolation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetLength">
            <summary>
                <para>Control the number of subdivisions that are created for the polyline based on an absolute length. The length of the spline is divided by this length to determine the number of subdivisions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetLengthMaxValue">
            <summary>
                <para>Control the number of subdivisions that are created for the polyline based on an absolute length. The length of the spline is divided by this length to determine the number of subdivisions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetLengthMinValue">
            <summary>
                <para>Control the number of subdivisions that are created for the polyline based on an absolute length. The length of the spline is divided by this length to determine the number of subdivisions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetLength(System.Double)">
            <summary>
                <para>Control the number of subdivisions that are created for the polyline based on an absolute length. The length of the spline is divided by this length to determine the number of subdivisions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetNumberOfSubdivisions">
            <summary>
                <para>Set the number of subdivisions that are created for the polyline. This method only has effect if Subdivisions is set to SetSubdivisionsToSpecify().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetNumberOfSubdivisionsMaxValue">
            <summary>
                <para>Set the number of subdivisions that are created for the polyline. This method only has effect if Subdivisions is set to SetSubdivisionsToSpecify().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetNumberOfSubdivisionsMinValue">
            <summary>
                <para>Set the number of subdivisions that are created for the polyline. This method only has effect if Subdivisions is set to SetSubdivisionsToSpecify().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetNumberOfSubdivisions(System.Int32)">
            <summary>
                <para>Set the number of subdivisions that are created for the polyline. This method only has effect if Subdivisions is set to SetSubdivisionsToSpecify().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetSubdivideAsString">
            <summary>
                <para>Specify how the number of subdivisions is determined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetSubdivideToLength">
            <summary>
                <para>Specify how the number of subdivisions is determined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetSubdivideToSpecified">
            <summary>
                <para>Specify how the number of subdivisions is determined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetSubdivide">
            <summary>
                <para>Specify how the number of subdivisions is determined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetSubdivideMaxValue">
            <summary>
                <para>Specify how the number of subdivisions is determined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetSubdivideMinValue">
            <summary>
                <para>Specify how the number of subdivisions is determined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetSubdivide(System.Int32)">
            <summary>
                <para>Specify how the number of subdivisions is determined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetMaximumNumberOfSubdivisions">
            <summary>
                <para>Set the maximum number of subdivisions that are created for each polyline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetMaximumNumberOfSubdivisionsMaxValue">
            <summary>
                <para>Set the maximum number of subdivisions that are created for each polyline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.GetMaximumNumberOfSubdivisionsMinValue">
            <summary>
                <para>Set the maximum number of subdivisions that are created for each polyline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplineFilter.SetMaximumNumberOfSubdivisions(System.Int32)">
            <summary>
                <para>Set the maximum number of subdivisions that are created for each polyline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.SetOutputWholeExtent(System.Int32,System.Int32)">
            <summary>
                <para>Hack set output by piece</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.ClipDataOff">
            <summary>
                <para>By default, ClipData is off, and only the WholeExtent is modified. the data's extent may actually be larger.  When this flag is on, the data extent will be no more than the OutputWholeExtent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.ClipDataOn">
            <summary>
                <para>By default, ClipData is off, and only the WholeExtent is modified. the data's extent may actually be larger.  When this flag is on, the data extent will be no more than the OutputWholeExtent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.GetClipData">
            <summary>
                <para>By default, ClipData is off, and only the WholeExtent is modified. the data's extent may actually be larger.  When this flag is on, the data extent will be no more than the OutputWholeExtent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.SetClipData(System.Int32)">
            <summary>
                <para>By default, ClipData is off, and only the WholeExtent is modified. the data's extent may actually be larger.  When this flag is on, the data extent will be no more than the OutputWholeExtent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.GetOutputWholeExtent(System.Int32[])">
            <summary>
                <para>The whole extent of the output has to be set explicitly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.SetOutputWholeExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>The whole extent of the output has to be set explicitly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridClip.SetOutputWholeExtent(System.Int32[],vtk.vtkInformation)">
            <summary>
                <para>The whole extent of the output has to be set explicitly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorDot.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVectorDot.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVectorDot.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVectorDot.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVectorDot.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVectorDot.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVectorDot.GetScalarRange">
            <summary>
                <para>Get the range that scalars map into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorDot.SetScalarRange(System.Double[])">
            <summary>
                <para>Specify range to map scalars into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorDot.SetScalarRange(System.Double,System.Double)">
            <summary>
                <para>Specify range to map scalars into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkReverseSense.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkReverseSense.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkReverseSense.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkReverseSense.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkReverseSense.ReverseNormalsOff">
            <summary>
                <para>Flag controls whether to reverse normal orientation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.ReverseNormalsOn">
            <summary>
                <para>Flag controls whether to reverse normal orientation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.GetReverseNormals">
            <summary>
                <para>Flag controls whether to reverse normal orientation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.SetReverseNormals(System.Int32)">
            <summary>
                <para>Flag controls whether to reverse normal orientation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.ReverseCellsOff">
            <summary>
                <para>Flag controls whether to reverse cell ordering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.ReverseCellsOn">
            <summary>
                <para>Flag controls whether to reverse cell ordering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.GetReverseCells">
            <summary>
                <para>Flag controls whether to reverse cell ordering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReverseSense.SetReverseCells(System.Int32)">
            <summary>
                <para>Flag controls whether to reverse cell ordering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.GetRectilinearGridInput">
            <summary>
                <para>Get the input as a concrete type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.GetUnstructuredGridInput">
            <summary>
                <para>Get the input as a concrete type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.GetStructuredGridInput">
            <summary>
                <para>Get the input as a concrete type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.GetStructuredPointsInput">
            <summary>
                <para>Get the input as a concrete type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableFilter.GetPolyDataInput">
            <summary>
                <para>Get the input as a concrete type. This method is typically used by the writer of the filter function to get the input as a particular type (i.e., it essentially does type casting). It is the users responsibility to know the correct type of the input data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkArrowSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkArrowSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkArrowSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkArrowSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetShaftResolution">
            <summary>
                <para>Set the resolution of the shaft.  2 gives a rectangle. I would like to extend the cone to produce a line, but this is not an option now.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetShaftResolutionMaxValue">
            <summary>
                <para>Set the resolution of the shaft.  2 gives a rectangle. I would like to extend the cone to produce a line, but this is not an option now.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetShaftResolutionMinValue">
            <summary>
                <para>Set the resolution of the shaft.  2 gives a rectangle. I would like to extend the cone to produce a line, but this is not an option now.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.SetShaftResolution(System.Int32)">
            <summary>
                <para>Set the resolution of the shaft.  2 gives a rectangle. I would like to extend the cone to produce a line, but this is not an option now.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetShaftRadius">
            <summary>
                <para>Set the radius of the shaft.  Defaults to 0.03.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetShaftRadiusMaxValue">
            <summary>
                <para>Set the radius of the shaft.  Defaults to 0.03.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetShaftRadiusMinValue">
            <summary>
                <para>Set the radius of the shaft.  Defaults to 0.03.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.SetShaftRadius(System.Double)">
            <summary>
                <para>Set the radius of the shaft.  Defaults to 0.03.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipResolution">
            <summary>
                <para>Set the resolution of the tip.  The tip behaves the same as a cone. Resoultion 1 gives a single triangle, 2 gives two crossed triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipResolutionMaxValue">
            <summary>
                <para>Set the resolution of the tip.  The tip behaves the same as a cone. Resoultion 1 gives a single triangle, 2 gives two crossed triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipResolutionMinValue">
            <summary>
                <para>Set the resolution of the tip.  The tip behaves the same as a cone. Resoultion 1 gives a single triangle, 2 gives two crossed triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.SetTipResolution(System.Int32)">
            <summary>
                <para>Set the resolution of the tip.  The tip behaves the same as a cone. Resoultion 1 gives a single triangle, 2 gives two crossed triangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipRadius">
            <summary>
                <para>Set the length, and radius of the tip.  They default to 0.35 and 0.1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipRadiusMaxValue">
            <summary>
                <para>Set the length, and radius of the tip.  They default to 0.35 and 0.1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipRadiusMinValue">
            <summary>
                <para>Set the length, and radius of the tip.  They default to 0.35 and 0.1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.SetTipRadius(System.Double)">
            <summary>
                <para>Set the length, and radius of the tip.  They default to 0.35 and 0.1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipLength">
            <summary>
                <para>Set the length, and radius of the tip.  They default to 0.35 and 0.1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipLengthMaxValue">
            <summary>
                <para>Set the length, and radius of the tip.  They default to 0.35 and 0.1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.GetTipLengthMinValue">
            <summary>
                <para>Set the length, and radius of the tip.  They default to 0.35 and 0.1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrowSource.SetTipLength(System.Double)">
            <summary>
                <para>Set the length, and radius of the tip.  They default to 0.35 and 0.1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatingSubdivisionFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolatingSubdivisionFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.PassLinesOff">
            <summary>
                <para>Indicate whether the generating lines are to be passed to the output. By defualt lines are not passed to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.PassLinesOn">
            <summary>
                <para>Indicate whether the generating lines are to be passed to the output. By defualt lines are not passed to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetPassLines">
            <summary>
                <para>Indicate whether the generating lines are to be passed to the output. By defualt lines are not passed to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetPassLines(System.Int32)">
            <summary>
                <para>Indicate whether the generating lines are to be passed to the output. By defualt lines are not passed to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetResolution">
            <summary>
                <para>If the ruled surface generation mode is RESAMPLE, then these parameters are used to determine the resample rate. Resolution[0] defines the resolution in the direction of the polylines; Resolution[1] defines the resolution across the polylines (i.e., direction orthogonal to Resolution[0]).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetResolution(System.Int32[])">
            <summary>
                <para>If the ruled surface generation mode is RESAMPLE, then these parameters are used to determine the resample rate. Resolution[0] defines the resolution in the direction of the polylines; Resolution[1] defines the resolution across the polylines (i.e., direction orthogonal to Resolution[0]).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetResolution(System.Int32,System.Int32)">
            <summary>
                <para>If the ruled surface generation mode is RESAMPLE, then these parameters are used to determine the resample rate. Resolution[0] defines the resolution in the direction of the polylines; Resolution[1] defines the resolution across the polylines (i.e., direction orthogonal to Resolution[0]).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetRuledModeAsString">
            <summary>
                <para>Set the mode by which to create the ruled surface. (Dramatically different results are possible depending on the chosen mode.) The resample mode evenly resamples the polylines (based on length) and  generates triangle strips. The point walk mode uses the existing points and walks around the polyline using existing points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetRuledModeToPointWalk">
            <summary>
                <para>Set the mode by which to create the ruled surface. (Dramatically different results are possible depending on the chosen mode.) The resample mode evenly resamples the polylines (based on length) and  generates triangle strips. The point walk mode uses the existing points and walks around the polyline using existing points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetRuledModeToResample">
            <summary>
                <para>Set the mode by which to create the ruled surface. (Dramatically different results are possible depending on the chosen mode.) The resample mode evenly resamples the polylines (based on length) and  generates triangle strips. The point walk mode uses the existing points and walks around the polyline using existing points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetRuledMode">
            <summary>
                <para>Set the mode by which to create the ruled surface. (Dramatically different results are possible depending on the chosen mode.) The resample mode evenly resamples the polylines (based on length) and  generates triangle strips. The point walk mode uses the existing points and walks around the polyline using existing points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetRuledModeMaxValue">
            <summary>
                <para>Set the mode by which to create the ruled surface. (Dramatically different results are possible depending on the chosen mode.) The resample mode evenly resamples the polylines (based on length) and  generates triangle strips. The point walk mode uses the existing points and walks around the polyline using existing points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetRuledModeMinValue">
            <summary>
                <para>Set the mode by which to create the ruled surface. (Dramatically different results are possible depending on the chosen mode.) The resample mode evenly resamples the polylines (based on length) and  generates triangle strips. The point walk mode uses the existing points and walks around the polyline using existing points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetRuledMode(System.Int32)">
            <summary>
                <para>Set the mode by which to create the ruled surface. (Dramatically different results are possible depending on the chosen mode.) The resample mode evenly resamples the polylines (based on length) and  generates triangle strips. The point walk mode uses the existing points and walks around the polyline using existing points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.CloseSurfaceOff">
            <summary>
                <para>Indicate whether the surface is to be closed. If this boolean is on, then the first and last polyline are used to generate a stripe that closes the surface. (Note: to close the surface in the other direction, repeat the first point in the polyline as the last point in the polyline.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.CloseSurfaceOn">
            <summary>
                <para>Indicate whether the surface is to be closed. If this boolean is on, then the first and last polyline are used to generate a stripe that closes the surface. (Note: to close the surface in the other direction, repeat the first point in the polyline as the last point in the polyline.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetCloseSurface">
            <summary>
                <para>Indicate whether the surface is to be closed. If this boolean is on, then the first and last polyline are used to generate a stripe that closes the surface. (Note: to close the surface in the other direction, repeat the first point in the polyline as the last point in the polyline.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetCloseSurface(System.Int32)">
            <summary>
                <para>Indicate whether the surface is to be closed. If this boolean is on, then the first and last polyline are used to generate a stripe that closes the surface. (Note: to close the surface in the other direction, repeat the first point in the polyline as the last point in the polyline.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetOffset">
            <summary>
                <para>Control the striping of the ruled surface. The offset sets the first stripe that is visible. Offset is generally used with OnRatio to create nifty striping effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetOffsetMaxValue">
            <summary>
                <para>Control the striping of the ruled surface. The offset sets the first stripe that is visible. Offset is generally used with OnRatio to create nifty striping effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetOffsetMinValue">
            <summary>
                <para>Control the striping of the ruled surface. The offset sets the first stripe that is visible. Offset is generally used with OnRatio to create nifty striping effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetOffset(System.Int32)">
            <summary>
                <para>Control the striping of the ruled surface. The offset sets the first stripe that is visible. Offset is generally used with OnRatio to create nifty striping effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetOnRatio">
            <summary>
                <para>Control the striping of the ruled surface. If OnRatio is greater  than 1, then every nth strip is turned on, beginning with the Offset strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetOnRatioMaxValue">
            <summary>
                <para>Control the striping of the ruled surface. If OnRatio is greater  than 1, then every nth strip is turned on, beginning with the Offset strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetOnRatioMinValue">
            <summary>
                <para>Control the striping of the ruled surface. If OnRatio is greater  than 1, then every nth strip is turned on, beginning with the Offset strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetOnRatio(System.Int32)">
            <summary>
                <para>Control the striping of the ruled surface. If OnRatio is greater  than 1, then every nth strip is turned on, beginning with the Offset strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetDistanceFactor">
            <summary>
                <para>Set/Get the factor that controls tearing of the surface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetDistanceFactorMaxValue">
            <summary>
                <para>Set/Get the factor that controls tearing of the surface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.GetDistanceFactorMinValue">
            <summary>
                <para>Set/Get the factor that controls tearing of the surface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRuledSurfaceFilter.SetDistanceFactor(System.Double)">
            <summary>
                <para>Set/Get the factor that controls tearing of the surface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetMTime">
            <summary>
                <para>Return the MTime also considering the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetLocator">
            <summary>
                <para>Set / get a spatial locator for merging points. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / get a spatial locator for merging points. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.MergingOff">
            <summary>
                <para>Turn on/off merging of coincident points. Note that is merging is on, points with different point attributes (e.g., normals) are merged, which may cause rendering artifacts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.MergingOn">
            <summary>
                <para>Turn on/off merging of coincident points. Note that is merging is on, points with different point attributes (e.g., normals) are merged, which may cause rendering artifacts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetMerging">
            <summary>
                <para>Turn on/off merging of coincident points. Note that is merging is on, points with different point attributes (e.g., normals) are merged, which may cause rendering artifacts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetMerging(System.Int32)">
            <summary>
                <para>Turn on/off merging of coincident points. Note that is merging is on, points with different point attributes (e.g., normals) are merged, which may cause rendering artifacts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetExtent">
            <summary>
                <para>Set / get a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetExtent(System.Double[])">
            <summary>
                <para>Set / get a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetExtent(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetCellMaximum">
            <summary>
                <para>Specify the maximum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetCellMaximumMaxValue">
            <summary>
                <para>Specify the maximum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetCellMaximumMinValue">
            <summary>
                <para>Specify the maximum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetCellMaximum(System.Int32)">
            <summary>
                <para>Specify the maximum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetCellMinimum">
            <summary>
                <para>Specify the minimum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetCellMinimumMaxValue">
            <summary>
                <para>Specify the minimum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetCellMinimumMinValue">
            <summary>
                <para>Specify the minimum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetCellMinimum(System.Int32)">
            <summary>
                <para>Specify the minimum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetPointMaximum">
            <summary>
                <para>Specify the maximum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetPointMaximumMaxValue">
            <summary>
                <para>Specify the maximum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetPointMaximumMinValue">
            <summary>
                <para>Specify the maximum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetPointMaximum(System.Int32)">
            <summary>
                <para>Specify the maximum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetPointMinimum">
            <summary>
                <para>Specify the minimum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetPointMinimumMaxValue">
            <summary>
                <para>Specify the minimum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetPointMinimumMinValue">
            <summary>
                <para>Specify the minimum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetPointMinimum(System.Int32)">
            <summary>
                <para>Specify the minimum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.ExtentClippingOff">
            <summary>
                <para>Turn on/off selection of geometry via bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.ExtentClippingOn">
            <summary>
                <para>Turn on/off selection of geometry via bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetExtentClipping">
            <summary>
                <para>Turn on/off selection of geometry via bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetExtentClipping(System.Int32)">
            <summary>
                <para>Turn on/off selection of geometry via bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.CellClippingOff">
            <summary>
                <para>Turn on/off selection of geometry by cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.CellClippingOn">
            <summary>
                <para>Turn on/off selection of geometry by cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetCellClipping">
            <summary>
                <para>Turn on/off selection of geometry by cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetCellClipping(System.Int32)">
            <summary>
                <para>Turn on/off selection of geometry by cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.PointClippingOff">
            <summary>
                <para>Turn on/off selection of geometry by point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.PointClippingOn">
            <summary>
                <para>Turn on/off selection of geometry by point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.GetPointClipping">
            <summary>
                <para>Turn on/off selection of geometry by point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractUnstructuredGrid.SetPointClipping(System.Int32)">
            <summary>
                <para>Turn on/off selection of geometry by point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButterflySubdivisionFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkButterflySubdivisionFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkButterflySubdivisionFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkButterflySubdivisionFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkButterflySubdivisionFilter.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButterflySubdivisionFilter.NewInstance">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButterflySubdivisionFilter.IsA(System.String)">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButterflySubdivisionFilter.GetClassName">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubdivideTetra.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSubdivideTetra.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSubdivideTetra.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSubdivideTetra.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSubdivideTetra.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSubdivideTetra.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableDataObjectSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableDataObjectSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableDataObjectSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProgrammableDataObjectSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProgrammableDataObjectSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableDataObjectSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.SetOutputFieldToCellDataField">
            <summary>
                <para>Specify where to place the field data during the merge process.  There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.SetOutputFieldToPointDataField">
            <summary>
                <para>Specify where to place the field data during the merge process.  There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.SetOutputFieldToDataObjectField">
            <summary>
                <para>Specify where to place the field data during the merge process.  There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.GetOutputField">
            <summary>
                <para>Specify where to place the field data during the merge process.  There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.SetOutputField(System.Int32)">
            <summary>
                <para>Specify where to place the field data during the merge process.  There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.GetDataObject">
            <summary>
                <para>Specify the data object to merge with the input dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeDataObjectFilter.SetDataObject(vtk.vtkDataObject)">
            <summary>
                <para>Specify the data object to merge with the input dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridOutlineFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredGridOutlineFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridOutlineFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridOutlineFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTubeFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetTextureLength">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetTextureLengthMaxValue">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetTextureLengthMinValue">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetTextureLength(System.Double)">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetGenerateTCoordsAsString">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetGenerateTCoordsToUseScalars">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetGenerateTCoordsToUseLength">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetGenerateTCoordsToNormalizedLength">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetGenerateTCoordsToOff">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetGenerateTCoords">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetGenerateTCoordsMaxValue">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetGenerateTCoordsMinValue">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetGenerateTCoords(System.Int32)">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the tube with length textures, etc. If you use scalars to create the texture, the scalars are assumed to be monotonically increasing (or decreasing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetOffset">
            <summary>
                <para>Control the striping of the tubes. The offset sets the first tube side that is visible. Offset is generally used with OnRatio to create nifty striping effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetOffsetMaxValue">
            <summary>
                <para>Control the striping of the tubes. The offset sets the first tube side that is visible. Offset is generally used with OnRatio to create nifty striping effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetOffsetMinValue">
            <summary>
                <para>Control the striping of the tubes. The offset sets the first tube side that is visible. Offset is generally used with OnRatio to create nifty striping effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetOffset(System.Int32)">
            <summary>
                <para>Control the striping of the tubes. The offset sets the first tube side that is visible. Offset is generally used with OnRatio to create nifty striping effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetOnRatio">
            <summary>
                <para>Control the striping of the tubes. If OnRatio is greater than 1, then every nth tube side is turned on, beginning with the Offset side.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetOnRatioMaxValue">
            <summary>
                <para>Control the striping of the tubes. If OnRatio is greater than 1, then every nth tube side is turned on, beginning with the Offset side.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetOnRatioMinValue">
            <summary>
                <para>Control the striping of the tubes. If OnRatio is greater than 1, then every nth tube side is turned on, beginning with the Offset side.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetOnRatio(System.Int32)">
            <summary>
                <para>Control the striping of the tubes. If OnRatio is greater than 1, then every nth tube side is turned on, beginning with the Offset side.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.CappingOff">
            <summary>
                <para>Turn on/off whether to cap the ends with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.CappingOn">
            <summary>
                <para>Turn on/off whether to cap the ends with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetCapping">
            <summary>
                <para>Turn on/off whether to cap the ends with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetCapping(System.Int32)">
            <summary>
                <para>Turn on/off whether to cap the ends with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SidesShareVerticesOff">
            <summary>
                <para>Set a boolean to control whether tube sides should share vertices. This creates independent strips, with constant normals so the tube is always faceted in appearance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SidesShareVerticesOn">
            <summary>
                <para>Set a boolean to control whether tube sides should share vertices. This creates independent strips, with constant normals so the tube is always faceted in appearance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetSidesShareVertices">
            <summary>
                <para>Set a boolean to control whether tube sides should share vertices. This creates independent strips, with constant normals so the tube is always faceted in appearance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetSidesShareVertices(System.Int32)">
            <summary>
                <para>Set a boolean to control whether tube sides should share vertices. This creates independent strips, with constant normals so the tube is always faceted in appearance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.UseDefaultNormalOff">
            <summary>
                <para>Set a boolean to control whether to use default normals. DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.UseDefaultNormalOn">
            <summary>
                <para>Set a boolean to control whether to use default normals. DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetUseDefaultNormal">
            <summary>
                <para>Set a boolean to control whether to use default normals. DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetUseDefaultNormal(System.Int32)">
            <summary>
                <para>Set a boolean to control whether to use default normals. DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetDefaultNormal">
            <summary>
                <para>Set the default normal to use if no normals are supplied, and the DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetDefaultNormal(System.Double[])">
            <summary>
                <para>Set the default normal to use if no normals are supplied, and the DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetDefaultNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the default normal to use if no normals are supplied, and the DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetRadiusFactor">
            <summary>
                <para>Set the maximum tube radius in terms of a multiple of the minimum radius.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetRadiusFactor(System.Double)">
            <summary>
                <para>Set the maximum tube radius in terms of a multiple of the minimum radius.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetNumberOfSides">
            <summary>
                <para>Set the number of sides for the tube. At a minimum, number of sides is 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetNumberOfSidesMaxValue">
            <summary>
                <para>Set the number of sides for the tube. At a minimum, number of sides is 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetNumberOfSidesMinValue">
            <summary>
                <para>Set the number of sides for the tube. At a minimum, number of sides is 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetNumberOfSides(System.Int32)">
            <summary>
                <para>Set the number of sides for the tube. At a minimum, number of sides is 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetVaryRadiusAsString">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetVaryRadiusToVaryRadiusByAbsoluteScalar">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetVaryRadiusToVaryRadiusByVector">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetVaryRadiusToVaryRadiusByScalar">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetVaryRadiusToVaryRadiusOff">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetVaryRadius">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetVaryRadiusMaxValue">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetVaryRadiusMinValue">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetVaryRadius(System.Int32)">
            <summary>
                <para>Turn on/off the variation of tube radius with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetRadius">
            <summary>
                <para>Set the minimum tube radius (minimum because the tube radius may vary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetRadiusMaxValue">
            <summary>
                <para>Set the minimum tube radius (minimum because the tube radius may vary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.GetRadiusMinValue">
            <summary>
                <para>Set the minimum tube radius (minimum because the tube radius may vary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTubeFilter.SetRadius(System.Double)">
            <summary>
                <para>Set the minimum tube radius (minimum because the tube radius may vary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDelaunay2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetProjectionPlaneMode">
            <summary>
                <para>Define</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetProjectionPlaneModeMaxValue">
            <summary>
                <para>Define</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetProjectionPlaneModeMinValue">
            <summary>
                <para>Define</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.SetProjectionPlaneMode(System.Int32)">
            <summary>
                <para>Define</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetTransform">
            <summary>
                <para>Set / get the transform which is applied to points to generate a 2D problem.  This maps a 3D dataset into a 2D dataset where triangulation can be done on the XY plane.  The points are transformed and triangulated.  The topology of triangulated points is used as the output topology.  The output points are the original (untransformed) points.  The transform can be any subclass of vtkAbstractTransform (thus it does not need to be a linear or invertible transform).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.SetTransform(vtk.vtkAbstractTransform)">
            <summary>
                <para>Set / get the transform which is applied to points to generate a 2D problem.  This maps a 3D dataset into a 2D dataset where triangulation can be done on the XY plane.  The points are transformed and triangulated.  The topology of triangulated points is used as the output topology.  The output points are the original (untransformed) points.  The transform can be any subclass of vtkAbstractTransform (thus it does not need to be a linear or invertible transform).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.BoundingTriangulationOff">
            <summary>
                <para>Boolean controls whether bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.BoundingTriangulationOn">
            <summary>
                <para>Boolean controls whether bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetBoundingTriangulation">
            <summary>
                <para>Boolean controls whether bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.SetBoundingTriangulation(System.Int32)">
            <summary>
                <para>Boolean controls whether bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetOffset">
            <summary>
                <para>Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetOffsetMaxValue">
            <summary>
                <para>Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetOffsetMinValue">
            <summary>
                <para>Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.SetOffset(System.Double)">
            <summary>
                <para>Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetTolerance">
            <summary>
                <para>Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetToleranceMaxValue">
            <summary>
                <para>Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetToleranceMinValue">
            <summary>
                <para>Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.SetTolerance(System.Double)">
            <summary>
                <para>Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetAlpha">
            <summary>
                <para>Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetAlphaMaxValue">
            <summary>
                <para>Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetAlphaMinValue">
            <summary>
                <para>Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.SetAlpha(System.Double)">
            <summary>
                <para>Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.GetSource">
            <summary>
                <para>Get a pointer to the source object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.SetSourceConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Specify the source object used to specify constrained edges and loops. (This is optional.) If set, and lines/polygons are defined, a constrained triangulation is created. The lines/polygons are assumed to reference points in the input point set (i.e. point ids are identical in the input and source). New style. This method is equivalent to SetInputConnection(1, algOutput).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDelaunay2D.SetSource(vtk.vtkPolyData)">
            <summary>
                <para>Specify the source object used to specify constrained edges and loops. (This is optional.) If set, and lines/polygons are defined, a constrained triangulation is created. The lines/polygons are assumed to reference points in the input point set (i.e. point ids are identical in the input and source). Old style. See SetSourceConnection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.PassCellDataOff">
            <summary>
                <para>Control whether the input cell data is to be passed to the output. If on, then the input cell data is passed through to the output; otherwise, only generated point data is placed into the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.PassCellDataOn">
            <summary>
                <para>Control whether the input cell data is to be passed to the output. If on, then the input cell data is passed through to the output; otherwise, only generated point data is placed into the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.GetPassCellData">
            <summary>
                <para>Control whether the input cell data is to be passed to the output. If on, then the input cell data is passed through to the output; otherwise, only generated point data is placed into the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellDataToPointData.SetPassCellData(System.Int32)">
            <summary>
                <para>Control whether the input cell data is to be passed to the output. If on, then the input cell data is passed through to the output; otherwise, only generated point data is placed into the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkThresholdPoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.GetLowerThreshold">
            <summary>
                <para>Get the upper and lower thresholds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.GetUpperThreshold">
            <summary>
                <para>Get the upper and lower thresholds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.ThresholdBetween(System.Double,System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are between lower and upper thresholds (inclusive of the end values).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.ThresholdByUpper(System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are greater or equal to upper threshold.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdPoints.ThresholdByLower(System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are less or equal to lower threshold.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.GetDeltaRadius">
            <summary>
                <para>Set/Get change in radius during sweep process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.SetDeltaRadius(System.Double)">
            <summary>
                <para>Set/Get change in radius during sweep process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.GetTranslation">
            <summary>
                <para>Set/Get total amount of translation along the z-axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.SetTranslation(System.Double)">
            <summary>
                <para>Set/Get total amount of translation along the z-axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.GetAngle">
            <summary>
                <para>Set/Get angle of rotation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.SetAngle(System.Double)">
            <summary>
                <para>Set/Get angle of rotation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.CappingOff">
            <summary>
                <para>Turn on/off the capping of the skirt.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.CappingOn">
            <summary>
                <para>Turn on/off the capping of the skirt.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.GetCapping">
            <summary>
                <para>Turn on/off the capping of the skirt.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.SetCapping(System.Int32)">
            <summary>
                <para>Turn on/off the capping of the skirt.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.GetResolution">
            <summary>
                <para>Set/Get resolution of sweep operation. Resolution controls the number of intermediate node points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.GetResolutionMaxValue">
            <summary>
                <para>Set/Get resolution of sweep operation. Resolution controls the number of intermediate node points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.GetResolutionMinValue">
            <summary>
                <para>Set/Get resolution of sweep operation. Resolution controls the number of intermediate node points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationalExtrusionFilter.SetResolution(System.Int32)">
            <summary>
                <para>Set/Get resolution of sweep operation. Resolution controls the number of intermediate node points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearSubdivisionFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLinearSubdivisionFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLinearSubdivisionFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLinearSubdivisionFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLinearSubdivisionFilter.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearSubdivisionFilter.NewInstance">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearSubdivisionFilter.IsA(System.String)">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearSubdivisionFilter.GetClassName">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatingSubdivisionFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInterpolatingSubdivisionFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInterpolatingSubdivisionFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolatingSubdivisionFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolatingSubdivisionFilter.GetNumberOfSubdivisions">
            <summary>
                <para>Set/get the number of subdivisions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolatingSubdivisionFilter.SetNumberOfSubdivisions(System.Int32)">
            <summary>
                <para>Set/get the number of subdivisions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.GetExtrusionPoint">
            <summary>
                <para>Set/Get extrusion point. Only needs to be set if PointExtrusion is turned on. This is the point towards which extrusion occurs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetExtrusionPoint(System.Double[])">
            <summary>
                <para>Set/Get extrusion point. Only needs to be set if PointExtrusion is turned on. This is the point towards which extrusion occurs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetExtrusionPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get extrusion point. Only needs to be set if PointExtrusion is turned on. This is the point towards which extrusion occurs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.GetVector">
            <summary>
                <para>Set/Get extrusion vector. Only needs to be set if VectorExtrusion is turned on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetVector(System.Double[])">
            <summary>
                <para>Set/Get extrusion vector. Only needs to be set if VectorExtrusion is turned on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetVector(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get extrusion vector. Only needs to be set if VectorExtrusion is turned on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.GetScaleFactor">
            <summary>
                <para>Set/Get extrusion scale factor,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetScaleFactor(System.Double)">
            <summary>
                <para>Set/Get extrusion scale factor,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.CappingOff">
            <summary>
                <para>Turn on/off the capping of the skirt.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.CappingOn">
            <summary>
                <para>Turn on/off the capping of the skirt.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.GetCapping">
            <summary>
                <para>Turn on/off the capping of the skirt.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetCapping(System.Int32)">
            <summary>
                <para>Turn on/off the capping of the skirt.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetExtrusionTypeToPointExtrusion">
            <summary>
                <para>Set/Get the type of extrusion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetExtrusionTypeToNormalExtrusion">
            <summary>
                <para>Set/Get the type of extrusion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetExtrusionTypeToVectorExtrusion">
            <summary>
                <para>Set/Get the type of extrusion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.GetExtrusionType">
            <summary>
                <para>Set/Get the type of extrusion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.GetExtrusionTypeMaxValue">
            <summary>
                <para>Set/Get the type of extrusion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.GetExtrusionTypeMinValue">
            <summary>
                <para>Set/Get the type of extrusion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearExtrusionFilter.SetExtrusionType(System.Int32)">
            <summary>
                <para>Set/Get the type of extrusion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.GetInput">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set / get the input data or filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.ResetOutput">
            <summary>
                <para>Reset requested output levels</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.GetOutput">
            <summary>
                <para>Output of terminal nodes/leaves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.GetOutput(System.Int32)">
            <summary>
                <para>A special form of the GetOutput() method that returns multiple outputs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.GetLevel">
            <summary>
                <para>Get the maximum number of outputs actually available.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.GetSpatialRepresentation">
            <summary>
                <para>Set/Get the locator that will be used to generate the representation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpatialRepresentationFilter.SetSpatialRepresentation(vtk.vtkLocator)">
            <summary>
                <para>Set/Get the locator that will be used to generate the representation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkApproximatingSubdivisionFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkApproximatingSubdivisionFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVectorNorm.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.GetAttributeModeAsString">
            <summary>
                <para>Control how the filter works to generate scalar data from the input vector data. By default, (AttributeModeToDefault) the filter will generate the scalar norm for point and cell data (if vector data present in the input). Alternatively, you can explicitly set the filter to generate point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.SetAttributeModeToUseCellData">
            <summary>
                <para>Control how the filter works to generate scalar data from the input vector data. By default, (AttributeModeToDefault) the filter will generate the scalar norm for point and cell data (if vector data present in the input). Alternatively, you can explicitly set the filter to generate point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.SetAttributeModeToUsePointData">
            <summary>
                <para>Control how the filter works to generate scalar data from the input vector data. By default, (AttributeModeToDefault) the filter will generate the scalar norm for point and cell data (if vector data present in the input). Alternatively, you can explicitly set the filter to generate point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.SetAttributeModeToDefault">
            <summary>
                <para>Control how the filter works to generate scalar data from the input vector data. By default, (AttributeModeToDefault) the filter will generate the scalar norm for point and cell data (if vector data present in the input). Alternatively, you can explicitly set the filter to generate point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.GetAttributeMode">
            <summary>
                <para>Control how the filter works to generate scalar data from the input vector data. By default, (AttributeModeToDefault) the filter will generate the scalar norm for point and cell data (if vector data present in the input). Alternatively, you can explicitly set the filter to generate point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.SetAttributeMode(System.Int32)">
            <summary>
                <para>Control how the filter works to generate scalar data from the input vector data. By default, (AttributeModeToDefault) the filter will generate the scalar norm for point and cell data (if vector data present in the input). Alternatively, you can explicitly set the filter to generate point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.NormalizeOff">
            <summary>
                <para>Specify whether to normalize scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.NormalizeOn">
            <summary>
                <para>Specify whether to normalize scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.GetNormalize">
            <summary>
                <para>Specify whether to normalize scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorNorm.SetNormalize(System.Int32)">
            <summary>
                <para>Specify whether to normalize scalar values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.GetTransform">
            <summary>
                <para>Specify the transform object used to transform points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.SetTransform(vtk.vtkAbstractTransform)">
            <summary>
                <para>Specify the transform object used to transform points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformPolyDataFilter.GetMTime">
            <summary>
                <para>Return the MTime also considering the transform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.SetInput(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>This version of the function for the wrappers</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.SetInput(System.Double[],System.Double[],System.Double)">
            <summary>
                <para>This function for convenience for creating a Rectilinear Grid If Spacing does not fit evenly into extent, the last cell will have a different width (or height or depth). If Extent[i]/Spacing[i] is within tol of an integer, then assume the programmer meant an integer for direction i.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.RememberVoxelIdOff">
            <summary>
                <para>Should the tetrahedra have scalar data indicating which Voxel they came from in the vtkRectilinearGrid?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.RememberVoxelIdOn">
            <summary>
                <para>Should the tetrahedra have scalar data indicating which Voxel they came from in the vtkRectilinearGrid?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.GetRememberVoxelId">
            <summary>
                <para>Should the tetrahedra have scalar data indicating which Voxel they came from in the vtkRectilinearGrid?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.SetRememberVoxelId(System.Int32)">
            <summary>
                <para>Should the tetrahedra have scalar data indicating which Voxel they came from in the vtkRectilinearGrid?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.GetTetraPerCell">
            <summary>
                <para>Set the method to divide each cell (voxel) in the RectilinearGrid into tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.SetTetraPerCell(System.Int32)">
            <summary>
                <para>Set the method to divide each cell (voxel) in the RectilinearGrid into tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.SetTetraPerCellTo5And12">
            <summary>
                <para>Set the method to divide each cell (voxel) in the RectilinearGrid into tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.SetTetraPerCellTo12">
            <summary>
                <para>Set the method to divide each cell (voxel) in the RectilinearGrid into tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.SetTetraPerCellTo6">
            <summary>
                <para>Set the method to divide each cell (voxel) in the RectilinearGrid into tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridToTetrahedra.SetTetraPerCellTo5">
            <summary>
                <para>Set the method to divide each cell (voxel) in the RectilinearGrid into tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.GetArrayComponent">
            <summary>
                <para>Set/get which component of the scalar array to contour on; defaults to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.SetArrayComponent(System.Int32)">
            <summary>
                <para>Set/get which component of the scalar array to contour on; defaults to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.ComputeScalarsOff">
            <summary>
                <para>Option to set the point scalars of the output.  The scalars will be the  iso value of course.  By default this flag is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.ComputeScalarsOn">
            <summary>
                <para>Option to set the point scalars of the output.  The scalars will be the  iso value of course.  By default this flag is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.GetComputeScalars">
            <summary>
                <para>Option to set the point scalars of the output.  The scalars will be the  iso value of course.  By default this flag is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.SetComputeScalars(System.Int32)">
            <summary>
                <para>Option to set the point scalars of the output.  The scalars will be the  iso value of course.  By default this flag is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Option to set the point scalars of the output.  The scalars will be the  iso value of course.  By default this flag is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.GetNumberOfContours">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Get the number of contours in the list of contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.GetValues(System.Double[])">
            <summary>
                <para>Set the number of contours to place into the list. You only really need to use this method to reduce list size. The method SetValue() will automatically increase list size as needed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.GetValue(System.Int32)">
            <summary>
                <para>Get a pointer to an array of contour values. There will be GetNumberOfContours() values in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Get the ith contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates2D.GetMTime">
            <summary>
                <para>Because we delegate to vtkContourValues</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStreamTracer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetInterpolatorPrototype(vtk.vtkInterpolatedVelocityField)">
            <summary />
        </member>
        <member name="M:vtk.vtkStreamTracer.AddInput(vtk.vtkDataSet)">
            <summary>
                <para>Add a dataset to the list inputs</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegrationDirectionToBoth">
            <summary>
                <para>Specify whether the streamtrace will be generated in the upstream or downstream direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegrationDirectionToBackward">
            <summary>
                <para>Specify whether the streamtrace will be generated in the upstream or downstream direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegrationDirectionToForward">
            <summary>
                <para>Specify whether the streamtrace will be generated in the upstream or downstream direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetIntegrationDirection">
            <summary>
                <para>Specify whether the streamtrace will be generated in the upstream or downstream direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetIntegrationDirectionMaxValue">
            <summary>
                <para>Specify whether the streamtrace will be generated in the upstream or downstream direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetIntegrationDirectionMinValue">
            <summary>
                <para>Specify whether the streamtrace will be generated in the upstream or downstream direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegrationDirection(System.Int32)">
            <summary>
                <para>Specify whether the streamtrace will be generated in the upstream or downstream direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetInitialIntegrationStepUnitToCellLengthUnit">
            <summary>
                <para>Specify the initial step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is the actual step used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetInitialIntegrationStepUnitToLengthUnit">
            <summary>
                <para>Specify the initial step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is the actual step used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetInitialIntegrationStepUnitToTimeUnit">
            <summary>
                <para>Specify the initial step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is the actual step used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetInitialIntegrationStep">
            <summary>
                <para>Specify the initial step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is the actual step used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetInitialIntegrationStepUnit">
            <summary>
                <para>Specify the initial step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is the actual step used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetInitialIntegrationStep(System.Double)">
            <summary>
                <para>Specify the initial step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is the actual step used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetInitialIntegrationStepUnit(System.Int32)">
            <summary>
                <para>Specify the initial step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is the actual step used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetInitialIntegrationStep(System.Int32,System.Double)">
            <summary>
                <para>Specify the initial step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is the actual step used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumIntegrationStepUnitToCellLengthUnit">
            <summary>
                <para>Specify the maximum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumIntegrationStepUnitToLengthUnit">
            <summary>
                <para>Specify the maximum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumIntegrationStepUnitToTimeUnit">
            <summary>
                <para>Specify the maximum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetMaximumIntegrationStep">
            <summary>
                <para>Specify the maximum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetMaximumIntegrationStepUnit">
            <summary>
                <para>Specify the maximum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumIntegrationStep(System.Double)">
            <summary>
                <para>Specify the maximum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumIntegrationStepUnit(System.Int32)">
            <summary>
                <para>Specify the maximum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumIntegrationStep(System.Int32,System.Double)">
            <summary>
                <para>Specify the maximum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMinimumIntegrationStepUnitToCellLengthUnit">
            <summary>
                <para>Specify the minimum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMinimumIntegrationStepUnitToLengthUnit">
            <summary>
                <para>Specify the minimum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMinimumIntegrationStepUnitToTimeUnit">
            <summary>
                <para>Specify the minimum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetMinimumIntegrationStep">
            <summary>
                <para>Specify the minimum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetMinimumIntegrationStepUnit">
            <summary>
                <para>Specify the minimum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMinimumIntegrationStep(System.Double)">
            <summary>
                <para>Specify the minimum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMinimumIntegrationStepUnit(System.Int32)">
            <summary>
                <para>Specify the minimum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMinimumIntegrationStep(System.Int32,System.Double)">
            <summary>
                <para>Specify the minimum step used in the integration expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumPropagationUnitToCellLengthUnit">
            <summary>
                <para>Specify the maximum length of the streamlines expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumPropagationUnitToLengthUnit">
            <summary>
                <para>Specify the maximum length of the streamlines expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumPropagationUnitToTimeUnit">
            <summary>
                <para>Specify the maximum length of the streamlines expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetMaximumPropagation">
            <summary>
                <para>Specify the maximum length of the streamlines expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetMaximumPropagationUnit">
            <summary>
                <para>Specify the maximum length of the streamlines expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumPropagationUnit(System.Int32)">
            <summary>
                <para>Specify the maximum length of the streamlines expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumPropagation(System.Double)">
            <summary>
                <para>Specify the maximum length of the streamlines expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetMaximumPropagation(System.Int32,System.Double)">
            <summary>
                <para>Specify the maximum length of the streamlines expressed in  one of the:  TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegratorTypeToRungeKutta45">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance in the process of integration  (prototype pattern). The default is 2nd order Runge Kutta. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegratorTypeToRungeKutta4">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance in the process of integration  (prototype pattern). The default is 2nd order Runge Kutta. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegratorTypeToRungeKutta2">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance in the process of integration  (prototype pattern). The default is 2nd order Runge Kutta. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetIntegratorType">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance in the process of integration  (prototype pattern). The default is 2nd order Runge Kutta. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegratorType(System.Int32)">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance in the process of integration  (prototype pattern). The default is 2nd order Runge Kutta. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetIntegrator">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance in the process of integration  (prototype pattern). The default is 2nd order Runge Kutta. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetIntegrator(vtk.vtkInitialValueProblemSolver)">
            <summary>
                <para>Set/get the integrator type to be used in the stream line calculation. The object passed is not actually used but is cloned with NewInstance in the process of integration  (prototype pattern). The default is 2nd order Runge Kutta. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetSourceConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Specify the source object used to generate starting points. New style.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetSource">
            <summary>
                <para>Specify the source object used to generate starting points. Old style. Do not use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetSource(vtk.vtkDataSet)">
            <summary>
                <para>Specify the source object used to generate starting points. Old style. Do not use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.GetStartPosition">
            <summary>
                <para>Specify the start of the streamline in the global coordinate system. Search must be performed to find initial cell to start integration from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetStartPosition(System.Double[])">
            <summary>
                <para>Specify the start of the streamline in the global coordinate system. Search must be performed to find initial cell to start integration from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStreamTracer.SetStartPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the start of the streamline in the global coordinate system. Search must be performed to find initial cell to start integration from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GeneratePolylineOff">
            <summary>
                <para>Control whether a polyline is produced. By default, GeneratePolyline is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GeneratePolylineOn">
            <summary>
                <para>Control whether a polyline is produced. By default, GeneratePolyline is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetGeneratePolyline">
            <summary>
                <para>Control whether a polyline is produced. By default, GeneratePolyline is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SetGeneratePolyline(System.Int32)">
            <summary>
                <para>Control whether a polyline is produced. By default, GeneratePolyline is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GeneratePolygonOff">
            <summary>
                <para>Control whether a polygon is produced. By default, GeneratePolygon is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GeneratePolygonOn">
            <summary>
                <para>Control whether a polygon is produced. By default, GeneratePolygon is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetGeneratePolygon">
            <summary>
                <para>Control whether a polygon is produced. By default, GeneratePolygon is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SetGeneratePolygon(System.Int32)">
            <summary>
                <para>Control whether a polygon is produced. By default, GeneratePolygon is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetRadius">
            <summary>
                <para>Set/Get the radius of the polygon. By default, the radius is set to 0.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SetRadius(System.Double)">
            <summary>
                <para>Set/Get the radius of the polygon. By default, the radius is set to 0.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetNormal">
            <summary>
                <para>Set/Get the normal to the polygon. The ordering of the polygon will be counter-clockwise around the normal (i.e., using the right-hand rule). By default, the normal is set to (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SetNormal(System.Double[])">
            <summary>
                <para>Set/Get the normal to the polygon. The ordering of the polygon will be counter-clockwise around the normal (i.e., using the right-hand rule). By default, the normal is set to (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SetNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the normal to the polygon. The ordering of the polygon will be counter-clockwise around the normal (i.e., using the right-hand rule). By default, the normal is set to (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetCenter">
            <summary>
                <para>Set/Get the center of the polygon. By default, the center is set at the origin (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SetCenter(System.Double[])">
            <summary>
                <para>Set/Get the center of the polygon. By default, the center is set at the origin (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the center of the polygon. By default, the center is set at the origin (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetNumberOfSides">
            <summary>
                <para>Set/Get the number of sides of the polygon. By default, the number of sides is set to six.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetNumberOfSidesMaxValue">
            <summary>
                <para>Set/Get the number of sides of the polygon. By default, the number of sides is set to six.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetNumberOfSidesMinValue">
            <summary>
                <para>Set/Get the number of sides of the polygon. By default, the number of sides is set to six.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SetNumberOfSides(System.Int32)">
            <summary>
                <para>Set/Get the number of sides of the polygon. By default, the number of sides is set to six.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard methods for instantiation, obtaining type and printing instance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.NewInstance">
            <summary>
                <para>Standard methods for instantiation, obtaining type and printing instance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.IsA(System.String)">
            <summary>
                <para>Standard methods for instantiation, obtaining type and printing instance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRegularPolygonSource.GetClassName">
            <summary>
                <para>Standard methods for instantiation, obtaining type and printing instance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPlaneSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.Push(System.Double)">
            <summary>
                <para>Translate the plane in the direction of the normal by the distance specified.  Negative values move the plane in the opposite direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.GetNormal">
            <summary>
                <para>Set/Get the plane normal. Works in conjunction with the plane center to orient the plane. Don't use this method to define the plane. Instead, use it to rotate the plane around the current center point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetNormal(System.Double[])">
            <summary>
                <para>Set/Get the plane normal. Works in conjunction with the plane center to orient the plane. Don't use this method to define the plane. Instead, use it to rotate the plane around the current center point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the plane normal. Works in conjunction with the plane center to orient the plane. Don't use this method to define the plane. Instead, use it to rotate the plane around the current center point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.GetCenter">
            <summary>
                <para>Set/Get the center of the plane. Works in conjunction with the plane  normal to position the plane. Don't use this method to define the plane. Instead, use it to move the plane to a new center point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetCenter(System.Double[])">
            <summary>
                <para>Set/Get the center of the plane. Works in conjunction with the plane  normal to position the plane. Don't use this method to define the plane. Instead, use it to move the plane to a new center point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the center of the plane. Works in conjunction with the plane  normal to position the plane. Don't use this method to define the plane. Instead, use it to move the plane to a new center point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.GetPoint2">
            <summary>
                <para>Specify a point defining the second axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetPoint2(System.Double[])">
            <summary>
                <para>Specify a point defining the second axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetPoint2(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point defining the second axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.GetPoint1">
            <summary>
                <para>Specify a point defining the first axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetPoint1(System.Double[])">
            <summary>
                <para>Specify a point defining the first axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetPoint1(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point defining the first axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.GetOrigin">
            <summary>
                <para>Specify a point defining the origin of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetOrigin(System.Double[])">
            <summary>
                <para>Specify a point defining the origin of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point defining the origin of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.GetResolution(System.Int32@,System.Int32@)">
            <summary>
                <para>Set the number of x-y subdivisions in the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetResolution(System.Int32,System.Int32)">
            <summary>
                <para>Set the number of x-y subdivisions in the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.GetYResolution">
            <summary>
                <para>Specify the resolution of the plane along the second axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetYResolution(System.Int32)">
            <summary>
                <para>Specify the resolution of the plane along the second axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.GetXResolution">
            <summary>
                <para>Specify the resolution of the plane along the first axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneSource.SetXResolution(System.Int32)">
            <summary>
                <para>Specify the resolution of the plane along the first axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.GetCoolDownRate">
            <summary>
                <para>Set/Get the Cool-down rate. The higher this number is, the longer it will take to "cool-down", and thus, the more the graph will be modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.GetCoolDownRateMaxValue">
            <summary>
                <para>Set/Get the Cool-down rate. The higher this number is, the longer it will take to "cool-down", and thus, the more the graph will be modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.GetCoolDownRateMinValue">
            <summary>
                <para>Set/Get the Cool-down rate. The higher this number is, the longer it will take to "cool-down", and thus, the more the graph will be modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.SetCoolDownRate(System.Double)">
            <summary>
                <para>Set/Get the Cool-down rate. The higher this number is, the longer it will take to "cool-down", and thus, the more the graph will be modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.GetMaxNumberOfIterations">
            <summary>
                <para>Set/Get the maximum number of iterations to be used. The higher this number, the more iterations through the algorithm is possible, and thus, the more the graph gets modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.GetMaxNumberOfIterationsMaxValue">
            <summary>
                <para>Set/Get the maximum number of iterations to be used. The higher this number, the more iterations through the algorithm is possible, and thus, the more the graph gets modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.GetMaxNumberOfIterationsMinValue">
            <summary>
                <para>Set/Get the maximum number of iterations to be used. The higher this number, the more iterations through the algorithm is possible, and thus, the more the graph gets modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.SetMaxNumberOfIterations(System.Int32)">
            <summary>
                <para>Set/Get the maximum number of iterations to be used. The higher this number, the more iterations through the algorithm is possible, and thus, the more the graph gets modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.AutomaticBoundsComputationOff">
            <summary>
                <para>Turn on/off automatic graph bounds calculation. If this boolean is off, then the manually specified GraphBounds is used. If on, then the input's bounds us used as the graph bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.AutomaticBoundsComputationOn">
            <summary>
                <para>Turn on/off automatic graph bounds calculation. If this boolean is off, then the manually specified GraphBounds is used. If on, then the input's bounds us used as the graph bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.GetAutomaticBoundsComputation">
            <summary>
                <para>Turn on/off automatic graph bounds calculation. If this boolean is off, then the manually specified GraphBounds is used. If on, then the input's bounds us used as the graph bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.SetAutomaticBoundsComputation(System.Int32)">
            <summary>
                <para>Turn on/off automatic graph bounds calculation. If this boolean is off, then the manually specified GraphBounds is used. If on, then the input's bounds us used as the graph bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.GetGraphBounds">
            <summary>
                <para>Set / get the region in space in which to place the final graph. The GraphBounds only affects the results if AutomaticBoundsComputation is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.SetGraphBounds(System.Double[])">
            <summary>
                <para>Set / get the region in space in which to place the final graph. The GraphBounds only affects the results if AutomaticBoundsComputation is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphLayoutFilter.SetGraphBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the region in space in which to place the final graph. The GraphBounds only affects the results if AutomaticBoundsComputation is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.ComputeSpacing(vtk.vtkRectilinearGrid,System.Int32,System.Int32,System.Int32,System.Int32[],System.Double[])">
            <summary>
                <para>Compute the spacing between this point and its 6 neighbors.  This method needs to be public so it can be accessed from a templated function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GetArrayComponent">
            <summary>
                <para>Set/get which component of the scalar array to contour on; defaults to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.SetArrayComponent(System.Int32)">
            <summary>
                <para>Set/get which component of the scalar array to contour on; defaults to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Needed by templated functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GetNumberOfContours">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Get the number of contours in the list of contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GetValues(System.Double[])">
            <summary>
                <para>Set the number of contours to place into the list. You only really need to use this method to reduce list size. The method SetValue() will automatically increase list size as needed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GetValue(System.Int32)">
            <summary>
                <para>Get a pointer to an array of contour values. There will be GetNumberOfContours() values in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Get the ith contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.ComputeScalarsOff">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.ComputeScalarsOn">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GetComputeScalars">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.SetComputeScalars(System.Int32)">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.ComputeGradientsOff">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.ComputeGradientsOn">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GetComputeGradients">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.SetComputeGradients(System.Int32)">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearSynchronizedTemplates.GetMTime">
            <summary>
                <para>Because we delegate to vtkContourValues</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetActualReduction">
            <summary>
                <para>Get the actual reduction. This value is only valid after the filter has executed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetTensorsWeight">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetTCoordsWeight">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetNormalsWeight">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetVectorsWeight">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetScalarsWeight">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetTensorsWeight(System.Double)">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetTCoordsWeight(System.Double)">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetNormalsWeight(System.Double)">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetVectorsWeight(System.Double)">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetScalarsWeight(System.Double)">
            <summary>
                <para>Set/Get the scaling weight contribution of the attribute. These values are used to weight the contribution of the attributes towards the error metric.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.TensorsAttributeOff">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.TensorsAttributeOn">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetTensorsAttribute">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetTensorsAttribute(System.Int32)">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.TCoordsAttributeOff">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.TCoordsAttributeOn">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetTCoordsAttribute">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetTCoordsAttribute(System.Int32)">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.NormalsAttributeOff">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.NormalsAttributeOn">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetNormalsAttribute">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetNormalsAttribute(System.Int32)">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.VectorsAttributeOff">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.VectorsAttributeOn">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetVectorsAttribute">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetVectorsAttribute(System.Int32)">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.ScalarsAttributeOff">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.ScalarsAttributeOn">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetScalarsAttribute">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetScalarsAttribute(System.Int32)">
            <summary>
                <para>If attribute errors are to be included in the metric (i.e., AttributeErrorMetric is on), then the following flags control which attributes are to be included in the error calculation. By default all of these are on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.AttributeErrorMetricOff">
            <summary>
                <para>Decide whether to include data attributes in the error metric. If off, then only geometric error is used to control the decimation. By default the attribute errors are off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.AttributeErrorMetricOn">
            <summary>
                <para>Decide whether to include data attributes in the error metric. If off, then only geometric error is used to control the decimation. By default the attribute errors are off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetAttributeErrorMetric">
            <summary>
                <para>Decide whether to include data attributes in the error metric. If off, then only geometric error is used to control the decimation. By default the attribute errors are off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetAttributeErrorMetric(System.Int32)">
            <summary>
                <para>Decide whether to include data attributes in the error metric. If off, then only geometric error is used to control the decimation. By default the attribute errors are off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetTargetReduction">
            <summary>
                <para>Set/Get the desired reduction (expressed as a fraction of the original number of triangles). The actual reduction may be less depending on triangulation and topological constraints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetTargetReductionMaxValue">
            <summary>
                <para>Set/Get the desired reduction (expressed as a fraction of the original number of triangles). The actual reduction may be less depending on triangulation and topological constraints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.GetTargetReductionMinValue">
            <summary>
                <para>Set/Get the desired reduction (expressed as a fraction of the original number of triangles). The actual reduction may be less depending on triangulation and topological constraints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricDecimation.SetTargetReduction(System.Double)">
            <summary>
                <para>Set/Get the desired reduction (expressed as a fraction of the original number of triangles). The actual reduction may be less depending on triangulation and topological constraints.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.SetSolidTypeToIcosahedron">
            <summary>
                <para>Specify the type of PlatonicSolid solid to create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.SetSolidTypeToOctahedron">
            <summary>
                <para>Specify the type of PlatonicSolid solid to create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.SetSolidTypeToCube">
            <summary>
                <para>Specify the type of PlatonicSolid solid to create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.SetSolidTypeToTetrahedron">
            <summary>
                <para>Specify the type of PlatonicSolid solid to create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.GetSolidType">
            <summary>
                <para>Specify the type of PlatonicSolid solid to create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.GetSolidTypeMaxValue">
            <summary>
                <para>Specify the type of PlatonicSolid solid to create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.GetSolidTypeMinValue">
            <summary>
                <para>Specify the type of PlatonicSolid solid to create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlatonicSolidSource.SetSolidType(System.Int32)">
            <summary>
                <para>Specify the type of PlatonicSolid solid to create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOutlineFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOutlineFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTo.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTo.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTo.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWarpTo.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTo.AbsoluteOff">
            <summary>
                <para>Set/Get the Absolute ivar. Turning Absolute on causes scale factor of the new position to be one unit away from Position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.AbsoluteOn">
            <summary>
                <para>Set/Get the Absolute ivar. Turning Absolute on causes scale factor of the new position to be one unit away from Position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.GetAbsolute">
            <summary>
                <para>Set/Get the Absolute ivar. Turning Absolute on causes scale factor of the new position to be one unit away from Position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.SetAbsolute(System.Int32)">
            <summary>
                <para>Set/Get the Absolute ivar. Turning Absolute on causes scale factor of the new position to be one unit away from Position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.SetPosition(System.Double[])">
            <summary>
                <para>Set/Get the position to warp towards.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.SetPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the position to warp towards.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.GetPosition">
            <summary>
                <para>Set/Get the position to warp towards.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.GetScaleFactor">
            <summary>
                <para>Set/Get the value to scale displacement.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTo.SetScaleFactor(System.Double)">
            <summary>
                <para>Set/Get the value to scale displacement.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsGeometryFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredPointsGeometryFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsGeometryFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredPointsGeometryFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.GetT">
            <summary>
                <para>Specify interpolation parameter t.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.GetTMaxValue">
            <summary>
                <para>Specify interpolation parameter t.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.GetTMinValue">
            <summary>
                <para>Specify interpolation parameter t.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.SetT(System.Double)">
            <summary>
                <para>Specify interpolation parameter t.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInterpolateDataSetAttributes.GetInputList">
            <summary>
                <para>Return the list of inputs to this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDicer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDicer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDicer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDicer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDicer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDicer.GetMemoryLimit">
            <summary>
                <para>Control piece size based on a memory limit.  (This ivar has effect only when the DiceMode is set to SetDiceModeToMemoryLimit()). The memory limit should be set in kilobytes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetMemoryLimitMaxValue">
            <summary>
                <para>Control piece size based on a memory limit.  (This ivar has effect only when the DiceMode is set to SetDiceModeToMemoryLimit()). The memory limit should be set in kilobytes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetMemoryLimitMinValue">
            <summary>
                <para>Control piece size based on a memory limit.  (This ivar has effect only when the DiceMode is set to SetDiceModeToMemoryLimit()). The memory limit should be set in kilobytes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.SetMemoryLimit(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Control piece size based on a memory limit.  (This ivar has effect only when the DiceMode is set to SetDiceModeToMemoryLimit()). The memory limit should be set in kilobytes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetNumberOfPieces">
            <summary>
                <para>Set/Get the number of pieces the object is to be separated into. (This ivar has effect only when the DiceMode is set to SetDiceModeToSpecifiedNumber()). Note that the ivar NumberOfPieces is a target - depending on the particulars of the data, more or less number of pieces than the target value may be created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetNumberOfPiecesMaxValue">
            <summary>
                <para>Set/Get the number of pieces the object is to be separated into. (This ivar has effect only when the DiceMode is set to SetDiceModeToSpecifiedNumber()). Note that the ivar NumberOfPieces is a target - depending on the particulars of the data, more or less number of pieces than the target value may be created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetNumberOfPiecesMinValue">
            <summary>
                <para>Set/Get the number of pieces the object is to be separated into. (This ivar has effect only when the DiceMode is set to SetDiceModeToSpecifiedNumber()). Note that the ivar NumberOfPieces is a target - depending on the particulars of the data, more or less number of pieces than the target value may be created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.SetNumberOfPieces(System.Int32)">
            <summary>
                <para>Set/Get the number of pieces the object is to be separated into. (This ivar has effect only when the DiceMode is set to SetDiceModeToSpecifiedNumber()). Note that the ivar NumberOfPieces is a target - depending on the particulars of the data, more or less number of pieces than the target value may be created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetNumberOfPointsPerPiece">
            <summary>
                <para>Control piece size based on the maximum number of points per piece. (This ivar has effect only when the DiceMode is set to  SetDiceModeToNumberOfPoints().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetNumberOfPointsPerPieceMaxValue">
            <summary>
                <para>Control piece size based on the maximum number of points per piece. (This ivar has effect only when the DiceMode is set to  SetDiceModeToNumberOfPoints().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetNumberOfPointsPerPieceMinValue">
            <summary>
                <para>Control piece size based on the maximum number of points per piece. (This ivar has effect only when the DiceMode is set to  SetDiceModeToNumberOfPoints().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.SetNumberOfPointsPerPiece(System.Int32)">
            <summary>
                <para>Control piece size based on the maximum number of points per piece. (This ivar has effect only when the DiceMode is set to  SetDiceModeToNumberOfPoints().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetNumberOfActualPieces">
            <summary>
                <para>Use the following method after the filter has updated to determine the actual number of pieces the data was separated into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.SetDiceModeToMemoryLimitPerPiece">
            <summary>
                <para>Specify the method to determine how many pieces the data should be broken into. By default, the number of points per piece is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.SetDiceModeToSpecifiedNumberOfPieces">
            <summary>
                <para>Specify the method to determine how many pieces the data should be broken into. By default, the number of points per piece is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.SetDiceModeToNumberOfPointsPerPiece">
            <summary>
                <para>Specify the method to determine how many pieces the data should be broken into. By default, the number of points per piece is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetDiceMode">
            <summary>
                <para>Specify the method to determine how many pieces the data should be broken into. By default, the number of points per piece is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetDiceModeMaxValue">
            <summary>
                <para>Specify the method to determine how many pieces the data should be broken into. By default, the number of points per piece is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetDiceModeMinValue">
            <summary>
                <para>Specify the method to determine how many pieces the data should be broken into. By default, the number of points per piece is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.SetDiceMode(System.Int32)">
            <summary>
                <para>Specify the method to determine how many pieces the data should be broken into. By default, the number of points per piece is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.FieldDataOff">
            <summary>
                <para>Set/Get the flag which controls whether to generate point scalar data or point field data. If this flag is off, scalar data is generated.  Otherwise, field data is generated. Note that the generated the data are integer numbers indicating which piece a particular point belongs to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.FieldDataOn">
            <summary>
                <para>Set/Get the flag which controls whether to generate point scalar data or point field data. If this flag is off, scalar data is generated.  Otherwise, field data is generated. Note that the generated the data are integer numbers indicating which piece a particular point belongs to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.GetFieldData">
            <summary>
                <para>Set/Get the flag which controls whether to generate point scalar data or point field data. If this flag is off, scalar data is generated.  Otherwise, field data is generated. Note that the generated the data are integer numbers indicating which piece a particular point belongs to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDicer.SetFieldData(System.Int32)">
            <summary>
                <para>Set/Get the flag which controls whether to generate point scalar data or point field data. If this flag is off, scalar data is generated.  Otherwise, field data is generated. Note that the generated the data are integer numbers indicating which piece a particular point belongs to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.GetCornerFactor">
            <summary>
                <para>Set/Get the factor that controls the relative size of the corners to the length of the corresponding bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.GetCornerFactorMaxValue">
            <summary>
                <para>Set/Get the factor that controls the relative size of the corners to the length of the corresponding bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.GetCornerFactorMinValue">
            <summary>
                <para>Set/Get the factor that controls the relative size of the corners to the length of the corresponding bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerSource.SetCornerFactor(System.Double)">
            <summary>
                <para>Set/Get the factor that controls the relative size of the corners to the length of the corresponding bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.GetOutTextureCoord">
            <summary>
                <para>Set the texture coordinate value for point NOT satisfying threshold  criterion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.SetOutTextureCoord(System.Double[])">
            <summary>
                <para>Set the texture coordinate value for point NOT satisfying threshold  criterion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.SetOutTextureCoord(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the texture coordinate value for point NOT satisfying threshold  criterion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.GetInTextureCoord">
            <summary>
                <para>Set the texture coordinate value for point satisfying threshold criterion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.SetInTextureCoord(System.Double[])">
            <summary>
                <para>Set the texture coordinate value for point satisfying threshold criterion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.SetInTextureCoord(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the texture coordinate value for point satisfying threshold criterion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.GetTextureDimension">
            <summary>
                <para>Set the desired dimension of the texture map.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.GetTextureDimensionMaxValue">
            <summary>
                <para>Set the desired dimension of the texture map.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.GetTextureDimensionMinValue">
            <summary>
                <para>Set the desired dimension of the texture map.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.SetTextureDimension(System.Int32)">
            <summary>
                <para>Set the desired dimension of the texture map.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.GetLowerThreshold">
            <summary>
                <para>Return the upper and lower thresholds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.GetUpperThreshold">
            <summary>
                <para>Return the upper and lower thresholds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.ThresholdBetween(System.Double,System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are between lower and upper thresholds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.ThresholdByUpper(System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are less than upper threshold.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThresholdTextureCoords.ThresholdByLower(System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are less than lower threshold.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDecimatePro.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetInflectionPoints(System.Double[])">
            <summary>
                <para>Get a list of inflection points. These are double values 0 &lt; r &lt;= 1.0  corresponding to reduction level, and there are a total of NumberOfInflectionPoints() values. You must provide an array (of the correct size) into which the inflection points are written.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetNumberOfInflectionPoints">
            <summary>
                <para>Get the number of inflection points. Only returns a valid value after the filter has executed.  The values in the list are mesh reduction values at each inflection point. Note: the first inflection point always occurs right before non-planar triangles are decimated (i.e., as the error becomes non-zero).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetInflectionPointRatio">
            <summary>
                <para>Specify the inflection point ratio. An inflection point occurs when the ratio of reduction error between two iterations is greater than or equal to the InflectionPointRatio.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetInflectionPointRatioMaxValue">
            <summary>
                <para>Specify the inflection point ratio. An inflection point occurs when the ratio of reduction error between two iterations is greater than or equal to the InflectionPointRatio.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetInflectionPointRatioMinValue">
            <summary>
                <para>Specify the inflection point ratio. An inflection point occurs when the ratio of reduction error between two iterations is greater than or equal to the InflectionPointRatio.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetInflectionPointRatio(System.Double)">
            <summary>
                <para>Specify the inflection point ratio. An inflection point occurs when the ratio of reduction error between two iterations is greater than or equal to the InflectionPointRatio.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetDegree">
            <summary>
                <para>If the number of triangles connected to a vertex exceeds "Degree", then the vertex will be split. (NOTE: the complexity of the triangulation algorithm is proportional to Degree^2. Setting degree small can improve the performance of the algorithm.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetDegreeMaxValue">
            <summary>
                <para>If the number of triangles connected to a vertex exceeds "Degree", then the vertex will be split. (NOTE: the complexity of the triangulation algorithm is proportional to Degree^2. Setting degree small can improve the performance of the algorithm.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetDegreeMinValue">
            <summary>
                <para>If the number of triangles connected to a vertex exceeds "Degree", then the vertex will be split. (NOTE: the complexity of the triangulation algorithm is proportional to Degree^2. Setting degree small can improve the performance of the algorithm.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetDegree(System.Int32)">
            <summary>
                <para>If the number of triangles connected to a vertex exceeds "Degree", then the vertex will be split. (NOTE: the complexity of the triangulation algorithm is proportional to Degree^2. Setting degree small can improve the performance of the algorithm.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.BoundaryVertexDeletionOff">
            <summary>
                <para>Turn on/off the deletion of vertices on the boundary of a mesh. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.BoundaryVertexDeletionOn">
            <summary>
                <para>Turn on/off the deletion of vertices on the boundary of a mesh. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetBoundaryVertexDeletion">
            <summary>
                <para>Turn on/off the deletion of vertices on the boundary of a mesh. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetBoundaryVertexDeletion(System.Int32)">
            <summary>
                <para>Turn on/off the deletion of vertices on the boundary of a mesh. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetAbsoluteError">
            <summary>
                <para>Same as MaximumError, but to be used when ErrorIsAbsolute is 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetAbsoluteErrorMaxValue">
            <summary>
                <para>Same as MaximumError, but to be used when ErrorIsAbsolute is 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetAbsoluteErrorMinValue">
            <summary>
                <para>Same as MaximumError, but to be used when ErrorIsAbsolute is 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetAbsoluteError(System.Double)">
            <summary>
                <para>Same as MaximumError, but to be used when ErrorIsAbsolute is 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetErrorIsAbsolute">
            <summary>
                <para>The MaximumError is normally defined as a fraction of the dataset bounding diagonal. By setting ErrorIsAbsolute to 1, the error is instead defined as that specified by AbsoluteError. By default ErrorIsAbsolute=0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetErrorIsAbsolute(System.Int32)">
            <summary>
                <para>The MaximumError is normally defined as a fraction of the dataset bounding diagonal. By setting ErrorIsAbsolute to 1, the error is instead defined as that specified by AbsoluteError. By default ErrorIsAbsolute=0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.AccumulateErrorOff">
            <summary>
                <para>The computed error can either be computed directly from the mesh or the error may be accumulated as the mesh is modified. If the error is accumulated, then it represents a global error bounds, and the ivar MaximumError becomes a global bounds on mesh error. Accumulating the error requires extra memory proportional to the number of vertices in the mesh. If AccumulateError is off, then the error is not accumulated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.AccumulateErrorOn">
            <summary>
                <para>The computed error can either be computed directly from the mesh or the error may be accumulated as the mesh is modified. If the error is accumulated, then it represents a global error bounds, and the ivar MaximumError becomes a global bounds on mesh error. Accumulating the error requires extra memory proportional to the number of vertices in the mesh. If AccumulateError is off, then the error is not accumulated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetAccumulateError">
            <summary>
                <para>The computed error can either be computed directly from the mesh or the error may be accumulated as the mesh is modified. If the error is accumulated, then it represents a global error bounds, and the ivar MaximumError becomes a global bounds on mesh error. Accumulating the error requires extra memory proportional to the number of vertices in the mesh. If AccumulateError is off, then the error is not accumulated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetAccumulateError(System.Int32)">
            <summary>
                <para>The computed error can either be computed directly from the mesh or the error may be accumulated as the mesh is modified. If the error is accumulated, then it represents a global error bounds, and the ivar MaximumError becomes a global bounds on mesh error. Accumulating the error requires extra memory proportional to the number of vertices in the mesh. If AccumulateError is off, then the error is not accumulated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetMaximumError">
            <summary>
                <para>Set the largest decimation error that is allowed during the decimation process. This may limit the maximum reduction that may be achieved. The maximum error is specified as a fraction of the maximum length of the input data bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetMaximumErrorMaxValue">
            <summary>
                <para>Set the largest decimation error that is allowed during the decimation process. This may limit the maximum reduction that may be achieved. The maximum error is specified as a fraction of the maximum length of the input data bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetMaximumErrorMinValue">
            <summary>
                <para>Set the largest decimation error that is allowed during the decimation process. This may limit the maximum reduction that may be achieved. The maximum error is specified as a fraction of the maximum length of the input data bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetMaximumError(System.Double)">
            <summary>
                <para>Set the largest decimation error that is allowed during the decimation process. This may limit the maximum reduction that may be achieved. The maximum error is specified as a fraction of the maximum length of the input data bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.PreSplitMeshOff">
            <summary>
                <para>In some cases you may wish to split the mesh prior to algorithm execution. This separates the mesh into semi-planar patches, which are disconnected from each other. This can give superior results in some cases. If the ivar PreSplitMesh ivar is enabled, the mesh is split with the specified SplitAngle. Otherwise mesh splitting is deferred as long as possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.PreSplitMeshOn">
            <summary>
                <para>In some cases you may wish to split the mesh prior to algorithm execution. This separates the mesh into semi-planar patches, which are disconnected from each other. This can give superior results in some cases. If the ivar PreSplitMesh ivar is enabled, the mesh is split with the specified SplitAngle. Otherwise mesh splitting is deferred as long as possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetPreSplitMesh">
            <summary>
                <para>In some cases you may wish to split the mesh prior to algorithm execution. This separates the mesh into semi-planar patches, which are disconnected from each other. This can give superior results in some cases. If the ivar PreSplitMesh ivar is enabled, the mesh is split with the specified SplitAngle. Otherwise mesh splitting is deferred as long as possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetPreSplitMesh(System.Int32)">
            <summary>
                <para>In some cases you may wish to split the mesh prior to algorithm execution. This separates the mesh into semi-planar patches, which are disconnected from each other. This can give superior results in some cases. If the ivar PreSplitMesh ivar is enabled, the mesh is split with the specified SplitAngle. Otherwise mesh splitting is deferred as long as possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetSplitAngle">
            <summary>
                <para>Specify the mesh split angle. This angle is used to control the splitting of the mesh. A split line exists when the surface normals between two edge connected triangles are &gt;= SplitAngle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetSplitAngleMaxValue">
            <summary>
                <para>Specify the mesh split angle. This angle is used to control the splitting of the mesh. A split line exists when the surface normals between two edge connected triangles are &gt;= SplitAngle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetSplitAngleMinValue">
            <summary>
                <para>Specify the mesh split angle. This angle is used to control the splitting of the mesh. A split line exists when the surface normals between two edge connected triangles are &gt;= SplitAngle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetSplitAngle(System.Double)">
            <summary>
                <para>Specify the mesh split angle. This angle is used to control the splitting of the mesh. A split line exists when the surface normals between two edge connected triangles are &gt;= SplitAngle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SplittingOff">
            <summary>
                <para>Turn on/off the splitting of the mesh at corners, along edges, at non-manifold points, or anywhere else a split is required. Turning  splitting off will better preserve the original topology of the mesh, but you may not obtain the requested reduction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SplittingOn">
            <summary>
                <para>Turn on/off the splitting of the mesh at corners, along edges, at non-manifold points, or anywhere else a split is required. Turning  splitting off will better preserve the original topology of the mesh, but you may not obtain the requested reduction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetSplitting">
            <summary>
                <para>Turn on/off the splitting of the mesh at corners, along edges, at non-manifold points, or anywhere else a split is required. Turning  splitting off will better preserve the original topology of the mesh, but you may not obtain the requested reduction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetSplitting(System.Int32)">
            <summary>
                <para>Turn on/off the splitting of the mesh at corners, along edges, at non-manifold points, or anywhere else a split is required. Turning  splitting off will better preserve the original topology of the mesh, but you may not obtain the requested reduction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetFeatureAngle">
            <summary>
                <para>Specify the mesh feature angle. This angle is used to define what an edge is (i.e., if the surface normal between two adjacent triangles is &gt;= FeatureAngle, an edge exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetFeatureAngleMaxValue">
            <summary>
                <para>Specify the mesh feature angle. This angle is used to define what an edge is (i.e., if the surface normal between two adjacent triangles is &gt;= FeatureAngle, an edge exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetFeatureAngleMinValue">
            <summary>
                <para>Specify the mesh feature angle. This angle is used to define what an edge is (i.e., if the surface normal between two adjacent triangles is &gt;= FeatureAngle, an edge exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetFeatureAngle(System.Double)">
            <summary>
                <para>Specify the mesh feature angle. This angle is used to define what an edge is (i.e., if the surface normal between two adjacent triangles is &gt;= FeatureAngle, an edge exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.PreserveTopologyOff">
            <summary>
                <para>Turn on/off whether to preserve the topology of the original mesh. If on, mesh splitting and hole elimination will not occur. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.PreserveTopologyOn">
            <summary>
                <para>Turn on/off whether to preserve the topology of the original mesh. If on, mesh splitting and hole elimination will not occur. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetPreserveTopology">
            <summary>
                <para>Turn on/off whether to preserve the topology of the original mesh. If on, mesh splitting and hole elimination will not occur. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetPreserveTopology(System.Int32)">
            <summary>
                <para>Turn on/off whether to preserve the topology of the original mesh. If on, mesh splitting and hole elimination will not occur. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetTargetReduction">
            <summary>
                <para>Specify the desired reduction in the total number of polygons (e.g., if TargetReduction is set to 0.9, this filter will try to reduce the data set to 10% of its original size). Because of various constraints, this level of reduction may not be realized. If you want to guarantee a particular reduction, you must turn off PreserveTopology, turn on SplitEdges and BoundaryVertexDeletion, and set the MaximumError to VTK_DOUBLE_MAX (these ivars are initialized this way when the object is instantiated).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetTargetReductionMaxValue">
            <summary>
                <para>Specify the desired reduction in the total number of polygons (e.g., if TargetReduction is set to 0.9, this filter will try to reduce the data set to 10% of its original size). Because of various constraints, this level of reduction may not be realized. If you want to guarantee a particular reduction, you must turn off PreserveTopology, turn on SplitEdges and BoundaryVertexDeletion, and set the MaximumError to VTK_DOUBLE_MAX (these ivars are initialized this way when the object is instantiated).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.GetTargetReductionMinValue">
            <summary>
                <para>Specify the desired reduction in the total number of polygons (e.g., if TargetReduction is set to 0.9, this filter will try to reduce the data set to 10% of its original size). Because of various constraints, this level of reduction may not be realized. If you want to guarantee a particular reduction, you must turn off PreserveTopology, turn on SplitEdges and BoundaryVertexDeletion, and set the MaximumError to VTK_DOUBLE_MAX (these ivars are initialized this way when the object is instantiated).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDecimatePro.SetTargetReduction(System.Double)">
            <summary>
                <para>Specify the desired reduction in the total number of polygons (e.g., if TargetReduction is set to 0.9, this filter will try to reduce the data set to 10% of its original size). Because of various constraints, this level of reduction may not be realized. If you want to guarantee a particular reduction, you must turn off PreserveTopology, turn on SplitEdges and BoundaryVertexDeletion, and set the MaximumError to VTK_DOUBLE_MAX (these ivars are initialized this way when the object is instantiated).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGridWithImage.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGridWithImage.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGridWithImage.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBlankStructuredGridWithImage.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGridWithImage.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGridWithImage.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGridWithImage.GetBlankingInput">
            <summary>
                <para>Set / get the input image used to perform the blanking.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGridWithImage.SetBlankingInput(vtk.vtkImageData)">
            <summary>
                <para>Set / get the input image used to perform the blanking.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProjectedTexture.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.GetTRange">
            <summary>
                <para>Specify t-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetTRange(System.Double[])">
            <summary>
                <para>Specify t-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetTRange(System.Double,System.Double)">
            <summary>
                <para>Specify t-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.GetSRange">
            <summary>
                <para>Specify s-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetSRange(System.Double[])">
            <summary>
                <para>Specify s-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetSRange(System.Double,System.Double)">
            <summary>
                <para>Specify s-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.GetOrientation">
            <summary>
                <para>Get the normalized orientation vector of the projector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.GetMirrorSeparation">
            <summary>
                <para>Set/Get the mirror separation for the two mirror system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetMirrorSeparation(System.Double)">
            <summary>
                <para>Set/Get the mirror separation for the two mirror system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetCameraModeToTwoMirror">
            <summary>
                <para>Set/Get the mirror separation for the two mirror system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetCameraModeToPinhole">
            <summary>
                <para>Set/Get the camera mode of the projection -- pinhole projection or two mirror projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.GetCameraMode">
            <summary>
                <para>Set/Get the camera mode of the projection -- pinhole projection or two mirror projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetCameraMode(System.Int32)">
            <summary>
                <para>Set/Get the camera mode of the projection -- pinhole projection or two mirror projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.GetFocalPoint">
            <summary>
                <para>Set/Get the focal point of the projector (a point that lies along the center axis of the projector's frustum).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetFocalPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the focal point of the projector (a point that lies along the center axis of the projector's frustum).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetFocalPoint(System.Double[])">
            <summary>
                <para>Set/Get the focal point of the projector (a point that lies along the center axis of the projector's frustum).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.GetPosition">
            <summary>
                <para>Set/Get the position of the focus of the projector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetPosition(System.Double[])">
            <summary>
                <para>Set/Get the position of the focus of the projector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTexture.SetPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the position of the focus of the projector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkClipVolume.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkClipVolume.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkClipVolume.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkClipVolume.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetMTime">
            <summary>
                <para>Return the mtime also considering the locator and clip function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The  locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetLocator">
            <summary>
                <para>Set / Get a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / Get a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetMergeTolerance">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the corners of voxels. This tolerance is used to prevent the generation of degenerate tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetMergeToleranceMaxValue">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the corners of voxels. This tolerance is used to prevent the generation of degenerate tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetMergeToleranceMinValue">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the corners of voxels. This tolerance is used to prevent the generation of degenerate tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.SetMergeTolerance(System.Double)">
            <summary>
                <para>Set the tolerance for merging clip intersection points that are near the corners of voxels. This tolerance is used to prevent the generation of degenerate tetrahedra.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.Mixed3DCellGenerationOff">
            <summary>
                <para>Control whether the filter produces a mix of 3D cell types on output, or whether the output cells are all tetrahedra. By default, a mixed set of cells (e.g., tetrahedra and wedges) is produced. (Note: mixed type generation is faster and less overall data is generated.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.Mixed3DCellGenerationOn">
            <summary>
                <para>Control whether the filter produces a mix of 3D cell types on output, or whether the output cells are all tetrahedra. By default, a mixed set of cells (e.g., tetrahedra and wedges) is produced. (Note: mixed type generation is faster and less overall data is generated.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetMixed3DCellGeneration">
            <summary>
                <para>Control whether the filter produces a mix of 3D cell types on output, or whether the output cells are all tetrahedra. By default, a mixed set of cells (e.g., tetrahedra and wedges) is produced. (Note: mixed type generation is faster and less overall data is generated.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.SetMixed3DCellGeneration(System.Int32)">
            <summary>
                <para>Control whether the filter produces a mix of 3D cell types on output, or whether the output cells are all tetrahedra. By default, a mixed set of cells (e.g., tetrahedra and wedges) is produced. (Note: mixed type generation is faster and less overall data is generated.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetClippedOutput">
            <summary>
                <para>Return the clipped output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GenerateClippedOutputOff">
            <summary>
                <para>Control whether a second output is generated. The second output contains the unstructured grid that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GenerateClippedOutputOn">
            <summary>
                <para>Control whether a second output is generated. The second output contains the unstructured grid that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetGenerateClippedOutput">
            <summary>
                <para>Control whether a second output is generated. The second output contains the unstructured grid that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.SetGenerateClippedOutput(System.Int32)">
            <summary>
                <para>Control whether a second output is generated. The second output contains the unstructured grid that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GenerateClipScalarsOff">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GenerateClipScalarsOn">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetGenerateClipScalars">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.SetGenerateClipScalars(System.Int32)">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.InsideOutOff">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.InsideOutOn">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetInsideOut">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.SetInsideOut(System.Int32)">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.GetValue">
            <summary>
                <para>Set the clipping value of the implicit function (if clipping with implicit function) or scalar value (if clipping with scalars). The default value is 0.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipVolume.SetValue(System.Double)">
            <summary>
                <para>Set the clipping value of the implicit function (if clipping with implicit function) or scalar value (if clipping with scalars). The default value is 0.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTensorGlyph.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetMaxScaleFactor">
            <summary>
                <para>Set/Get the maximum allowable scale factor. This value is compared to the combination of the scale factor times the eigenvalue. If less, the scale factor is reset to the MaxScaleFactor. The boolean ClampScaling has to  be "on" for this to work.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetMaxScaleFactor(System.Double)">
            <summary>
                <para>Set/Get the maximum allowable scale factor. This value is compared to the combination of the scale factor times the eigenvalue. If less, the scale factor is reset to the MaxScaleFactor. The boolean ClampScaling has to  be "on" for this to work.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ClampScalingOff">
            <summary>
                <para>Turn on/off scalar clamping. If scalar clamping is on, the ivar MaxScaleFactor is used to control the maximum scale factor. (This is useful to prevent uncontrolled scaling near singularities.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ClampScalingOn">
            <summary>
                <para>Turn on/off scalar clamping. If scalar clamping is on, the ivar MaxScaleFactor is used to control the maximum scale factor. (This is useful to prevent uncontrolled scaling near singularities.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetClampScaling">
            <summary>
                <para>Turn on/off scalar clamping. If scalar clamping is on, the ivar MaxScaleFactor is used to control the maximum scale factor. (This is useful to prevent uncontrolled scaling near singularities.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetClampScaling(System.Int32)">
            <summary>
                <para>Turn on/off scalar clamping. If scalar clamping is on, the ivar MaxScaleFactor is used to control the maximum scale factor. (This is useful to prevent uncontrolled scaling near singularities.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetColorModeToEigenvalues">
            <summary>
                <para>Set the color mode to be used for the glyphs.  This can be set to use the input scalars (default) or to use the eigenvalues at the point.  If ThreeGlyphs is set and the eigenvalues are chosen for coloring then each glyph is colored by the corresponding eigenvalue and if not set the color corresponding to the largest eigenvalue is chosen.  The recognized values are: COLOR_BY_SCALARS = 0 (default) COLOR_BY_EIGENVALUES = 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetColorModeToScalars">
            <summary>
                <para>Set the color mode to be used for the glyphs.  This can be set to use the input scalars (default) or to use the eigenvalues at the point.  If ThreeGlyphs is set and the eigenvalues are chosen for coloring then each glyph is colored by the corresponding eigenvalue and if not set the color corresponding to the largest eigenvalue is chosen.  The recognized values are: COLOR_BY_SCALARS = 0 (default) COLOR_BY_EIGENVALUES = 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetColorMode">
            <summary>
                <para>Set the color mode to be used for the glyphs.  This can be set to use the input scalars (default) or to use the eigenvalues at the point.  If ThreeGlyphs is set and the eigenvalues are chosen for coloring then each glyph is colored by the corresponding eigenvalue and if not set the color corresponding to the largest eigenvalue is chosen.  The recognized values are: COLOR_BY_SCALARS = 0 (default) COLOR_BY_EIGENVALUES = 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetColorModeMaxValue">
            <summary>
                <para>Set the color mode to be used for the glyphs.  This can be set to use the input scalars (default) or to use the eigenvalues at the point.  If ThreeGlyphs is set and the eigenvalues are chosen for coloring then each glyph is colored by the corresponding eigenvalue and if not set the color corresponding to the largest eigenvalue is chosen.  The recognized values are: COLOR_BY_SCALARS = 0 (default) COLOR_BY_EIGENVALUES = 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetColorModeMinValue">
            <summary>
                <para>Set the color mode to be used for the glyphs.  This can be set to use the input scalars (default) or to use the eigenvalues at the point.  If ThreeGlyphs is set and the eigenvalues are chosen for coloring then each glyph is colored by the corresponding eigenvalue and if not set the color corresponding to the largest eigenvalue is chosen.  The recognized values are: COLOR_BY_SCALARS = 0 (default) COLOR_BY_EIGENVALUES = 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetColorMode(System.Int32)">
            <summary>
                <para>Set the color mode to be used for the glyphs.  This can be set to use the input scalars (default) or to use the eigenvalues at the point.  If ThreeGlyphs is set and the eigenvalues are chosen for coloring then each glyph is colored by the corresponding eigenvalue and if not set the color corresponding to the largest eigenvalue is chosen.  The recognized values are: COLOR_BY_SCALARS = 0 (default) COLOR_BY_EIGENVALUES = 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ColorGlyphsOff">
            <summary>
                <para>Turn on/off coloring of glyph with input scalar data or eigenvalues. If false, or input scalar data not present, then the scalars from the source object are passed through the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ColorGlyphsOn">
            <summary>
                <para>Turn on/off coloring of glyph with input scalar data or eigenvalues. If false, or input scalar data not present, then the scalars from the source object are passed through the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetColorGlyphs">
            <summary>
                <para>Turn on/off coloring of glyph with input scalar data or eigenvalues. If false, or input scalar data not present, then the scalars from the source object are passed through the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetColorGlyphs(System.Int32)">
            <summary>
                <para>Turn on/off coloring of glyph with input scalar data or eigenvalues. If false, or input scalar data not present, then the scalars from the source object are passed through the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetExtractEigenvalues">
            <summary>
                <para>Turn on/off extraction of eigenvalues from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ExtractEigenvaluesOff">
            <summary>
                <para>Turn on/off extraction of eigenvalues from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ExtractEigenvaluesOn">
            <summary>
                <para>Turn on/off extraction of eigenvalues from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetExtractEigenvalues(System.Int32)">
            <summary>
                <para>Turn on/off extraction of eigenvalues from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetLength">
            <summary>
                <para>Set/Get the distance, along x, from the origin to the end of the  source glyph. It is used to draw the symmetric glyphs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetLength(System.Double)">
            <summary>
                <para>Set/Get the distance, along x, from the origin to the end of the  source glyph. It is used to draw the symmetric glyphs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SymmetricOff">
            <summary>
                <para>Turn on/off drawing a mirror of each glyph</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SymmetricOn">
            <summary>
                <para>Turn on/off drawing a mirror of each glyph</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetSymmetric">
            <summary>
                <para>Turn on/off drawing a mirror of each glyph</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetSymmetric(System.Int32)">
            <summary>
                <para>Turn on/off drawing a mirror of each glyph</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ThreeGlyphsOff">
            <summary>
                <para>Turn on/off drawing three glyphs</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ThreeGlyphsOn">
            <summary>
                <para>Turn on/off drawing three glyphs</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetThreeGlyphs">
            <summary>
                <para>Turn on/off drawing three glyphs</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetThreeGlyphs(System.Int32)">
            <summary>
                <para>Turn on/off drawing three glyphs</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetScaleFactor">
            <summary>
                <para>Specify scale factor to scale object by. (Scale factor always affects output even if scaling is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetScaleFactor(System.Double)">
            <summary>
                <para>Specify scale factor to scale object by. (Scale factor always affects output even if scaling is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ScalingOff">
            <summary>
                <para>Turn on/off scaling of glyph with eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.ScalingOn">
            <summary>
                <para>Turn on/off scaling of glyph with eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetScaling">
            <summary>
                <para>Turn on/off scaling of glyph with eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetScaling(System.Int32)">
            <summary>
                <para>Turn on/off scaling of glyph with eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.GetSource">
            <summary>
                <para>Specify the geometry to copy to each point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensorGlyph.SetSource(vtk.vtkPolyData)">
            <summary>
                <para>Specify the geometry to copy to each point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.GetComponent">
            <summary>
                <para>Specify the component in the data array to use to generate the blanking field.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.GetComponentMaxValue">
            <summary>
                <para>Specify the component in the data array to use to generate the blanking field.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.GetComponentMinValue">
            <summary>
                <para>Specify the component in the data array to use to generate the blanking field.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.SetComponent(System.Int32)">
            <summary>
                <para>Specify the component in the data array to use to generate the blanking field.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.GetArrayId">
            <summary>
                <para>Specify the data array id to use to generate the blanking field. Alternatively, you can specify the array name. (If both are set, the array name takes precedence.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.SetArrayId(System.Int32)">
            <summary>
                <para>Specify the data array id to use to generate the blanking field. Alternatively, you can specify the array name. (If both are set, the array name takes precedence.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.GetArrayName">
            <summary>
                <para>Specify the data array name to use to generate the blanking field. Alternatively, you can specify the array id. (If both are set, the array name takes precedence.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.SetArrayName(System.String)">
            <summary>
                <para>Specify the data array name to use to generate the blanking field. Alternatively, you can specify the array id. (If both are set, the array name takes precedence.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.GetMaxBlankingValue">
            <summary>
                <para>Specify the upper data value in the data array specified which will be converted into a "blank" (or off) value in the blanking array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.SetMaxBlankingValue(System.Double)">
            <summary>
                <para>Specify the upper data value in the data array specified which will be converted into a "blank" (or off) value in the blanking array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.GetMinBlankingValue">
            <summary>
                <para>Specify the lower data value in the data array specified which will be converted into a "blank" (or off) value in the blanking array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBlankStructuredGrid.SetMinBlankingValue(System.Double)">
            <summary>
                <para>Specify the lower data value in the data array specified which will be converted into a "blank" (or off) value in the blanking array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkKdTree.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkKdNode.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkKdNode.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkKdNode.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkKdNode.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkKdTree.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkKdTree.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkKdTree.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkKdTree.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkKdTree.NewGeometry">
            <summary>
                <para>Return 1 if the geometry of the input data sets    has changed since the last time the k-d tree was built.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetGenerateRepresentationUsingDataBounds">
            <summary>
                <para>The polydata representation of the k-d tree shows the boundaries    of the k-d tree decomposition spatial regions.  The data inside    the regions may not occupy the entire space.  To draw just the    bounds of the data in the regions, set this variable ON.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.SetGenerateRepresentationUsingDataBounds(System.Int32)">
            <summary>
                <para>The polydata representation of the k-d tree shows the boundaries    of the k-d tree decomposition spatial regions.  The data inside    the regions may not occupy the entire space.  To draw just the    bounds of the data in the regions, set this variable ON.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GenerateRepresentationUsingDataBoundsOff">
            <summary>
                <para>The polydata representation of the k-d tree shows the boundaries    of the k-d tree decomposition spatial regions.  The data inside    the regions may not occupy the entire space.  To draw just the    bounds of the data in the regions, set this variable ON.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GenerateRepresentationUsingDataBoundsOn">
            <summary>
                <para>The polydata representation of the k-d tree shows the boundaries    of the k-d tree decomposition spatial regions.  The data inside    the regions may not occupy the entire space.  To draw just the    bounds of the data in the regions, set this variable ON.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GenerateRepresentation(System.Int32[],System.Int32,vtk.vtkPolyData)">
            <summary>
                <para>Generate a polygonal representation of a list of regions.    Only leaf nodes have region IDs, so these will be leaf nodes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GenerateRepresentation(System.Int32,vtk.vtkPolyData)">
            <summary>
                <para>Create a polydata representation of the boundaries of the k-d tree regions.  If level equals GetLevel(), the leaf nodes are represented.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.FreeSearchStructure">
            <summary>
                <para>Delete the k-d tree data structure. Also delete any cell lists that were computed with CreateCellLists().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetPointsInRegion(System.Int32)">
            <summary>
                <para>Get a list of the original IDs of all points in a region.  You must have called BuildLocatorFromPoints before calling this.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.FindClosestPointInRegion(System.Int32,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Find the Id of the point in the given region which is closest to the given point.  Return the ID of the point, and set the square of the distance of between the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.FindClosestPointInRegion(System.Int32,System.Double[],System.Double@)">
            <summary>
                <para>Find the Id of the point in the given region which is closest to the given point.  Return the ID of the point, and set the square of the distance of between the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.FindClosestPoint(System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Find the Id of the point that was previously supplied to BuildLocatorFromPoints() which is closest to the given point. Set the square of the distance between the two points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.FindClosestPoint(System.Double[],System.Double@)">
            <summary>
                <para>Find the Id of the point that was previously supplied to BuildLocatorFromPoints() which is closest to the given point. Set the square of the distance between the two points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.FindPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Find the Id of the point that was previously supplied to BuildLocatorFromPoints().  Returns -1 if the point was not in the original array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.FindPoint(System.Double[])">
            <summary>
                <para>Find the Id of the point that was previously supplied to BuildLocatorFromPoints().  Returns -1 if the point was not in the original array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.BuildMapForDuplicatePoints(System.Single)">
            <summary>
                <para>This call returns a mapping from the original point IDs supplied to BuildLocatorFromPoints to a subset of those IDs that is unique  within the specified tolerance.   If points 2, 5, and 12 are the same, then  IdMap[2] = IdMap[5] = IdMap[12] = 2 (or 5 or 12).</para>
                <para>"original point IDs" - For point IDs we start at 0 for the first point in the first vtkPoints object, and increase by 1 for subsequent points and subsequent vtkPoints objects.</para>
                <para>You must have called BuildLocatorFromPoints() before calling this. You are responsible for deleting the returned array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.BuildLocatorFromPoints(vtk.vtkPoints)">
            <summary>
                <para>This is a special purpose locator that builds a k-d tree to  find duplicate and near-by points.  It builds the tree from  one or more vtkPoints objects instead of from the cells of a vtkDataSet.  This build would normally be followed by BuildMapForDuplicatePoints, FindPoint, or FindClosestPoint. Since this will build a normal k-d tree, all the region intersection queries will still work, as will most other calls except those that have "Cell" in the name.</para>
                <para>This method works most efficiently when the point arrays are float arrays.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.BuildLocator">
            <summary>
                <para>Create the k-d tree decomposition of the cells of the data set or data sets.  Cells are assigned to k-d tree spatial regions based on the location of their centroids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetRegionContainingPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Get the id of the region containing the specified location.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetRegionContainingCell(System.Int32)">
            <summary>
                <para>Get the id of the region containing the cell centroid.  If    no DataSet is specified, assume DataSet 0.  If you need the    region ID for every cell, use AllGetRegionContainingCell    instead.  It is more efficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetRegionContainingCell(System.Int32,System.Int32)">
            <summary>
                <para>Get the id of the region containing the cell centroid.  If    no DataSet is specified, assume DataSet 0.  If you need the    region ID for every cell, use AllGetRegionContainingCell    instead.  It is more efficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetRegionContainingCell(vtk.vtkDataSet,System.Int32)">
            <summary>
                <para>Get the id of the region containing the cell centroid.  If    no DataSet is specified, assume DataSet 0.  If you need the    region ID for every cell, use AllGetRegionContainingCell    instead.  It is more efficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetCellLists(vtk.vtkIntArray,vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>For a list of regions, get two cell lists.  The first lists   the IDs  all cells whose centroids lie in one of the regions.   The second lists the IDs of all cells that intersect the regions,   but whose centroid lies in a region not on the list.</para>
                <para>The total number of cell IDs written to both lists is returned.   Either list pointer passed in can be NULL, and it will be ignored.   If there are multiple data sets, you must specify which data set   you wish cell IDs for.</para>
                <para>The caller should delete these two lists when done.  This method   uses the cell lists created in CreateCellLists().   If the cell list for any of the requested regions does not   exist, then this method will call CreateCellLists() to create   cell lists for *every* region of the k-d tree.  You must remember    to DeleteCellLists() when done with all calls to this method, as    cell lists can require a great deal of memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetCellLists(vtk.vtkIntArray,vtk.vtkDataSet,vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>For a list of regions, get two cell lists.  The first lists   the IDs  all cells whose centroids lie in one of the regions.   The second lists the IDs of all cells that intersect the regions,   but whose centroid lies in a region not on the list.</para>
                <para>The total number of cell IDs written to both lists is returned.   Either list pointer passed in can be NULL, and it will be ignored.   If there are multiple data sets, you must specify which data set   you wish cell IDs for.</para>
                <para>The caller should delete these two lists when done.  This method   uses the cell lists created in CreateCellLists().   If the cell list for any of the requested regions does not   exist, then this method will call CreateCellLists() to create   cell lists for *every* region of the k-d tree.  You must remember    to DeleteCellLists() when done with all calls to this method, as    cell lists can require a great deal of memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetCellLists(vtk.vtkIntArray,System.Int32,vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>For a list of regions, get two cell lists.  The first lists   the IDs  all cells whose centroids lie in one of the regions.   The second lists the IDs of all cells that intersect the regions,   but whose centroid lies in a region not on the list.</para>
                <para>The total number of cell IDs written to both lists is returned.   Either list pointer passed in can be NULL, and it will be ignored.   If there are multiple data sets, you must specify which data set   you wish cell IDs for.</para>
                <para>The caller should delete these two lists when done.  This method   uses the cell lists created in CreateCellLists().   If the cell list for any of the requested regions does not   exist, then this method will call CreateCellLists() to create   cell lists for *every* region of the k-d tree.  You must remember    to DeleteCellLists() when done with all calls to this method, as    cell lists can require a great deal of memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetBoundaryCellList(System.Int32)">
            <summary>
                <para>The cell list obtained with GetCellList is the list    of all cells such that their centroid is contained in    the spatial region.  It may also be desirable to get    a list of all cells intersecting a spatial region,    but with centroid in some other region.  This is that    list.  This list is computed in CreateCellLists() if    and only if IncludeRegionBoundaryCells is ON.  This    returns a pointer to KdTree's memory, so don't free it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetCellList(System.Int32)">
            <summary>
                <para>Get the cell list for a region.  This returns a pointer    to vtkKdTree's memory, so don't free it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.DeleteCellLists">
            <summary>
                <para>Free the memory used by the cell lists.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.IncludeRegionBoundaryCellsOff">
            <summary>
                <para>If IncludeRegionBoundaryCells is ON,   CreateCellLists() will also create a list of cells which   intersect a given region, but are not assigned   to the region.  These lists are obtained with    GetBoundaryCellList().  Default is OFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.IncludeRegionBoundaryCellsOn">
            <summary>
                <para>If IncludeRegionBoundaryCells is ON,   CreateCellLists() will also create a list of cells which   intersect a given region, but are not assigned   to the region.  These lists are obtained with    GetBoundaryCellList().  Default is OFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetIncludeRegionBoundaryCells">
            <summary>
                <para>If IncludeRegionBoundaryCells is ON,   CreateCellLists() will also create a list of cells which   intersect a given region, but are not assigned   to the region.  These lists are obtained with    GetBoundaryCellList().  Default is OFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.SetIncludeRegionBoundaryCells(System.Int32)">
            <summary>
                <para>If IncludeRegionBoundaryCells is ON,   CreateCellLists() will also create a list of cells which   intersect a given region, but are not assigned   to the region.  These lists are obtained with    GetBoundaryCellList().  Default is OFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.PrintRegion(System.Int32)">
            <summary>
                <para>Print out leaf node data for given id</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.PrintVerboseTree">
            <summary>
                <para>Print out nodes of kd tree</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.PrintTree">
            <summary>
                <para>Print out nodes of kd tree</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetRegionDataBounds(System.Int32,System.Double[])">
            <summary>
                <para>Get the bounds of the data within the k-d tree region</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetRegionBounds(System.Int32,System.Double[])">
            <summary>
                <para>Get the spatial bounds of k-d tree region</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetNumberOfRegions">
            <summary>
                <para>The number of leaf nodes of the tree, the spatial regions</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetBounds(System.Double[])">
            <summary>
                <para>Get the spatial bounds of the entire k-d tree space. Sets    bounds array to xmin, xmax, ymin, ymax, zmin, zmax.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetDataSet(vtk.vtkDataSet)">
            <summary>
                <para>Get handle for one of the data sets included in spatial paritioning.   Handles can change after RemoveDataSet.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetDataSet">
            <summary>
                <para>Get handle for one of the data sets included in spatial paritioning.   Handles can change after RemoveDataSet.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetNumberOfDataSets">
            <summary>
                <para>Get the number of data sets included in spatial paritioning</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.OmitNoPartitioning">
            <summary>
                <para>Partition along all three axes - this is the default</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.OmitZXPartitioning">
            <summary>
                <para>Omit partitions along the Z and X axes, yielding slabs along Y</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.OmitYZPartitioning">
            <summary>
                <para>Omit partitions along the Y and Z axes, yielding slabs along X</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.OmitXYPartitioning">
            <summary>
                <para>Omit partitions along the X and Y axes, yielding slabs along Z</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.OmitZPartitioning">
            <summary>
                <para>Omit partitions along the Z axis, yielding shafts in the Z direction</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.OmitYPartitioning">
            <summary>
                <para>Omit partitions along the Y axis, yielding shafts in the Y direction</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.OmitXPartitioning">
            <summary>
                <para>Omit partitions along the X axis, yielding shafts in the X direction</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetMinCells">
            <summary>
                <para>Minimum number of cells per spatial region.  Default is 100.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.SetMinCells(System.Int32)">
            <summary>
                <para>Minimum number of cells per spatial region.  Default is 100.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.GetTiming">
            <summary>
                <para>Turn on timing of the k-d tree build</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.SetTiming(System.Int32)">
            <summary>
                <para>Turn on timing of the k-d tree build</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.TimingOff">
            <summary>
                <para>Turn on timing of the k-d tree build</para>
            </summary>
        </member>
        <member name="M:vtk.vtkKdTree.TimingOn">
            <summary>
                <para>Turn on timing of the k-d tree build</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkReflectionFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.CopyInputOff">
            <summary>
                <para>If on (the default), copy the input geometry to the output. If off, the output will only contain the reflection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.CopyInputOn">
            <summary>
                <para>If on (the default), copy the input geometry to the output. If off, the output will only contain the reflection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.GetCopyInput">
            <summary>
                <para>If on (the default), copy the input geometry to the output. If off, the output will only contain the reflection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetCopyInput(System.Int32)">
            <summary>
                <para>If on (the default), copy the input geometry to the output. If off, the output will only contain the reflection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.GetCenter">
            <summary>
                <para>If the reflection plane is set to X, Y or Z, this variable is use to set the position of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetCenter(System.Double)">
            <summary>
                <para>If the reflection plane is set to X, Y or Z, this variable is use to set the position of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToZMax">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToYMax">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToXMax">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToZMin">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToYMin">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToXMin">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToZ">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToY">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlaneToX">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.GetPlane">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.GetPlaneMaxValue">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.GetPlaneMinValue">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkReflectionFilter.SetPlane(System.Int32)">
            <summary>
                <para>Set the normal of the plane to use as mirror.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.NonManifoldTraversalOff">
            <summary>
                <para>Turn on/off traversal across non-manifold edges. This will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.NonManifoldTraversalOn">
            <summary>
                <para>Turn on/off traversal across non-manifold edges. This will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetNonManifoldTraversal">
            <summary>
                <para>Turn on/off traversal across non-manifold edges. This will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SetNonManifoldTraversal(System.Int32)">
            <summary>
                <para>Turn on/off traversal across non-manifold edges. This will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.FlipNormalsOff">
            <summary>
                <para>Turn on/off the global flipping of normal orientation. Flipping reverves the meaning of front and back for Frontface and Backface culling in vtkProperty.  Flipping modifies both the normal direction and the order of a cell's points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.FlipNormalsOn">
            <summary>
                <para>Turn on/off the global flipping of normal orientation. Flipping reverves the meaning of front and back for Frontface and Backface culling in vtkProperty.  Flipping modifies both the normal direction and the order of a cell's points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetFlipNormals">
            <summary>
                <para>Turn on/off the global flipping of normal orientation. Flipping reverves the meaning of front and back for Frontface and Backface culling in vtkProperty.  Flipping modifies both the normal direction and the order of a cell's points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SetFlipNormals(System.Int32)">
            <summary>
                <para>Turn on/off the global flipping of normal orientation. Flipping reverves the meaning of front and back for Frontface and Backface culling in vtkProperty.  Flipping modifies both the normal direction and the order of a cell's points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.ComputeCellNormalsOff">
            <summary>
                <para>Turn on/off the computation of cell normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.ComputeCellNormalsOn">
            <summary>
                <para>Turn on/off the computation of cell normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetComputeCellNormals">
            <summary>
                <para>Turn on/off the computation of cell normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SetComputeCellNormals(System.Int32)">
            <summary>
                <para>Turn on/off the computation of cell normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.ComputePointNormalsOff">
            <summary>
                <para>Turn on/off the computation of point normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.ComputePointNormalsOn">
            <summary>
                <para>Turn on/off the computation of point normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetComputePointNormals">
            <summary>
                <para>Turn on/off the computation of point normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SetComputePointNormals(System.Int32)">
            <summary>
                <para>Turn on/off the computation of point normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.AutoOrientNormalsOff">
            <summary>
                <para>Turn on/off the automatic determination of correct normal orientation. NOTE: This assumes a completely closed surface (i.e. no boundary edges) and no non-manifold edges. If these constraints do not hold, all bets are off. This option adds some computational complexity, and is useful if you don't want to have to inspect the rendered image to determine whether to turn on the  FlipNormals flag. However, this flag can work with the FlipNormals  flag, and if both are set, all the normals in the output will  point "inward".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.AutoOrientNormalsOn">
            <summary>
                <para>Turn on/off the automatic determination of correct normal orientation. NOTE: This assumes a completely closed surface (i.e. no boundary edges) and no non-manifold edges. If these constraints do not hold, all bets are off. This option adds some computational complexity, and is useful if you don't want to have to inspect the rendered image to determine whether to turn on the  FlipNormals flag. However, this flag can work with the FlipNormals  flag, and if both are set, all the normals in the output will  point "inward".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetAutoOrientNormals">
            <summary>
                <para>Turn on/off the automatic determination of correct normal orientation. NOTE: This assumes a completely closed surface (i.e. no boundary edges) and no non-manifold edges. If these constraints do not hold, all bets are off. This option adds some computational complexity, and is useful if you don't want to have to inspect the rendered image to determine whether to turn on the  FlipNormals flag. However, this flag can work with the FlipNormals  flag, and if both are set, all the normals in the output will  point "inward".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SetAutoOrientNormals(System.Int32)">
            <summary>
                <para>Turn on/off the automatic determination of correct normal orientation. NOTE: This assumes a completely closed surface (i.e. no boundary edges) and no non-manifold edges. If these constraints do not hold, all bets are off. This option adds some computational complexity, and is useful if you don't want to have to inspect the rendered image to determine whether to turn on the  FlipNormals flag. However, this flag can work with the FlipNormals  flag, and if both are set, all the normals in the output will  point "inward".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.ConsistencyOff">
            <summary>
                <para>Turn on/off the enforcement of consistent polygon ordering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.ConsistencyOn">
            <summary>
                <para>Turn on/off the enforcement of consistent polygon ordering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetConsistency">
            <summary>
                <para>Turn on/off the enforcement of consistent polygon ordering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SetConsistency(System.Int32)">
            <summary>
                <para>Turn on/off the enforcement of consistent polygon ordering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SplittingOff">
            <summary>
                <para>Turn on/off the splitting of sharp edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SplittingOn">
            <summary>
                <para>Turn on/off the splitting of sharp edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetSplitting">
            <summary>
                <para>Turn on/off the splitting of sharp edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SetSplitting(System.Int32)">
            <summary>
                <para>Turn on/off the splitting of sharp edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetFeatureAngle">
            <summary>
                <para>Specify the angle that defines a sharp edge. If the difference in angle across neighboring polygons is greater than this value, the shared edge is considered "sharp".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetFeatureAngleMaxValue">
            <summary>
                <para>Specify the angle that defines a sharp edge. If the difference in angle across neighboring polygons is greater than this value, the shared edge is considered "sharp".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.GetFeatureAngleMinValue">
            <summary>
                <para>Specify the angle that defines a sharp edge. If the difference in angle across neighboring polygons is greater than this value, the shared edge is considered "sharp".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataNormals.SetFeatureAngle(System.Double)">
            <summary>
                <para>Specify the angle that defines a sharp edge. If the difference in angle across neighboring polygons is greater than this value, the shared edge is considered "sharp".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetTriangleFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetTriangleFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetTriangleFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetTriangleFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetTriangleFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetTriangleFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkClipPolyData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GetMTime">
            <summary>
                <para>Return the mtime also considering the locator and clip function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The  locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GetLocator">
            <summary>
                <para>Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GetClippedOutputPort">
            <summary>
                <para>Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GetClippedOutput">
            <summary>
                <para>Return the Clipped output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GenerateClippedOutputOff">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GenerateClippedOutputOn">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GetGenerateClippedOutput">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.SetGenerateClippedOutput(System.Int32)">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GenerateClipScalarsOff">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GenerateClipScalarsOn">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GetGenerateClipScalars">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.SetGenerateClipScalars(System.Int32)">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated from the implicit function values, and not the  input scalar data. If you enable this flag but do not provide an implicit function an error will be reported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.InsideOutOff">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.InsideOutOn">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GetInsideOut">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.SetInsideOut(System.Int32)">
            <summary>
                <para>Set/Get the InsideOut flag. When off, a vertex is considered inside the implicit function if its value is greater than the Value ivar. When InsideOutside is turned on, a vertex is considered inside the implicit function if its implicit function value is less than or equal to the Value ivar.  InsideOut is off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.GetValue">
            <summary>
                <para>Set the clipping value of the implicit function (if clipping with implicit function) or scalar value (if clipping with scalars). The default value is 0.0. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkClipPolyData.SetValue(System.Double)">
            <summary>
                <para>Set the clipping value of the implicit function (if clipping with implicit function) or scalar value (if clipping with scalars). The default value is 0.0. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkConeSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkConeSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkConeSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkConeSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkConeSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkConeSource.CappingOff">
            <summary>
                <para>Turn on/off whether to cap the base of the cone with a polygon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.CappingOn">
            <summary>
                <para>Turn on/off whether to cap the base of the cone with a polygon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetCapping">
            <summary>
                <para>Turn on/off whether to cap the base of the cone with a polygon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetCapping(System.Int32)">
            <summary>
                <para>Turn on/off whether to cap the base of the cone with a polygon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetAngle">
            <summary>
                <para>Set the angle of the cone. As a side effect, the angle plus height sets  the base radius of the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetAngle(System.Double)">
            <summary>
                <para>Set the angle of the cone. As a side effect, the angle plus height sets  the base radius of the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetDirection">
            <summary>
                <para>Set the orientation vector of the cone. The vector does not have to be normalized. The cone will point in the Direction specified. The default is (1,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetDirection(System.Double[])">
            <summary>
                <para>Set the orientation vector of the cone. The vector does not have to be normalized. The cone will point in the Direction specified. The default is (1,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetDirection(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the orientation vector of the cone. The vector does not have to be normalized. The cone will point in the Direction specified. The default is (1,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetCenter">
            <summary>
                <para>Set the center of the cone. The default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetCenter(System.Double[])">
            <summary>
                <para>Set the center of the cone. The default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the center of the cone. The default is 0,0,0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetResolution">
            <summary>
                <para>Set the number of facets used to represent the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetResolutionMaxValue">
            <summary>
                <para>Set the number of facets used to represent the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetResolutionMinValue">
            <summary>
                <para>Set the number of facets used to represent the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetResolution(System.Int32)">
            <summary>
                <para>Set the number of facets used to represent the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetRadius">
            <summary>
                <para>Set the base radius of the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetRadiusMaxValue">
            <summary>
                <para>Set the base radius of the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetRadiusMinValue">
            <summary>
                <para>Set the base radius of the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetRadius(System.Double)">
            <summary>
                <para>Set the base radius of the cone.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetHeight">
            <summary>
                <para>Set the height of the cone. This is the height along the cone in its specified direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetHeightMaxValue">
            <summary>
                <para>Set the height of the cone. This is the height along the cone in its specified direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.GetHeightMinValue">
            <summary>
                <para>Set the height of the cone. This is the height along the cone in its specified direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConeSource.SetHeight(System.Double)">
            <summary>
                <para>Set the height of the cone. This is the height along the cone in its specified direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.GetVector">
            <summary>
                <para>Define one end of the line (small scalar values).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.SetVector(System.Double[])">
            <summary>
                <para>Define one end of the line (small scalar values).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSimpleElevationFilter.SetVector(System.Double,System.Double,System.Double)">
            <summary>
                <para>Define one end of the line (small scalar values).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.AutomaticPlaneGenerationOff">
            <summary>
                <para>Turn on/off automatic plane generation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.AutomaticPlaneGenerationOn">
            <summary>
                <para>Turn on/off automatic plane generation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.GetAutomaticPlaneGeneration">
            <summary>
                <para>Turn on/off automatic plane generation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetAutomaticPlaneGeneration(System.Int32)">
            <summary>
                <para>Turn on/off automatic plane generation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.GetTRange">
            <summary>
                <para>Specify t-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetTRange(System.Double[])">
            <summary>
                <para>Specify t-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetTRange(System.Double,System.Double)">
            <summary>
                <para>Specify t-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.GetSRange">
            <summary>
                <para>Specify s-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetSRange(System.Double[])">
            <summary>
                <para>Specify s-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetSRange(System.Double,System.Double)">
            <summary>
                <para>Specify s-coordinate range for texture s-t coordinate pair.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.GetNormal">
            <summary>
                <para>Specify plane normal. An alternative way to specify a map plane. Using this method, the object will scale the resulting texture coordinate between the SRange and TRange specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetNormal(System.Double[])">
            <summary>
                <para>Specify plane normal. An alternative way to specify a map plane. Using this method, the object will scale the resulting texture coordinate between the SRange and TRange specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify plane normal. An alternative way to specify a map plane. Using this method, the object will scale the resulting texture coordinate between the SRange and TRange specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.GetPoint2">
            <summary>
                <para>Specify a point defining the second axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetPoint2(System.Double[])">
            <summary>
                <para>Specify a point defining the second axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetPoint2(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point defining the second axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.GetPoint1">
            <summary>
                <para>Specify a point defining the first axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetPoint1(System.Double[])">
            <summary>
                <para>Specify a point defining the first axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetPoint1(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point defining the first axis of the plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.GetOrigin">
            <summary>
                <para>Specify a point defining the origin of the plane. Used in conjunction with the Point1 and Point2 ivars to specify a map plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetOrigin(System.Double[])">
            <summary>
                <para>Specify a point defining the origin of the plane. Used in conjunction with the Point1 and Point2 ivars to specify a map plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextureMapToPlane.SetOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point defining the origin of the plane. Used in conjunction with the Point1 and Point2 ivars to specify a map plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOutlineSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.GetCorners">
            <summary>
                <para>Specify the corners of the outline when in Oriented mode, the values are supplied as 8*3 double values The correct corner ordering is using {x,y,z} convention for the unit cube as follows: {0,0,0},{1,0,0},{0,1,0},{1,1,0},{0,0,1},{1,0,1},{0,1,1},{1,1,1}.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.SetCorners(System.Double[])">
            <summary>
                <para>Specify the corners of the outline when in Oriented mode, the values are supplied as 8*3 double values The correct corner ordering is using {x,y,z} convention for the unit cube as follows: {0,0,0},{1,0,0},{0,1,0},{1,1,0},{0,0,1},{1,0,1},{0,1,1},{1,1,1}.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.GetBounds">
            <summary>
                <para>Specify the bounds of the box to be used in Axis Aligned mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.SetBounds(System.Double[])">
            <summary>
                <para>Specify the bounds of the box to be used in Axis Aligned mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.SetBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the bounds of the box to be used in Axis Aligned mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.SetBoxTypeToOriented">
            <summary>
                <para>Specify the bounds of the box to be used in Axis Aligned mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.SetBoxTypeToAxisAligned">
            <summary>
                <para>Set box type to AxisAligned (default) or Oriented. Use the method SetBounds() with AxisAligned mode, and SetCorners()  with Oriented mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.GetBoxType">
            <summary>
                <para>Set box type to AxisAligned (default) or Oriented. Use the method SetBounds() with AxisAligned mode, and SetCorners()  with Oriented mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineSource.SetBoxType(System.Int32)">
            <summary>
                <para>Set box type to AxisAligned (default) or Oriented. Use the method SetBounds() with AxisAligned mode, and SetCorners()  with Oriented mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDiskSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDiskSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDiskSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDiskSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetCircumferentialResolution">
            <summary>
                <para>Set the number of points in circumferential direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetCircumferentialResolutionMaxValue">
            <summary>
                <para>Set the number of points in circumferential direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetCircumferentialResolutionMinValue">
            <summary>
                <para>Set the number of points in circumferential direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.SetCircumferentialResolution(System.Int32)">
            <summary>
                <para>Set the number of points in circumferential direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetRadialResolution">
            <summary>
                <para>Set the number of points in radius direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetRadialResolutionMaxValue">
            <summary>
                <para>Set the number of points in radius direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetRadialResolutionMinValue">
            <summary>
                <para>Set the number of points in radius direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.SetRadialResolution(System.Int32)">
            <summary>
                <para>Set the number of points in radius direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetOuterRadius">
            <summary>
                <para>Specify outer radius of disc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetOuterRadiusMaxValue">
            <summary>
                <para>Specify outer radius of disc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetOuterRadiusMinValue">
            <summary>
                <para>Specify outer radius of disc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.SetOuterRadius(System.Double)">
            <summary>
                <para>Specify outer radius of disc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetInnerRadius">
            <summary>
                <para>Specify inner radius of hole in disc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetInnerRadiusMaxValue">
            <summary>
                <para>Specify inner radius of hole in disc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.GetInnerRadiusMinValue">
            <summary>
                <para>Specify inner radius of hole in disc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiskSource.SetInnerRadius(System.Double)">
            <summary>
                <para>Specify inner radius of hole in disc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractGeometry.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.ExtractOnlyBoundaryCellsOff">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.ExtractOnlyBoundaryCellsOn">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.GetExtractOnlyBoundaryCells">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.SetExtractOnlyBoundaryCells(System.Int32)">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.ExtractBoundaryCellsOff">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.ExtractBoundaryCellsOn">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.GetExtractBoundaryCells">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.SetExtractBoundaryCells(System.Int32)">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.ExtractInsideOff">
            <summary>
                <para>Boolean controls whether to extract cells that are inside of implicit  function (ExtractInside == 1) or outside of implicit function  (ExtractInside == 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.ExtractInsideOn">
            <summary>
                <para>Boolean controls whether to extract cells that are inside of implicit  function (ExtractInside == 1) or outside of implicit function  (ExtractInside == 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.GetExtractInside">
            <summary>
                <para>Boolean controls whether to extract cells that are inside of implicit  function (ExtractInside == 1) or outside of implicit function  (ExtractInside == 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.SetExtractInside(System.Int32)">
            <summary>
                <para>Boolean controls whether to extract cells that are inside of implicit  function (ExtractInside == 1) or outside of implicit function  (ExtractInside == 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.GetImplicitFunction">
            <summary>
                <para>Specify the implicit function for inside/outside checks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.SetImplicitFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Specify the implicit function for inside/outside checks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGeometry.GetMTime">
            <summary>
                <para>Return the MTime taking into account changes to the implicit function</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAppendPolyData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.ParallelStreamingOff">
            <summary>
                <para>ParallelStreaming is for a particular application. It causes this filter to ask for a different piece from each of its inputs.  If all the inputs are the same, then the output of this append filter is the whole dataset pieced back together.  Duplicate points are create  along the seams.  The purpose of this feature is to get  data parallelism at a course scale.  Each of the inputs can be generated in a different process at the same time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.ParallelStreamingOn">
            <summary>
                <para>ParallelStreaming is for a particular application. It causes this filter to ask for a different piece from each of its inputs.  If all the inputs are the same, then the output of this append filter is the whole dataset pieced back together.  Duplicate points are create  along the seams.  The purpose of this feature is to get  data parallelism at a course scale.  Each of the inputs can be generated in a different process at the same time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.GetParallelStreaming">
            <summary>
                <para>ParallelStreaming is for a particular application. It causes this filter to ask for a different piece from each of its inputs.  If all the inputs are the same, then the output of this append filter is the whole dataset pieced back together.  Duplicate points are create  along the seams.  The purpose of this feature is to get  data parallelism at a course scale.  Each of the inputs can be generated in a different process at the same time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.SetParallelStreaming(System.Int32)">
            <summary>
                <para>ParallelStreaming is for a particular application. It causes this filter to ask for a different piece from each of its inputs.  If all the inputs are the same, then the output of this append filter is the whole dataset pieced back together.  Duplicate points are create  along the seams.  The purpose of this feature is to get  data parallelism at a course scale.  Each of the inputs can be generated in a different process at the same time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.SetNumberOfInputs(System.Int32)">
            <summary>
                <para>Directly set(allocate) number of inputs, should only be used when UserManagedInputs is true.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.RemoveInput(vtk.vtkPolyData)">
            <summary>
                <para>Remove a dataset from the list of data to append. Should not be used when UserManagedInputs is true, use SetInputByNumber (NULL) instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.AddInput(vtk.vtkPolyData)">
            <summary>
                <para>Add a dataset to the list of data to append. Should not be used when UserManagedInputs is true, use SetInputByNumber instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.UserManagedInputsOff">
            <summary>
                <para>UserManagedInputs allows the user to set inputs by number instead of using the AddInput/RemoveInput functions. Calls to SetNumberOfInputs/SetInputByNumber should not be mixed with calls to AddInput/RemoveInput. By default, UserManagedInputs is false.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.UserManagedInputsOn">
            <summary>
                <para>UserManagedInputs allows the user to set inputs by number instead of using the AddInput/RemoveInput functions. Calls to SetNumberOfInputs/SetInputByNumber should not be mixed with calls to AddInput/RemoveInput. By default, UserManagedInputs is false.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.GetUserManagedInputs">
            <summary>
                <para>UserManagedInputs allows the user to set inputs by number instead of using the AddInput/RemoveInput functions. Calls to SetNumberOfInputs/SetInputByNumber should not be mixed with calls to AddInput/RemoveInput. By default, UserManagedInputs is false.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAppendPolyData.SetUserManagedInputs(System.Int32)">
            <summary>
                <para>UserManagedInputs allows the user to set inputs by number instead of using the AddInput/RemoveInput functions. Calls to SetNumberOfInputs/SetInputByNumber should not be mixed with calls to AddInput/RemoveInput. By default, UserManagedInputs is false.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWarpLens.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWarpLens.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWarpLens.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWarpLens.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetImageHeight">
            <summary>
                <para>Specify the image width / height in pixels</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetImageHeight(System.Int32)">
            <summary>
                <para>Specify the image width / height in pixels</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetImageWidth">
            <summary>
                <para>Specify the image width / height in pixels</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetImageWidth(System.Int32)">
            <summary>
                <para>Specify the image width / height in pixels</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetFormatHeight">
            <summary>
                <para>Specify the imager format width / height in mm</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetFormatHeight(System.Double)">
            <summary>
                <para>Specify the imager format width / height in mm</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetFormatWidth">
            <summary>
                <para>Specify the imager format width / height in mm</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetFormatWidth(System.Double)">
            <summary>
                <para>Specify the imager format width / height in mm</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetP2">
            <summary>
                <para>Specify the decentering distortion parameters for the lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetP2(System.Double)">
            <summary>
                <para>Specify the decentering distortion parameters for the lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetP1">
            <summary>
                <para>Specify the decentering distortion parameters for the lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetP1(System.Double)">
            <summary>
                <para>Specify the decentering distortion parameters for the lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetK2">
            <summary>
                <para>Specify the symmetric radial distortion parameters for the lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetK2(System.Double)">
            <summary>
                <para>Specify the symmetric radial distortion parameters for the lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetK1">
            <summary>
                <para>Specify the symmetric radial distortion parameters for the lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetK1(System.Double)">
            <summary>
                <para>Specify the symmetric radial distortion parameters for the lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetPrincipalPoint">
            <summary>
                <para>Specify the calibrated principal point of the camera/lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetPrincipalPoint(System.Double[])">
            <summary>
                <para>Specify the calibrated principal point of the camera/lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetPrincipalPoint(System.Double,System.Double)">
            <summary>
                <para>Specify the calibrated principal point of the camera/lens</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetCenter">
            <summary>
                <para>Specify the center of radial distortion in pixels. This is obsoleted by newer instance variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetCenter(System.Double,System.Double)">
            <summary>
                <para>Specify the center of radial distortion in pixels. This is obsoleted by newer instance variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.GetKappa">
            <summary>
                <para>Specify second order symmetric radial lens distortion parameter. This is obsoleted by newer instance variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpLens.SetKappa(System.Double)">
            <summary>
                <para>Specify second order symmetric radial lens distortion parameter. This is obsoleted by newer instance variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.GetCornerFactor">
            <summary>
                <para>Set/Get the factor that controls the relative size of the corners to the length of the corresponding bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.GetCornerFactorMaxValue">
            <summary>
                <para>Set/Get the factor that controls the relative size of the corners to the length of the corresponding bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.GetCornerFactorMinValue">
            <summary>
                <para>Set/Get the factor that controls the relative size of the corners to the length of the corresponding bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutlineCornerFilter.SetCornerFactor(System.Double)">
            <summary>
                <para>Set/Get the factor that controls the relative size of the corners to the length of the corresponding bounds</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractEdges.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.GetMTime">
            <summary>
                <para>Return MTime also considering the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.GetLocator">
            <summary>
                <para>Set / get a spatial locator for merging points. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractEdges.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / get a spatial locator for merging points. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GetMTime">
            <summary>
                <para>Return the mtime also considering the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The  locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GetLocator">
            <summary>
                <para>Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GetNumberOfOutputs">
            <summary>
                <para>Return the Clipped output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GetClippedOutput">
            <summary>
                <para>Return the Clipped output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GenerateClippedOutputOff">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GenerateClippedOutputOn">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GetGenerateClippedOutput">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.SetGenerateClippedOutput(System.Int32)">
            <summary>
                <para>Control whether a second output is generated. The second output contains the polygonal data that's been clipped away.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GenerateClipScalarsOff">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated, and not the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GenerateClipScalarsOn">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated, and not the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.GetGenerateClipScalars">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated, and not the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBoxClipDataSet.SetGenerateClipScalars(System.Int32)">
            <summary>
                <para>If this flag is enabled, then the output scalar values will be  interpolated, and not the input scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.SetPermutation(vtk.vtkSpherePuzzle)">
            <summary />
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.SetPermutationComponent(System.Int32,System.Int32)">
            <summary />
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.GetPermutation">
            <summary />
        </member>
        <member name="M:vtk.vtkSpherePuzzleArrows.SetPermutation(System.Int32[])">
            <summary />
        </member>
        <member name="M:vtk.vtkRotationFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRotationFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.CopyInputOff">
            <summary>
                <para>If on (the default), copy the input geometry to the output. If off, the output will only contain the rotation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.CopyInputOn">
            <summary>
                <para>If on (the default), copy the input geometry to the output. If off, the output will only contain the rotation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.GetCopyInput">
            <summary>
                <para>If on (the default), copy the input geometry to the output. If off, the output will only contain the rotation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetCopyInput(System.Int32)">
            <summary>
                <para>If on (the default), copy the input geometry to the output. If off, the output will only contain the rotation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.GetNumberOfCopies">
            <summary>
                <para>Set the number of copies to create. The source will be rotated N times and a new polydata copy of the original created at each angular position All copies will be appended to form a single output</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetNumberOfCopies(System.Int32)">
            <summary>
                <para>Set the number of copies to create. The source will be rotated N times and a new polydata copy of the original created at each angular position All copies will be appended to form a single output</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.GetCenter">
            <summary>
                <para>Set the rotation center coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetCenter(System.Double[])">
            <summary>
                <para>Set the rotation center coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the rotation center coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.GetAngle">
            <summary>
                <para>Set the rotation angle to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetAngle(System.Double)">
            <summary>
                <para>Set the rotation angle to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetAxisToZ">
            <summary>
                <para>Set the axis of rotation to use. It is set by default to Z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetAxisToY">
            <summary>
                <para>Set the axis of rotation to use. It is set by default to Z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetAxisToX">
            <summary>
                <para>Set the axis of rotation to use. It is set by default to Z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.GetAxis">
            <summary>
                <para>Set the axis of rotation to use. It is set by default to Z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.GetAxisMaxValue">
            <summary>
                <para>Set the axis of rotation to use. It is set by default to Z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.GetAxisMinValue">
            <summary>
                <para>Set the axis of rotation to use. It is set by default to Z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRotationFilter.SetAxis(System.Int32)">
            <summary>
                <para>Set the axis of rotation to use. It is set by default to Z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.MovePoint(System.Int32)">
            <summary>
                <para>Move actually implements the pending move. When percentage is 100, the pending move becomes inactive, and SetPoint will have to be called again to setup another move.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.SetPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>SetPoint will be called as the mouse moves over the screen. The output will change to indicate the pending move. SetPoint returns zero if move is not activated by point. Otherwise it encodes the move into a unique integer so that the caller can determine if the move state has changed. This will answer the question, "Should I render."</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.MoveVertical(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Rotate vertical half of sphere along one of the longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.MoveHorizontal(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Move the top/bottom half one segment either direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSpherePuzzle.Reset">
            <summary>
                <para>Reset the state of this puzzle back to its original state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.ColorRegionsOff">
            <summary>
                <para>Turn on/off the coloring of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.ColorRegionsOn">
            <summary>
                <para>Turn on/off the coloring of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetColorRegions">
            <summary>
                <para>Turn on/off the coloring of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetColorRegions(System.Int32)">
            <summary>
                <para>Turn on/off the coloring of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetNumberOfExtractedRegions">
            <summary>
                <para>Obtain the number of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetClosestPoint">
            <summary>
                <para>Use to specify x-y-z point coordinates when extracting the region  closest to a specified point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetClosestPoint(System.Double[])">
            <summary>
                <para>Use to specify x-y-z point coordinates when extracting the region  closest to a specified point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetClosestPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Use to specify x-y-z point coordinates when extracting the region  closest to a specified point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.DeleteSpecifiedRegion(System.Int32)">
            <summary>
                <para>Delete a region id to extract. Note: ids are 0-offset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.AddSpecifiedRegion(System.Int32)">
            <summary>
                <para>Add a region id to extract. Note: ids are 0-offset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.InitializeSpecifiedRegionList">
            <summary>
                <para>Initialize list of region ids to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.DeleteSeed(System.Int32)">
            <summary>
                <para>Delete a seed id (point or cell id). Note: ids are 0-offset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.AddSeed(System.Int32)">
            <summary>
                <para>Add a seed id (point or cell id). Note: ids are 0-offset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.InitializeSeedList">
            <summary>
                <para>Initialize list of point ids/cell ids used to seed regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetExtractionModeAsString">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetExtractionModeToAllRegions">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetExtractionModeToClosestPointRegion">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetExtractionModeToSpecifiedRegions">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetExtractionModeToLargestRegion">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetExtractionModeToCellSeededRegions">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetExtractionModeToPointSeededRegions">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetExtractionMode">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetExtractionModeMaxValue">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetExtractionModeMinValue">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetExtractionMode(System.Int32)">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetScalarRange">
            <summary>
                <para>Set the scalar range to use to extract cells based on scalar connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetScalarRange(System.Double[])">
            <summary>
                <para>Set the scalar range to use to extract cells based on scalar connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetScalarRange(System.Double,System.Double)">
            <summary>
                <para>Set the scalar range to use to extract cells based on scalar connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.ScalarConnectivityOff">
            <summary>
                <para>Turn on/off connectivity based on scalar value. If on, cells are connected only if they share points AND one of the cells scalar values falls in the scalar range specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.ScalarConnectivityOn">
            <summary>
                <para>Turn on/off connectivity based on scalar value. If on, cells are connected only if they share points AND one of the cells scalar values falls in the scalar range specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.GetScalarConnectivity">
            <summary>
                <para>Turn on/off connectivity based on scalar value. If on, cells are connected only if they share points AND one of the cells scalar values falls in the scalar range specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataConnectivityFilter.SetScalarConnectivity(System.Int32)">
            <summary>
                <para>Turn on/off connectivity based on scalar value. If on, cells are connected only if they share points AND one of the cells scalar values falls in the scalar range specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.IncludeBoundaryOff">
            <summary>
                <para>Control whether to enforce that the "boundary" of the grid is output in the subsampling process. (This ivar only has effect when the SampleRate in any direction is not equal to 1.) When this ivar IncludeBoundary is on, the subsampling will always include the boundary of the grid even though the sample rate is not an even multiple of the grid dimensions. (By default IncludeBoundary is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.IncludeBoundaryOn">
            <summary>
                <para>Control whether to enforce that the "boundary" of the grid is output in the subsampling process. (This ivar only has effect when the SampleRate in any direction is not equal to 1.) When this ivar IncludeBoundary is on, the subsampling will always include the boundary of the grid even though the sample rate is not an even multiple of the grid dimensions. (By default IncludeBoundary is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.GetIncludeBoundary">
            <summary>
                <para>Control whether to enforce that the "boundary" of the grid is output in the subsampling process. (This ivar only has effect when the SampleRate in any direction is not equal to 1.) When this ivar IncludeBoundary is on, the subsampling will always include the boundary of the grid even though the sample rate is not an even multiple of the grid dimensions. (By default IncludeBoundary is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.SetIncludeBoundary(System.Int32)">
            <summary>
                <para>Control whether to enforce that the "boundary" of the grid is output in the subsampling process. (This ivar only has effect when the SampleRate in any direction is not equal to 1.) When this ivar IncludeBoundary is on, the subsampling will always include the boundary of the grid even though the sample rate is not an even multiple of the grid dimensions. (By default IncludeBoundary is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.GetSampleRate">
            <summary>
                <para>Set the sampling rate in the i, j, and k directions. If the rate is &gt; 1, then the resulting VOI will be subsampled representation of the input. For example, if the SampleRate=(2,2,2), every other point will be selected, resulting in a volume 1/8th the original size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.SetSampleRate(System.Int32[])">
            <summary>
                <para>Set the sampling rate in the i, j, and k directions. If the rate is &gt; 1, then the resulting VOI will be subsampled representation of the input. For example, if the SampleRate=(2,2,2), every other point will be selected, resulting in a volume 1/8th the original size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.SetSampleRate(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the sampling rate in the i, j, and k directions. If the rate is &gt; 1, then the resulting VOI will be subsampled representation of the input. For example, if the SampleRate=(2,2,2), every other point will be selected, resulting in a volume 1/8th the original size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.GetVOI">
            <summary>
                <para>Specify i-j-k (min,max) pairs to extract. The resulting structured grid dataset can be of any topological dimension (i.e., point, line, plane, or 3D grid). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.SetVOI(System.Int32[])">
            <summary>
                <para>Specify i-j-k (min,max) pairs to extract. The resulting structured grid dataset can be of any topological dimension (i.e., point, line, plane, or 3D grid). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractGrid.SetVOI(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Specify i-j-k (min,max) pairs to extract. The resulting structured grid dataset can be of any topological dimension (i.e., point, line, plane, or 3D grid). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetRadialRatio">
            <summary>
                <para>Set/Get the radial ratio. This is the measure of the radius of the outer ellipsoid to the inner ellipsoid of the button. The outer ellipsoid is the boundary of the button defined by the height and width. The inner ellipsoid circumscribes the texture region. Larger RadialRatio's cause the button to be more rounded (and the texture region to be smaller); smaller ratios produce sharply curved shoulders with a larger texture region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetRadialRatioMaxValue">
            <summary>
                <para>Set/Get the radial ratio. This is the measure of the radius of the outer ellipsoid to the inner ellipsoid of the button. The outer ellipsoid is the boundary of the button defined by the height and width. The inner ellipsoid circumscribes the texture region. Larger RadialRatio's cause the button to be more rounded (and the texture region to be smaller); smaller ratios produce sharply curved shoulders with a larger texture region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetRadialRatioMinValue">
            <summary>
                <para>Set/Get the radial ratio. This is the measure of the radius of the outer ellipsoid to the inner ellipsoid of the button. The outer ellipsoid is the boundary of the button defined by the height and width. The inner ellipsoid circumscribes the texture region. Larger RadialRatio's cause the button to be more rounded (and the texture region to be smaller); smaller ratios produce sharply curved shoulders with a larger texture region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.SetRadialRatio(System.Double)">
            <summary>
                <para>Set/Get the radial ratio. This is the measure of the radius of the outer ellipsoid to the inner ellipsoid of the button. The outer ellipsoid is the boundary of the button defined by the height and width. The inner ellipsoid circumscribes the texture region. Larger RadialRatio's cause the button to be more rounded (and the texture region to be smaller); smaller ratios produce sharply curved shoulders with a larger texture region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetShoulderResolution">
            <summary>
                <para>Specify the resolution of the texture in the radial direction in the shoulder region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetShoulderResolutionMaxValue">
            <summary>
                <para>Specify the resolution of the texture in the radial direction in the shoulder region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetShoulderResolutionMinValue">
            <summary>
                <para>Specify the resolution of the texture in the radial direction in the shoulder region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.SetShoulderResolution(System.Int32)">
            <summary>
                <para>Specify the resolution of the texture in the radial direction in the shoulder region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetTextureResolution">
            <summary>
                <para>Specify the resolution of the texture in the radial direction in the texture region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetTextureResolutionMaxValue">
            <summary>
                <para>Specify the resolution of the texture in the radial direction in the texture region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetTextureResolutionMinValue">
            <summary>
                <para>Specify the resolution of the texture in the radial direction in the texture region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.SetTextureResolution(System.Int32)">
            <summary>
                <para>Specify the resolution of the texture in the radial direction in the texture region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetCircumferentialResolution">
            <summary>
                <para>Specify the resolution of the button in the circumferential direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetCircumferentialResolutionMaxValue">
            <summary>
                <para>Specify the resolution of the button in the circumferential direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetCircumferentialResolutionMinValue">
            <summary>
                <para>Specify the resolution of the button in the circumferential direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.SetCircumferentialResolution(System.Int32)">
            <summary>
                <para>Specify the resolution of the button in the circumferential direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetDepth">
            <summary>
                <para>Set/Get the depth of the button (the z-eliipsoid axis length).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetDepthMaxValue">
            <summary>
                <para>Set/Get the depth of the button (the z-eliipsoid axis length).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetDepthMinValue">
            <summary>
                <para>Set/Get the depth of the button (the z-eliipsoid axis length).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.SetDepth(System.Double)">
            <summary>
                <para>Set/Get the depth of the button (the z-eliipsoid axis length).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetHeight">
            <summary>
                <para>Set/Get the height of the button (the y-ellipsoid axis length * 2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetHeightMaxValue">
            <summary>
                <para>Set/Get the height of the button (the y-ellipsoid axis length * 2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetHeightMinValue">
            <summary>
                <para>Set/Get the height of the button (the y-ellipsoid axis length * 2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.SetHeight(System.Double)">
            <summary>
                <para>Set/Get the height of the button (the y-ellipsoid axis length * 2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetWidth">
            <summary>
                <para>Set/Get the width of the button (the x-ellipsoid axis length * 2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetWidthMaxValue">
            <summary>
                <para>Set/Get the width of the button (the x-ellipsoid axis length * 2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.GetWidthMinValue">
            <summary>
                <para>Set/Get the width of the button (the x-ellipsoid axis length * 2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEllipticalButtonSource.SetWidth(System.Double)">
            <summary>
                <para>Set/Get the width of the button (the x-ellipsoid axis length * 2).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpVector.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWarpVector.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWarpVector.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWarpVector.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWarpVector.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWarpVector.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWarpVector.GetScaleFactor">
            <summary>
                <para>Specify value to scale displacement.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpVector.SetScaleFactor(System.Double)">
            <summary>
                <para>Specify value to scale displacement.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.FlipTextureOff">
            <summary>
                <para>If enabled, this will flip the sense of inside and outside the implicit function (i.e., a rotation around the r-s-t=0.5 axis).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.FlipTextureOn">
            <summary>
                <para>If enabled, this will flip the sense of inside and outside the implicit function (i.e., a rotation around the r-s-t=0.5 axis).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.GetFlipTexture">
            <summary>
                <para>If enabled, this will flip the sense of inside and outside the implicit function (i.e., a rotation around the r-s-t=0.5 axis).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.SetFlipTexture(System.Int32)">
            <summary>
                <para>If enabled, this will flip the sense of inside and outside the implicit function (i.e., a rotation around the r-s-t=0.5 axis).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.GetTFunction">
            <summary>
                <para>Specify an implicit function to compute the t texture coordinate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.SetTFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Specify an implicit function to compute the t texture coordinate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.GetSFunction">
            <summary>
                <para>Specify an implicit function to compute the s texture coordinate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.SetSFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Specify an implicit function to compute the s texture coordinate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.GetRFunction">
            <summary>
                <para>Specify an implicit function to compute the r texture coordinate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitTextureCoords.SetRFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Specify an implicit function to compute the r texture coordinate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgePoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkEdgePoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkEdgePoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkEdgePoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkEdgePoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkEdgePoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkEdgePoints.GetValue">
            <summary>
                <para>Set/get the contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgePoints.SetValue(System.Double)">
            <summary>
                <para>Set/get the contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkContourFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkContourFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkContourFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkContourFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetArrayComponent">
            <summary>
                <para>Set/get which component of the scalar array to contour on; defaults to 0. Currently this feature only works if the input is a vtkImageData.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetArrayComponent(System.Int32)">
            <summary>
                <para>Set/get which component of the scalar array to contour on; defaults to 0. Currently this feature only works if the input is a vtkImageData.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetLocator">
            <summary>
                <para>Set / get a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / get a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetScalarTree">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetScalarTree(vtk.vtkScalarTree)">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.UseScalarTreeOff">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.UseScalarTreeOn">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetUseScalarTree">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetUseScalarTree(System.Int32)">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.ComputeScalarsOff">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.ComputeScalarsOn">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetComputeScalars">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetComputeScalars(System.Int32)">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.ComputeGradientsOff">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.ComputeGradientsOn">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetComputeGradients">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetComputeGradients(System.Int32)">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetMTime">
            <summary>
                <para>Modified GetMTime Because we delegate to vtkContourValues</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetNumberOfContours">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetValues(System.Double[])">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.GetValue(System.Int32)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourFilter.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProbeFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.GetValidPoints">
            <summary>
                <para>Get the list of point ids in the output that contain attribute data interpolated from the source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.SpatialMatchOff">
            <summary>
                <para>This flag is used only when a piece is requested to update.  By default the flag is off.  Because no spatial correspondence between input pieces and source pieces is known, all of the source has to be requested no matter what piece of the output is requested.  When there is a spatial  correspondence, the user/application can set this flag.  This hint allows the breakup of the probe operation to be much more efficient.  When piece m of n is requested for update by the user, then only n of m needs to be requested of the source. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.SpatialMatchOn">
            <summary>
                <para>This flag is used only when a piece is requested to update.  By default the flag is off.  Because no spatial correspondence between input pieces and source pieces is known, all of the source has to be requested no matter what piece of the output is requested.  When there is a spatial  correspondence, the user/application can set this flag.  This hint allows the breakup of the probe operation to be much more efficient.  When piece m of n is requested for update by the user, then only n of m needs to be requested of the source. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.GetSpatialMatch">
            <summary>
                <para>This flag is used only when a piece is requested to update.  By default the flag is off.  Because no spatial correspondence between input pieces and source pieces is known, all of the source has to be requested no matter what piece of the output is requested.  When there is a spatial  correspondence, the user/application can set this flag.  This hint allows the breakup of the probe operation to be much more efficient.  When piece m of n is requested for update by the user, then only n of m needs to be requested of the source. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.SetSpatialMatch(System.Int32)">
            <summary>
                <para>This flag is used only when a piece is requested to update.  By default the flag is off.  Because no spatial correspondence between input pieces and source pieces is known, all of the source has to be requested no matter what piece of the output is requested.  When there is a spatial  correspondence, the user/application can set this flag.  This hint allows the breakup of the probe operation to be much more efficient.  When piece m of n is requested for update by the user, then only n of m needs to be requested of the source. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.SetSourceConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Specify the point locations used to probe input. Any geometry can be used. New style. Equivalent to SetInputConnection(1, algOutput).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.GetSource">
            <summary>
                <para>Specify the point locations used to probe input. Any geometry can be used. Old style. Do not use unless for backwards compatibility.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProbeFilter.SetSource(vtk.vtkDataObject)">
            <summary>
                <para>Specify the point locations used to probe input. Any geometry can be used. Old style. Do not use unless for backwards compatibility.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkButtonSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkButtonSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkButtonSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkButtonSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkButtonSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkButtonSource.TwoSidedOff">
            <summary>
                <para>Indicate whether the button is single or double sided. A double sided button can be viewed from two sides...it looks sort of like a "pill." A single-sided button is meant to viewed from a single side; it looks  like a "clam-shell."</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.TwoSidedOn">
            <summary>
                <para>Indicate whether the button is single or double sided. A double sided button can be viewed from two sides...it looks sort of like a "pill." A single-sided button is meant to viewed from a single side; it looks  like a "clam-shell."</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.GetTwoSided">
            <summary>
                <para>Indicate whether the button is single or double sided. A double sided button can be viewed from two sides...it looks sort of like a "pill." A single-sided button is meant to viewed from a single side; it looks  like a "clam-shell."</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetTwoSided(System.Int32)">
            <summary>
                <para>Indicate whether the button is single or double sided. A double sided button can be viewed from two sides...it looks sort of like a "pill." A single-sided button is meant to viewed from a single side; it looks  like a "clam-shell."</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.GetShoulderTextureCoordinate">
            <summary>
                <para>Set/Get the default texture coordinate to set the shoulder region to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetShoulderTextureCoordinate(System.Double[])">
            <summary>
                <para>Set/Get the default texture coordinate to set the shoulder region to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetShoulderTextureCoordinate(System.Double,System.Double)">
            <summary>
                <para>Set/Get the default texture coordinate to set the shoulder region to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.GetTextureDimensions">
            <summary>
                <para>Set/get the texture dimension. This needs to be set if the texture style is set to fit the image.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetTextureDimensions(System.Int32[])">
            <summary>
                <para>Set/get the texture dimension. This needs to be set if the texture style is set to fit the image.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetTextureDimensions(System.Int32,System.Int32)">
            <summary>
                <para>Set/get the texture dimension. This needs to be set if the texture style is set to fit the image.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetTextureStyleToProportional">
            <summary>
                <para>Set/get the texture dimension. This needs to be set if the texture style is set to fit the image.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetTextureStyleToFitImage">
            <summary>
                <para>Set/Get the style of the texture region: whether to size it according to the x-y dimensions of the texture, or whether to make the texture region proportional to the width/height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.GetTextureStyle">
            <summary>
                <para>Set/Get the style of the texture region: whether to size it according to the x-y dimensions of the texture, or whether to make the texture region proportional to the width/height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.GetTextureStyleMaxValue">
            <summary>
                <para>Set/Get the style of the texture region: whether to size it according to the x-y dimensions of the texture, or whether to make the texture region proportional to the width/height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.GetTextureStyleMinValue">
            <summary>
                <para>Set/Get the style of the texture region: whether to size it according to the x-y dimensions of the texture, or whether to make the texture region proportional to the width/height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetTextureStyle(System.Int32)">
            <summary>
                <para>Set/Get the style of the texture region: whether to size it according to the x-y dimensions of the texture, or whether to make the texture region proportional to the width/height of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.GetCenter">
            <summary>
                <para>Specify a point defining the origin (center) of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetCenter(System.Double[])">
            <summary>
                <para>Specify a point defining the origin (center) of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkButtonSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a point defining the origin (center) of the button.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBrownianPoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.GetMaximumSpeed">
            <summary>
                <para>Set the maximum speed value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.GetMaximumSpeedMaxValue">
            <summary>
                <para>Set the maximum speed value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.GetMaximumSpeedMinValue">
            <summary>
                <para>Set the maximum speed value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.SetMaximumSpeed(System.Double)">
            <summary>
                <para>Set the maximum speed value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.GetMinimumSpeed">
            <summary>
                <para>Set the minimum speed value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.GetMinimumSpeedMaxValue">
            <summary>
                <para>Set the minimum speed value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.GetMinimumSpeedMinValue">
            <summary>
                <para>Set the minimum speed value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBrownianPoints.SetMinimumSpeed(System.Double)">
            <summary>
                <para>Set the minimum speed value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetMTime">
            <summary>
                <para>Overload GetMTime because we delegate to vtkContourValues so its modified time must be taken into account.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetContourEdgesOutput">
            <summary>
                <para>Get the second output which contains the edges dividing the contour  bands. This output is empty unless GenerateContourEdges is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GenerateContourEdgesOff">
            <summary>
                <para>Turn on/off a flag to control whether contour edges are generated. Contour edges are the edges between bands. If enabled, they are  generated from polygons/triangle strips and placed into the second output (the ContourEdgesOutput).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GenerateContourEdgesOn">
            <summary>
                <para>Turn on/off a flag to control whether contour edges are generated. Contour edges are the edges between bands. If enabled, they are  generated from polygons/triangle strips and placed into the second output (the ContourEdgesOutput).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetGenerateContourEdges">
            <summary>
                <para>Turn on/off a flag to control whether contour edges are generated. Contour edges are the edges between bands. If enabled, they are  generated from polygons/triangle strips and placed into the second output (the ContourEdgesOutput).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.SetGenerateContourEdges(System.Int32)">
            <summary>
                <para>Turn on/off a flag to control whether contour edges are generated. Contour edges are the edges between bands. If enabled, they are  generated from polygons/triangle strips and placed into the second output (the ContourEdgesOutput).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.SetScalarModeToValue">
            <summary>
                <para>Turn on/off a flag to control whether contour edges are generated. Contour edges are the edges between bands. If enabled, they are  generated from polygons/triangle strips and placed into the second output (the ContourEdgesOutput).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.SetScalarModeToIndex">
            <summary>
                <para>Control whether the cell scalars are output as an integer index or a scalar value. If an index, the index refers to the bands produced by the clipping range. If a value, then a scalar value which is a  value between clip values is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetScalarMode">
            <summary>
                <para>Control whether the cell scalars are output as an integer index or a scalar value. If an index, the index refers to the bands produced by the clipping range. If a value, then a scalar value which is a  value between clip values is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetScalarModeMaxValue">
            <summary>
                <para>Control whether the cell scalars are output as an integer index or a scalar value. If an index, the index refers to the bands produced by the clipping range. If a value, then a scalar value which is a  value between clip values is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetScalarModeMinValue">
            <summary>
                <para>Control whether the cell scalars are output as an integer index or a scalar value. If an index, the index refers to the bands produced by the clipping range. If a value, then a scalar value which is a  value between clip values is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.SetScalarMode(System.Int32)">
            <summary>
                <para>Control whether the cell scalars are output as an integer index or a scalar value. If an index, the index refers to the bands produced by the clipping range. If a value, then a scalar value which is a  value between clip values is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.ClippingOff">
            <summary>
                <para>Indicate whether to clip outside the range specified by the user. (The range is contour value[0] to contour value[numContours-1].) Clipping means all cells outside of the range specified are not sent to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.ClippingOn">
            <summary>
                <para>Indicate whether to clip outside the range specified by the user. (The range is contour value[0] to contour value[numContours-1].) Clipping means all cells outside of the range specified are not sent to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetClipping">
            <summary>
                <para>Indicate whether to clip outside the range specified by the user. (The range is contour value[0] to contour value[numContours-1].) Clipping means all cells outside of the range specified are not sent to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.SetClipping(System.Int32)">
            <summary>
                <para>Indicate whether to clip outside the range specified by the user. (The range is contour value[0] to contour value[numContours-1].) Clipping means all cells outside of the range specified are not sent to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Methods to set / get contour values. A single value at a time can be set with SetValue(). Multiple contour values can be set with GenerateValues(). Note that GenerateValues() generates n values inclusive of the start and end range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Methods to set / get contour values. A single value at a time can be set with SetValue(). Multiple contour values can be set with GenerateValues(). Note that GenerateValues() generates n values inclusive of the start and end range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetNumberOfContours">
            <summary>
                <para>Methods to set / get contour values. A single value at a time can be set with SetValue(). Multiple contour values can be set with GenerateValues(). Note that GenerateValues() generates n values inclusive of the start and end range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Methods to set / get contour values. A single value at a time can be set with SetValue(). Multiple contour values can be set with GenerateValues(). Note that GenerateValues() generates n values inclusive of the start and end range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetValues(System.Double[])">
            <summary>
                <para>Methods to set / get contour values. A single value at a time can be set with SetValue(). Multiple contour values can be set with GenerateValues(). Note that GenerateValues() generates n values inclusive of the start and end range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.GetValue(System.Int32)">
            <summary>
                <para>Methods to set / get contour values. A single value at a time can be set with SetValue(). Multiple contour values can be set with GenerateValues(). Note that GenerateValues() generates n values inclusive of the start and end range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBandedPolyDataContourFilter.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Methods to set / get contour values. A single value at a time can be set with SetValue(). Multiple contour values can be set with GenerateValues(). Note that GenerateValues() generates n values inclusive of the start and end range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFields.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMergeFields.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMergeFields.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMergeFields.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMergeFields.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMergeFields.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMergeFields.SetNumberOfComponents(System.Int32)">
            <summary>
                <para>Set the number of the components in the output field. This has to be set before execution. Default value is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFields.Merge(System.Int32,System.String,System.Int32)">
            <summary>
                <para>Add a component (arrayName,sourceComp) to the output field.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFields.SetOutputField(System.String,System.String)">
            <summary>
                <para>Helper method used by the other language bindings. Allows the caller to specify arguments as strings instead of enums.Returns an operation id  which can later be used to remove the operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMergeFields.SetOutputField(System.String,System.Int32)">
            <summary>
                <para>The output field will have the given name and it will be in fieldLoc (the input fields also have to be in fieldLoc).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLinkEdgels.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.GetGradientThreshold">
            <summary>
                <para>Set/Get the threshold for image gradient thresholding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.SetGradientThreshold(System.Double)">
            <summary>
                <para>Set/Get the threshold for image gradient thresholding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.GetPhiThreshold">
            <summary>
                <para>Set/get the threshold for Phi vs. Phi link thresholding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.SetPhiThreshold(System.Double)">
            <summary>
                <para>Set/get the threshold for Phi vs. Phi link thresholding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.GetLinkThreshold">
            <summary>
                <para>Set/Get the threshold for Phi vs. Alpha link thresholding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinkEdgels.SetLinkThreshold(System.Double)">
            <summary>
                <para>Set/Get the threshold for Phi vs. Alpha link thresholding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDiscreteMarchingCubes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDiscreteMarchingCubes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDiscreteMarchingCubes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDiscreteMarchingCubes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMarchingCubes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.GetLocator">
            <summary>
                <para>Overide the default locator.  Useful for changing the number of bins for performance or specifying a more aggressive locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Overide the default locator.  Useful for changing the number of bins for performance or specifying a more aggressive locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.ComputeScalarsOff">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.ComputeScalarsOn">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.GetComputeScalars">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.SetComputeScalars(System.Int32)">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.ComputeGradientsOff">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.ComputeGradientsOn">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.GetComputeGradients">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.SetComputeGradients(System.Int32)">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingCubes.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPointSource.GetDistribution">
            <summary>
                <para>Specify the distribution to use.  The default is a uniform distribution.  The shell distribution produces random points on the surface of the sphere, none in the interior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.SetDistributionToShell">
            <summary>
                <para>Specify the distribution to use.  The default is a uniform distribution.  The shell distribution produces random points on the surface of the sphere, none in the interior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.SetDistributionToUniform">
            <summary>
                <para>Specify the distribution to use.  The default is a uniform distribution.  The shell distribution produces random points on the surface of the sphere, none in the interior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.SetDistribution(System.Int32)">
            <summary>
                <para>Specify the distribution to use.  The default is a uniform distribution.  The shell distribution produces random points on the surface of the sphere, none in the interior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.GetRadius">
            <summary>
                <para>Set the radius of the point cloud.  If you are generating a Gaussian distribution, then this is the standard deviation for each of x, y, and z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.GetRadiusMaxValue">
            <summary>
                <para>Set the radius of the point cloud.  If you are generating a Gaussian distribution, then this is the standard deviation for each of x, y, and z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.GetRadiusMinValue">
            <summary>
                <para>Set the radius of the point cloud.  If you are generating a Gaussian distribution, then this is the standard deviation for each of x, y, and z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.SetRadius(System.Double)">
            <summary>
                <para>Set the radius of the point cloud.  If you are generating a Gaussian distribution, then this is the standard deviation for each of x, y, and z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.GetCenter">
            <summary>
                <para>Set the center of the point cloud.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.SetCenter(System.Double[])">
            <summary>
                <para>Set the center of the point cloud.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the center of the point cloud.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.GetNumberOfPoints">
            <summary>
                <para>Set the number of points to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.GetNumberOfPointsMaxValue">
            <summary>
                <para>Set the number of points to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.GetNumberOfPointsMinValue">
            <summary>
                <para>Set the number of points to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPointSource.SetNumberOfPoints(System.Int32)">
            <summary>
                <para>Set the number of points to generate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.ColorByPieceOff">
            <summary>
                <para>By default, this option is off.  When it is on, cell scalars are generated based on which piece they are in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.ColorByPieceOn">
            <summary>
                <para>By default, this option is off.  When it is on, cell scalars are generated based on which piece they are in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.GetColorByPiece">
            <summary>
                <para>By default, this option is off.  When it is on, cell scalars are generated based on which piece they are in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.SetColorByPiece(System.Int32)">
            <summary>
                <para>By default, this option is off.  When it is on, cell scalars are generated based on which piece they are in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.GetNumberOfStreamDivisions">
            <summary>
                <para>Set the number of pieces to divide the problem into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataStreamer.SetNumberOfStreamDivisions(System.Int32)">
            <summary>
                <para>Set the number of pieces to divide the problem into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.OutputTrianglesOff">
            <summary>
                <para>Set OutputTriangles to true if you wish to generate triangles instead of quads when extracting cells from 2D imagedata Currently this functionality is only implemented for 2D imagedata</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.OutputTrianglesOn">
            <summary>
                <para>Set OutputTriangles to true if you wish to generate triangles instead of quads when extracting cells from 2D imagedata Currently this functionality is only implemented for 2D imagedata</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.GetOutputTriangles">
            <summary>
                <para>Set OutputTriangles to true if you wish to generate triangles instead of quads when extracting cells from 2D imagedata Currently this functionality is only implemented for 2D imagedata</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.SetOutputTriangles(System.Int32)">
            <summary>
                <para>Set OutputTriangles to true if you wish to generate triangles instead of quads when extracting cells from 2D imagedata Currently this functionality is only implemented for 2D imagedata</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.ThresholdValueOff">
            <summary>
                <para>Set ThresholdValue to the scalar value by which to threshhold cells when extracting geometry when ThresholdCells is true. Cells with scalar values greater than the threshold will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.ThresholdValueOn">
            <summary>
                <para>Set ThresholdValue to the scalar value by which to threshhold cells when extracting geometry when ThresholdCells is true. Cells with scalar values greater than the threshold will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.GetThresholdValue">
            <summary>
                <para>Set ThresholdValue to the scalar value by which to threshhold cells when extracting geometry when ThresholdCells is true. Cells with scalar values greater than the threshold will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.SetThresholdValue(System.Double)">
            <summary>
                <para>Set ThresholdValue to the scalar value by which to threshhold cells when extracting geometry when ThresholdCells is true. Cells with scalar values greater than the threshold will be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.ThresholdCellsOff">
            <summary>
                <para>Set ThresholdCells to true if you wish to skip any voxel/pixels which have scalar values less than the specified threshold. Currently this functionality is only implemented for 2D imagedata</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.ThresholdCellsOn">
            <summary>
                <para>Set ThresholdCells to true if you wish to skip any voxel/pixels which have scalar values less than the specified threshold. Currently this functionality is only implemented for 2D imagedata</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.GetThresholdCells">
            <summary>
                <para>Set ThresholdCells to true if you wish to skip any voxel/pixels which have scalar values less than the specified threshold. Currently this functionality is only implemented for 2D imagedata</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.SetThresholdCells(System.Int32)">
            <summary>
                <para>Set ThresholdCells to true if you wish to skip any voxel/pixels which have scalar values less than the specified threshold. Currently this functionality is only implemented for 2D imagedata</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.SetExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set / get the extent (imin,imax, jmin,jmax, kmin,kmax) indices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageDataGeometryFilter.SetExtent(System.Int32[])">
            <summary>
                <para>Set / get the extent (imin,imax, jmin,jmax, kmin,kmax) indices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkBSPCuts.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBSPCuts.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBSPCuts.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBSPCuts.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBSPIntersections.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.IntersectsCell(System.Int32[],System.Int32,vtk.vtkCell,System.Int32)">
            <summary>
                <para>Compute a list of the Ids of all regions that    intersect the given cell.  If you alrady    know the region that the cell centroid lies in, provide    that as the last argument to make the computation quicker.    Returns the number of regions the cell intersects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.IntersectsCell(System.Int32,vtk.vtkCell,System.Int32)">
            <summary>
                <para>Determine whether a region of the spatial decomposition    intersects the given cell.  If you already    know the region that the cell centroid lies in, provide     that as the last argument to make the computation quicker.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.IntersectsSphere2(System.Int32[],System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Compute a list of the Ids of all regions that     intersect the specified sphere.  The sphere is given    by it's center and the square of it's radius.    Returns: the number of ids in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.IntersectsSphere2(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Determine whether a region of the spatial decomposition     intersects a sphere, given the center of the sphere     and the square of it's radius.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.IntersectsBox(System.Int32[],System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Compute a list of the Ids of all regions that     intersect the specified axis aligned box.    Returns: the number of ids in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.IntersectsBox(System.Int32[],System.Int32,System.Double[])">
            <summary>
                <para>Compute a list of the Ids of all regions that     intersect the specified axis aligned box.    Returns: the number of ids in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.IntersectsBox(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Determine whether a region of the spatial decomposition     intersects an axis aligned box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBSPIntersections.IntersectsBox(System.Int32,System.Double[])">
            <summary>
                <para>Determine whether a region of the spatial decomposition     intersects an axis aligned box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkModelMetadata.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.GetBlockLocalIndex(System.Int32)">
            <summary>
                <para>Block information is stored in arrays.  This method returns   the array index for a given block ID.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.Reset">
            <summary>
                <para>Set the object back to it's initial state</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeUsedNodeVariables">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeUsedElementVariables">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeUsedNodeVariableNames">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeUsedElementVariableNames">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeOriginalNodeVariableNames">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeOriginalElementVariableNames">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeBlockDependentData">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeAllLocalData">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FreeAllGlobalData">
            <summary>
                <para>Free selected portions of the metadata when updating values   in the vtkModelMetadata object.  Resetting a particular field,   (i.e. SetNodeSetIds) frees the previous setting, but if you   are not setting every field, you may want to do a wholesale   "Free" first.</para>
                <para>FreeAllGlobalData frees all the fields which don't depend on     which time step, which blocks, or which variables are in the input.   FreeAllLocalData frees all the fields which do depend on which     time step, blocks or variables are in the input.   FreeBlockDependentData frees all metadata fields which depend on     which blocks were read in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.ExtractGlobalMetadata">
            <summary>
                <para>Create and return a new metadata object containing only the   global metadata of this metadata object.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.ExtractModelMetadata(vtk.vtkIntArray,vtk.vtkDataSet,System.String,System.String)">
            <summary>
                <para>Create and return a new metadata object which contains   the information for the subset of global cell IDs provided.   We need the grid containing the cells so we can find point   Ids as well, and also the name of the global cell ID array   and the name of the global point ID array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.MergeGlobalInformation(vtk.vtkModelMetadata)">
            <summary>
                <para>The metadata is divided into global metadata and local   metadata.  MergeGlobalInformation merges just the   global metadata of the supplied object into the   global metadata of this object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.MergeModelMetadata(vtk.vtkModelMetadata)">
            <summary>
                <para>In VTK we take vtkUnstructuredGrids and perform   operations on them, including subsetting and merging   grids.  We need to modify the metadata object    when this happens.  MergeModelMetadata merges the supplied   model (both global and local metadata) into this model.     The models must be from the same file set.</para>
                <para>MergeModelMetadata assumes that no element in one metadata   object appears in the other.  (It doesn't test for duplicate   elements when merging the two metadata objects.) </para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.RemoveUGridElementVariable(System.String)">
            <summary>
                <para>In order to write Exodus files from vtkUnstructuredGrid   objects that were read from Exodus files, we need to know   the mapping from variable names in the UGrid to variable   names in the Exodus file.  (The Exodus reader combines   scalar variables with similar names into vectors in the   UGrid.)  When building the UGrid to which this   ModelMetadata refers, add each element and node variable   name with this call, including the name of original variable   that yielded it's first component, and the number of components.   If a variable is removed from the UGrid, remove it from   the ModelMetadata.  (If this information is missing or   incomplete, the ExodusIIWriter can still do something   sensible in creating names for variables.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.AddUGridElementVariable(System.String,System.String,System.Int32)">
            <summary>
                <para>In order to write Exodus files from vtkUnstructuredGrid   objects that were read from Exodus files, we need to know   the mapping from variable names in the UGrid to variable   names in the Exodus file.  (The Exodus reader combines   scalar variables with similar names into vectors in the   UGrid.)  When building the UGrid to which this   ModelMetadata refers, add each element and node variable   name with this call, including the name of original variable   that yielded it's first component, and the number of components.   If a variable is removed from the UGrid, remove it from   the ModelMetadata.  (If this information is missing or   incomplete, the ExodusIIWriter can still do something   sensible in creating names for variables.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.Unpack(vtk.vtkDataSet,System.Int32)">
            <summary>
                <para>Unpack the metadata stored in a dataset,   and initialize this object with it.  Return 1 if there's   no metadata packed into the grid, 0 if OK.   If deleteIt is ON, then delete the grid's packed data after   unpacking it into the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.Pack(vtk.vtkDataSet)">
            <summary>
                <para>Pack this object's metadata into a field array of a dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.RemoveMetadata(vtk.vtkDataSet)">
            <summary>
                <para>Static function that removes the packed metadata arrays   from a dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.HasMetadata(vtk.vtkDataSet)">
            <summary>
                <para>Static function that returns 1 if the vtkUnstructuredGrid   has metadata packed into it's field arrays, and 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FindOriginalNodeVariableName(System.String,System.Int32)">
            <summary>
                <para>Given the name of an node variable the vtkUnstructuredGrid   described by this ModelMetadata, and a component number, give    the name of the scalar array in the original   file that turned into that component when the file was   read into VTK.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.FindOriginalElementVariableName(System.String,System.Int32)">
            <summary>
                <para>Given the name of an element variable the vtkUnstructuredGrid   described by this ModelMetadata, and a component number, give    the name of the scalar array in the original   file that turned into that component when the file was   read into VTK.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.ElementVariableIsDefinedInBlock(System.String,System.Int32)">
            <summary>
                <para>If the element variable named is defined for the block Id   provided (in the element variable truth table) return a   1, otherwise return a 0.  If the variable name or block Id   are unrecognized, the default value of 1 is returned.   (This is an "original" variable name, from the file,   not a name created for the vtkUnstructuredGrid.  Use   FindOriginal*VariableName to map between the two.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.AllVariablesDefinedInAllBlocksOff">
            <summary>
                <para>Instead of a truth table of all "1"s, you can set this   instance variable to indicate that all variables are   defined in all blocks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.AllVariablesDefinedInAllBlocksOn">
            <summary>
                <para>Instead of a truth table of all "1"s, you can set this   instance variable to indicate that all variables are   defined in all blocks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetAllVariablesDefinedInAllBlocks(System.Int32)">
            <summary>
                <para>Instead of a truth table of all "1"s, you can set this   instance variable to indicate that all variables are   defined in all blocks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetElementVariableTruthTable(System.Int32[])">
            <summary>
                <para>A truth table indicating which element variables are   defined for which blocks. The variables are all the original   element variables that were in the file.   The table is by block ID and within block ID by variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetGlobalVariableValue(System.Single[])">
            <summary>
                <para>Set or get the values of the global variables at the current   time step.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetSideSetPropertyValue(System.Int32[])">
            <summary>
                <para>Set or get value for each variable for each side set.  List   the integer values in order by variable and within variable   by side set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNodeSetPropertyValue(System.Int32[])">
            <summary>
                <para>Set or get value for each variable for each node set.  List   the integer values in order by variable and within variable   by node set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetBlockPropertyValue(System.Int32[])">
            <summary>
                <para>Set or get value for each variable for each block.  List   the integer values in order by variable and within variable   by block.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetSideSetDistributionFactors(System.Single[])">
            <summary>
                <para>Set or get a pointer to a list of all the distribution factors.   For every side set that has distribution factors, the number of   factors per node was given in the SideSetNumberOfDistributionFactors   array.  If this number for a given side set is N, then for that   side set we have N floating point values for each node for each   side in the side set.  If nodes are repeated in more than one   side, we repeat the distribution factors.  So this list is in order   by side set, by node.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetSideSetNumDFPerSide(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list of the number of nodes in each   side of each side set.  This list is organized by side set, and   within side set by side.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetSideSetSideList(System.Int32[])">
            <summary>
                <para>Set or get a pointer to the element side for each side in the side set.   (See the manual for the convention for numbering sides in different   types of cells.)  Side Ids are arranged by side set and within   side set by side, and correspond to the SideSetElementList.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetSideSetElementList(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list of the elements containing each   side in each side set.  The list is organized by side set, and   within side set by element.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetSideSetNumberOfDistributionFactors(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list of the number of distribution   factors stored by each side set.   Each side set has either   no distribution factors, or 1 per node in the side set.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetSideSetSize(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list of the number of sides  in each side set.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetSideSetIds(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list giving the ID of each side set.    We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNumberOfSideSets(System.Int32)">
            <summary>
                <para>Set or get the number of side sets.  Set this value before   setting any of the other side set arrays.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNodeSetDistributionFactors(System.Single[])">
            <summary>
                <para>Set or get a list of the distribution factors for the node sets.   The list is organized by node set, and within node set by node.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNodeSetNumberOfDistributionFactors(System.Int32[])">
            <summary>
                <para>Set or get a list of the number of distribution factors stored   by each node set.  This is either 0 or equal to the number of   nodes in the node set.    Length of list is number of node sets.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNodeSetNodeIdList(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a concatenated list of the   IDs of all nodes in each node set.  First list all IDs in   node set 0, then all IDs in node set 1, and so on.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNodeSetSize(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list of the number of nodes in each node set.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNodeSetIds(System.Int32[])">
            <summary>
                <para>Set or get the list the IDs for each node set.   Length of list is the number of node sets.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNumberOfNodeSets(System.Int32)">
            <summary>
                <para>The number of node sets in the file.  Set this value before   setting the various node set arrays.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetBlockAttributes(System.Single[])">
            <summary>
                <para>Set or get a pointer to a list of the attributes for all    blocks.  The order of the list should be by block, by element    within the block, by attribute.  Omit blocks that don't    have element attributes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetBlockNumberOfAttributesPerElement(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list of the number of attributes   stored for the elements in each block.   We use your pointers, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetBlockElementIdList(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list global element IDs for the   elements in each block.    We use your pointers, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetBlockNodesPerElement(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list of the number of nodes in the   elements of  each block.   We use your pointers, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetBlockNumberOfElements(System.Int32[])">
            <summary>
                <para>Set or get a pointer to a list of the number of elements in   each block.   We use your pointers, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetBlockIds(System.Int32[])">
            <summary>
                <para>An arbitrary integer ID for each block.   We use your pointer, and free the memory when the object is freed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetNumberOfBlocks(System.Int32)">
            <summary>
                <para>The number of blocks in the file.  Set this before setting   any of the block arrays.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetTimeSteps(System.Int32,System.Single[])">
            <summary>
                <para>Set the total number of time steps in the file,    and the value at each time step.  We use your time    step value array and delete it when we're done.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetTimeStepIndex(System.Int32)">
            <summary>
                <para>Set the index of the time step represented by the results    data in the file attached to this ModelMetadata object.  Time    step indices start at 0 in this file, they start at 1 in    an Exodus file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.AddQARecord(System.String,System.String,System.String,System.String)">
            <summary>
                <para>Add a QA record.  They fields are:    The code name    The code version number    The date (MM/DD/YY or NULL for today)    The time (HH:MM:SS or NULL for right now)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.AddInformationLine(System.String)">
            <summary>
                <para>Add an information line. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkModelMetadata.SetTitle(System.String)">
            <summary>
                <para>The title of the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.SetOutputWholeExtent(System.Int32,System.Int32)">
            <summary>
                <para>Hack set output by piece</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.ClipDataOff">
            <summary>
                <para>By default, ClipData is off, and only the WholeExtent is modified. the data's extent may actually be larger.  When this flag is on, the data extent will be no more than the OutputWholeExtent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.ClipDataOn">
            <summary>
                <para>By default, ClipData is off, and only the WholeExtent is modified. the data's extent may actually be larger.  When this flag is on, the data extent will be no more than the OutputWholeExtent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.GetClipData">
            <summary>
                <para>By default, ClipData is off, and only the WholeExtent is modified. the data's extent may actually be larger.  When this flag is on, the data extent will be no more than the OutputWholeExtent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.SetClipData(System.Int32)">
            <summary>
                <para>By default, ClipData is off, and only the WholeExtent is modified. the data's extent may actually be larger.  When this flag is on, the data extent will be no more than the OutputWholeExtent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.GetOutputWholeExtent(System.Int32[])">
            <summary>
                <para>The whole extent of the output has to be set explicitly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.SetOutputWholeExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>The whole extent of the output has to be set explicitly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridClip.SetOutputWholeExtent(System.Int32[],vtk.vtkInformation)">
            <summary>
                <para>The whole extent of the output has to be set explicitly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLineSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLineSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLineSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLineSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLineSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLineSource.GetResolution">
            <summary>
                <para>Divide line into resolution number of pieces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.GetResolutionMaxValue">
            <summary>
                <para>Divide line into resolution number of pieces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.GetResolutionMinValue">
            <summary>
                <para>Divide line into resolution number of pieces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.SetResolution(System.Int32)">
            <summary>
                <para>Divide line into resolution number of pieces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.GetPoint2">
            <summary>
                <para>Set position of other end point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.SetPoint2(System.Double[])">
            <summary>
                <para>Set position of other end point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.SetPoint2(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set position of other end point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.GetPoint1">
            <summary>
                <para>Set position of first end point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.SetPoint1(System.Double[])">
            <summary>
                <para>Set position of first end point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLineSource.SetPoint1(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set position of first end point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetTCoordComponents">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector. Up to NumberOfTCoords components are extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetTCoordComponents(System.Int32[])">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector. Up to NumberOfTCoords components are extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetTCoordComponents(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector. Up to NumberOfTCoords components are extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetNumberOfTCoords">
            <summary>
                <para>Set the dimension of the texture coordinates to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetNumberOfTCoordsMaxValue">
            <summary>
                <para>Set the dimension of the texture coordinates to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetNumberOfTCoordsMinValue">
            <summary>
                <para>Set the dimension of the texture coordinates to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetNumberOfTCoords(System.Int32)">
            <summary>
                <para>Set the dimension of the texture coordinates to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ExtractTCoordsOff">
            <summary>
                <para>Boolean controls whether texture coordinates are extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ExtractTCoordsOn">
            <summary>
                <para>Boolean controls whether texture coordinates are extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetExtractTCoords">
            <summary>
                <para>Boolean controls whether texture coordinates are extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetExtractTCoords(System.Int32)">
            <summary>
                <para>Boolean controls whether texture coordinates are extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetNormalComponents">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetNormalComponents(System.Int32[])">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetNormalComponents(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.NormalizeNormalsOff">
            <summary>
                <para>Boolean controls whether normal vector is converted to unit normal after extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.NormalizeNormalsOn">
            <summary>
                <para>Boolean controls whether normal vector is converted to unit normal after extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetNormalizeNormals">
            <summary>
                <para>Boolean controls whether normal vector is converted to unit normal after extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetNormalizeNormals(System.Int32)">
            <summary>
                <para>Boolean controls whether normal vector is converted to unit normal after extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ExtractNormalsOff">
            <summary>
                <para>Boolean controls whether normal data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ExtractNormalsOn">
            <summary>
                <para>Boolean controls whether normal data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetExtractNormals">
            <summary>
                <para>Boolean controls whether normal data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetExtractNormals(System.Int32)">
            <summary>
                <para>Boolean controls whether normal data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetVectorComponents">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetVectorComponents(System.Int32[])">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetVectorComponents(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Specify the ((row,column)0,(row,column)1,(row,column)2) tensor components to extract as a vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ExtractVectorsOff">
            <summary>
                <para>Boolean controls whether vector data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ExtractVectorsOn">
            <summary>
                <para>Boolean controls whether vector data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetExtractVectors">
            <summary>
                <para>Boolean controls whether vector data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetExtractVectors(System.Int32)">
            <summary>
                <para>Boolean controls whether vector data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ScalarIsDeterminant">
            <summary>
                <para>Specify how to extract the scalar. You can extract it as one of the components of the tensor, as effective stress, or as the determinant of the tensor. If you extract a component make sure that you set the ScalarComponents ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ScalarIsEffectiveStress">
            <summary>
                <para>Specify how to extract the scalar. You can extract it as one of the components of the tensor, as effective stress, or as the determinant of the tensor. If you extract a component make sure that you set the ScalarComponents ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ScalarIsComponent">
            <summary>
                <para>Specify how to extract the scalar. You can extract it as one of the components of the tensor, as effective stress, or as the determinant of the tensor. If you extract a component make sure that you set the ScalarComponents ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetScalarModeToDeterminant">
            <summary>
                <para>Specify how to extract the scalar. You can extract it as one of the components of the tensor, as effective stress, or as the determinant of the tensor. If you extract a component make sure that you set the ScalarComponents ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetScalarModeToEffectiveStress">
            <summary>
                <para>Specify how to extract the scalar. You can extract it as one of the components of the tensor, as effective stress, or as the determinant of the tensor. If you extract a component make sure that you set the ScalarComponents ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetScalarModeToComponent">
            <summary>
                <para>Specify how to extract the scalar. You can extract it as one of the components of the tensor, as effective stress, or as the determinant of the tensor. If you extract a component make sure that you set the ScalarComponents ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetScalarMode">
            <summary>
                <para>Specify how to extract the scalar. You can extract it as one of the components of the tensor, as effective stress, or as the determinant of the tensor. If you extract a component make sure that you set the ScalarComponents ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetScalarMode(System.Int32)">
            <summary>
                <para>Specify how to extract the scalar. You can extract it as one of the components of the tensor, as effective stress, or as the determinant of the tensor. If you extract a component make sure that you set the ScalarComponents ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetScalarComponents">
            <summary>
                <para>Specify the (row,column) tensor component to extract as a scalar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetScalarComponents(System.Int32[])">
            <summary>
                <para>Specify the (row,column) tensor component to extract as a scalar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetScalarComponents(System.Int32,System.Int32)">
            <summary>
                <para>Specify the (row,column) tensor component to extract as a scalar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ExtractScalarsOff">
            <summary>
                <para>Boolean controls whether scalar data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.ExtractScalarsOn">
            <summary>
                <para>Boolean controls whether scalar data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetExtractScalars">
            <summary>
                <para>Boolean controls whether scalar data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetExtractScalars(System.Int32)">
            <summary>
                <para>Boolean controls whether scalar data is extracted from tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.PassTensorsToOutputOff">
            <summary>
                <para>Boolean controls whether tensor data is passed through to output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.PassTensorsToOutputOn">
            <summary>
                <para>Boolean controls whether tensor data is passed through to output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.GetPassTensorsToOutput">
            <summary>
                <para>Boolean controls whether tensor data is passed through to output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractTensorComponents.SetPassTensorsToOutput(System.Int32)">
            <summary>
                <para>Boolean controls whether tensor data is passed through to output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGlyph2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGlyph2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGlyph2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGlyph2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGlyph2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGlyph3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.IsPointVisible(vtk.vtkDataSet,System.Int32)">
            <summary>
                <para>This can be overwritten by subclass to return 0 when a point is blanked. Default implementation is to always return 1;</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetPointIdsName">
            <summary>
                <para>Set/Get the name of the PointIds array if generated. By default the Ids are named "InputPointIds", but this can be changed with this function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetPointIdsName(System.String)">
            <summary>
                <para>Set/Get the name of the PointIds array if generated. By default the Ids are named "InputPointIds", but this can be changed with this function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GeneratePointIdsOff">
            <summary>
                <para>Enable/disable the generation of point ids as part of the output. The point ids are the id of the input generating point. The point ids are stored in the output point field data and named "InputPointIds". Point generation is useful for debugging and pick operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GeneratePointIdsOn">
            <summary>
                <para>Enable/disable the generation of point ids as part of the output. The point ids are the id of the input generating point. The point ids are stored in the output point field data and named "InputPointIds". Point generation is useful for debugging and pick operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetGeneratePointIds">
            <summary>
                <para>Enable/disable the generation of point ids as part of the output. The point ids are the id of the input generating point. The point ids are stored in the output point field data and named "InputPointIds". Point generation is useful for debugging and pick operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetGeneratePointIds(System.Int32)">
            <summary>
                <para>Enable/disable the generation of point ids as part of the output. The point ids are the id of the input generating point. The point ids are stored in the output point field data and named "InputPointIds". Point generation is useful for debugging and pick operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetIndexModeAsString">
            <summary>
                <para>Index into table of sources by scalar, by vector/normal magnitude, or no indexing. If indexing is turned off, then the first source glyph in the table of glyphs is used. Note that indexing mode will only use the InputScalarsSelection array and not the InputColorScalarsSelection as the scalar source if an array is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetIndexModeToOff">
            <summary>
                <para>Index into table of sources by scalar, by vector/normal magnitude, or no indexing. If indexing is turned off, then the first source glyph in the table of glyphs is used. Note that indexing mode will only use the InputScalarsSelection array and not the InputColorScalarsSelection as the scalar source if an array is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetIndexModeToVector">
            <summary>
                <para>Index into table of sources by scalar, by vector/normal magnitude, or no indexing. If indexing is turned off, then the first source glyph in the table of glyphs is used. Note that indexing mode will only use the InputScalarsSelection array and not the InputColorScalarsSelection as the scalar source if an array is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetIndexModeToScalar">
            <summary>
                <para>Index into table of sources by scalar, by vector/normal magnitude, or no indexing. If indexing is turned off, then the first source glyph in the table of glyphs is used. Note that indexing mode will only use the InputScalarsSelection array and not the InputColorScalarsSelection as the scalar source if an array is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetIndexMode">
            <summary>
                <para>Index into table of sources by scalar, by vector/normal magnitude, or no indexing. If indexing is turned off, then the first source glyph in the table of glyphs is used. Note that indexing mode will only use the InputScalarsSelection array and not the InputColorScalarsSelection as the scalar source if an array is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetIndexMode(System.Int32)">
            <summary>
                <para>Index into table of sources by scalar, by vector/normal magnitude, or no indexing. If indexing is turned off, then the first source glyph in the table of glyphs is used. Note that indexing mode will only use the InputScalarsSelection array and not the InputColorScalarsSelection as the scalar source if an array is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetVectorModeAsString">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetVectorModeToVectorRotationOff">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetVectorModeToUseNormal">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetVectorModeToUseVector">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetVectorMode">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetVectorMode(System.Int32)">
            <summary>
                <para>Specify whether to use vector or normal to perform vector operations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetClamping">
            <summary>
                <para>Turn on/off clamping of "scalar" values to range. (Scalar value may be  vector magnitude if ScaleByVector() is enabled.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.ClampingOff">
            <summary>
                <para>Turn on/off clamping of "scalar" values to range. (Scalar value may be  vector magnitude if ScaleByVector() is enabled.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.ClampingOn">
            <summary>
                <para>Turn on/off clamping of "scalar" values to range. (Scalar value may be  vector magnitude if ScaleByVector() is enabled.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetClamping(System.Int32)">
            <summary>
                <para>Turn on/off clamping of "scalar" values to range. (Scalar value may be  vector magnitude if ScaleByVector() is enabled.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetOrient">
            <summary>
                <para>Turn on/off orienting of input geometry along vector/normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.OrientOff">
            <summary>
                <para>Turn on/off orienting of input geometry along vector/normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.OrientOn">
            <summary>
                <para>Turn on/off orienting of input geometry along vector/normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetOrient(System.Int32)">
            <summary>
                <para>Turn on/off orienting of input geometry along vector/normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetRange">
            <summary>
                <para>Specify range to map scalar values into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetRange(System.Double[])">
            <summary>
                <para>Specify range to map scalar values into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetRange(System.Double,System.Double)">
            <summary>
                <para>Specify range to map scalar values into.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetScaleFactor">
            <summary>
                <para>Specify scale factor to scale object by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetScaleFactor(System.Double)">
            <summary>
                <para>Specify scale factor to scale object by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetColorModeAsString">
            <summary>
                <para>Either color by scale, scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetColorModeToColorByVector">
            <summary>
                <para>Either color by scale, scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetColorModeToColorByScalar">
            <summary>
                <para>Either color by scale, scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetColorModeToColorByScale">
            <summary>
                <para>Either color by scale, scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetColorMode">
            <summary>
                <para>Either color by scale, scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetColorMode(System.Int32)">
            <summary>
                <para>Either color by scale, scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetScaleModeAsString">
            <summary>
                <para>Either scale by scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetScaleModeToDataScalingOff">
            <summary>
                <para>Either scale by scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetScaleModeToScaleByVectorComponents">
            <summary>
                <para>Either scale by scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetScaleModeToScaleByVector">
            <summary>
                <para>Either scale by scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetScaleModeToScaleByScalar">
            <summary>
                <para>Either scale by scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetScaleMode">
            <summary>
                <para>Either scale by scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetScaleMode(System.Int32)">
            <summary>
                <para>Either scale by scalar or by vector/normal magnitude.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetScaling">
            <summary>
                <para>Turn on/off scaling of source geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.ScalingOff">
            <summary>
                <para>Turn on/off scaling of source geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.ScalingOn">
            <summary>
                <para>Turn on/off scaling of source geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetScaling(System.Int32)">
            <summary>
                <para>Turn on/off scaling of source geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.GetSource(System.Int32)">
            <summary>
                <para>Get a pointer to a source object at a specified table location.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetSourceConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Get a pointer to a source object at a specified table location.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetSourceConnection(System.Int32,vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Specify a source object at a specified table location. New style. Source connection is stored in port 1. This method is equivalent to SetInputConnection(1, id, outputPort).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetSource(System.Int32,vtk.vtkPolyData)">
            <summary>
                <para>Specify a source object at a specified table location. Old style. See SetSourceConnection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGlyph3D.SetSource(vtk.vtkPolyData)">
            <summary>
                <para>Set the source to use for he glyph. Old style. See SetSourceConnection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataLevelFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataLevelFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataLevelFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalDataLevelFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataLevelFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataLevelFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCubeSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCubeSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCubeSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCubeSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCubeSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCubeSource.SetBounds(System.Double[])">
            <summary>
                <para>Convenience method allows creation of cube by specifying bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.SetBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Convenience method allows creation of cube by specifying bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetCenter">
            <summary>
                <para>Set the center of the cube.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.SetCenter(System.Double[])">
            <summary>
                <para>Set the center of the cube.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.SetCenter(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the center of the cube.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetZLength">
            <summary>
                <para>Set the length of the cube in the z-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetZLengthMaxValue">
            <summary>
                <para>Set the length of the cube in the z-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetZLengthMinValue">
            <summary>
                <para>Set the length of the cube in the z-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.SetZLength(System.Double)">
            <summary>
                <para>Set the length of the cube in the z-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetYLength">
            <summary>
                <para>Set the length of the cube in the y-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetYLengthMaxValue">
            <summary>
                <para>Set the length of the cube in the y-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetYLengthMinValue">
            <summary>
                <para>Set the length of the cube in the y-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.SetYLength(System.Double)">
            <summary>
                <para>Set the length of the cube in the y-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetXLength">
            <summary>
                <para>Set the length of the cube in the x-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetXLengthMaxValue">
            <summary>
                <para>Set the length of the cube in the x-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.GetXLengthMinValue">
            <summary>
                <para>Set the length of the cube in the x-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeSource.SetXLength(System.Double)">
            <summary>
                <para>Set the length of the cube in the x-direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTextSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTextSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTextSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTextSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTextSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextSource.GetBackgroundColor">
            <summary>
                <para>Set/Get the background color. Default is black (0,0,0). Alpha is always 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.SetBackgroundColor(System.Double[])">
            <summary>
                <para>Set/Get the background color. Default is black (0,0,0). Alpha is always 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.SetBackgroundColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the background color. Default is black (0,0,0). Alpha is always 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.GetForegroundColor">
            <summary>
                <para>Set/Get the foreground color. Default is white (1,1,1). ALpha is always 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.SetForegroundColor(System.Double[])">
            <summary>
                <para>Set/Get the foreground color. Default is white (1,1,1). ALpha is always 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.SetForegroundColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the foreground color. Default is white (1,1,1). ALpha is always 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.BackingOff">
            <summary>
                <para>Controls whether or not a background is drawn with the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.BackingOn">
            <summary>
                <para>Controls whether or not a background is drawn with the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.GetBacking">
            <summary>
                <para>Controls whether or not a background is drawn with the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.SetBacking(System.Int32)">
            <summary>
                <para>Controls whether or not a background is drawn with the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.GetText">
            <summary>
                <para>Set/Get the text to be drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextSource.SetText(System.String)">
            <summary>
                <para>Set/Get the text to be drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.ColorRegionsOff">
            <summary>
                <para>Turn on/off the coloring of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.ColorRegionsOn">
            <summary>
                <para>Turn on/off the coloring of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetColorRegions">
            <summary>
                <para>Turn on/off the coloring of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetColorRegions(System.Int32)">
            <summary>
                <para>Turn on/off the coloring of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetNumberOfExtractedRegions">
            <summary>
                <para>Obtain the number of connected regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetClosestPoint">
            <summary>
                <para>Use to specify x-y-z point coordinates when extracting the region  closest to a specified point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetClosestPoint(System.Double[])">
            <summary>
                <para>Use to specify x-y-z point coordinates when extracting the region  closest to a specified point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetClosestPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Use to specify x-y-z point coordinates when extracting the region  closest to a specified point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.DeleteSpecifiedRegion(System.Int32)">
            <summary>
                <para>Delete a region id to extract. Note: ids are 0-offset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.AddSpecifiedRegion(System.Int32)">
            <summary>
                <para>Add a region id to extract. Note: ids are 0-offset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.InitializeSpecifiedRegionList">
            <summary>
                <para>Initialize list of region ids to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.DeleteSeed(System.Int32)">
            <summary>
                <para>Delete a seed id (point or cell id). Note: ids are 0-offset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.AddSeed(System.Int32)">
            <summary>
                <para>Add a seed id (point or cell id). Note: ids are 0-offset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.InitializeSeedList">
            <summary>
                <para>Initialize list of point ids/cell ids used to seed regions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetExtractionModeAsString">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetExtractionModeToAllRegions">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetExtractionModeToClosestPointRegion">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetExtractionModeToSpecifiedRegions">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetExtractionModeToLargestRegion">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetExtractionModeToCellSeededRegions">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetExtractionModeToPointSeededRegions">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetExtractionMode">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetExtractionModeMaxValue">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetExtractionModeMinValue">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetExtractionMode(System.Int32)">
            <summary>
                <para>Control the extraction of connected surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetScalarRange">
            <summary>
                <para>Set the scalar range to use to extract cells based on scalar connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetScalarRange(System.Double[])">
            <summary>
                <para>Set the scalar range to use to extract cells based on scalar connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetScalarRange(System.Double,System.Double)">
            <summary>
                <para>Set the scalar range to use to extract cells based on scalar connectivity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.ScalarConnectivityOff">
            <summary>
                <para>Turn on/off connectivity based on scalar value. If on, cells are connected only if they share points AND one of the cells scalar values falls in the scalar range specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.ScalarConnectivityOn">
            <summary>
                <para>Turn on/off connectivity based on scalar value. If on, cells are connected only if they share points AND one of the cells scalar values falls in the scalar range specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.GetScalarConnectivity">
            <summary>
                <para>Turn on/off connectivity based on scalar value. If on, cells are connected only if they share points AND one of the cells scalar values falls in the scalar range specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkConnectivityFilter.SetScalarConnectivity(System.Int32)">
            <summary>
                <para>Turn on/off connectivity based on scalar value. If on, cells are connected only if they share points AND one of the cells scalar values falls in the scalar range specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.ExtractBoundaryCellsOff">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.ExtractBoundaryCellsOn">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.GetExtractBoundaryCells">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.SetExtractBoundaryCells(System.Int32)">
            <summary>
                <para>Boolean controls whether to extract cells that are partially inside. By default, ExtractBoundaryCells is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.ExtractInsideOff">
            <summary>
                <para>Boolean controls whether to extract cells that are inside of implicit  function (ExtractInside == 1) or outside of implicit function  (ExtractInside == 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.ExtractInsideOn">
            <summary>
                <para>Boolean controls whether to extract cells that are inside of implicit  function (ExtractInside == 1) or outside of implicit function  (ExtractInside == 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.GetExtractInside">
            <summary>
                <para>Boolean controls whether to extract cells that are inside of implicit  function (ExtractInside == 1) or outside of implicit function  (ExtractInside == 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.SetExtractInside(System.Int32)">
            <summary>
                <para>Boolean controls whether to extract cells that are inside of implicit  function (ExtractInside == 1) or outside of implicit function  (ExtractInside == 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.GetImplicitFunction">
            <summary>
                <para>Specify the implicit function for inside/outside checks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.SetImplicitFunction(vtk.vtkImplicitFunction)">
            <summary>
                <para>Specify the implicit function for inside/outside checks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractPolyDataGeometry.GetMTime">
            <summary>
                <para>Return the MTime taking into account changes to the implicit function</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplitField.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSplitField.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSplitField.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSplitField.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSplitField.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSplitField.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSplitField.Split(System.Int32,System.String)">
            <summary>
                <para>Create a new array with the given component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplitField.SetInputField(System.String,System.String)">
            <summary>
                <para>Helper method used by other language bindings. Allows the caller to specify arguments as strings instead of enums.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplitField.SetInputField(System.String,System.Int32)">
            <summary>
                <para>Use the array with given name in the field data given by fieldLoc as input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSplitField.SetInputField(System.Int32,System.Int32)">
            <summary>
                <para>Use the  given attribute in the field data given by fieldLoc as input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetLocator">
            <summary>
                <para>Set / get a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / get a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.UseScalarTreeOff">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.UseScalarTreeOn">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetUseScalarTree">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.SetUseScalarTree(System.Int32)">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.ComputeScalarsOff">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.ComputeScalarsOn">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetComputeScalars">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.SetComputeScalars(System.Int32)">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.ComputeGradientsOff">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.ComputeGradientsOn">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetComputeGradients">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.SetComputeGradients(System.Int32)">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetMTime">
            <summary>
                <para>Modified GetMTime Because we delegate to vtkContourValues</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetNumberOfContours">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetValues(System.Double[])">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.GetValue(System.Int32)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingContourFilter.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWarpScalar.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.XYPlaneOff">
            <summary>
                <para>Turn on/off flag specifying that input data is x-y plane. If x-y plane, then the z value is used to warp the surface in the z-axis direction  (times the scale factor) and scalars are used to color the surface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.XYPlaneOn">
            <summary>
                <para>Turn on/off flag specifying that input data is x-y plane. If x-y plane, then the z value is used to warp the surface in the z-axis direction  (times the scale factor) and scalars are used to color the surface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.GetXYPlane">
            <summary>
                <para>Turn on/off flag specifying that input data is x-y plane. If x-y plane, then the z value is used to warp the surface in the z-axis direction  (times the scale factor) and scalars are used to color the surface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.SetXYPlane(System.Int32)">
            <summary>
                <para>Turn on/off flag specifying that input data is x-y plane. If x-y plane, then the z value is used to warp the surface in the z-axis direction  (times the scale factor) and scalars are used to color the surface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.GetNormal">
            <summary>
                <para>Normal (i.e., direction) along which to warp geometry. Only used if UseNormal boolean set to true or no normals available in data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.SetNormal(System.Double[])">
            <summary>
                <para>Normal (i.e., direction) along which to warp geometry. Only used if UseNormal boolean set to true or no normals available in data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.SetNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Normal (i.e., direction) along which to warp geometry. Only used if UseNormal boolean set to true or no normals available in data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.UseNormalOff">
            <summary>
                <para>Turn on/off use of user specified normal. If on, data normals will be ignored and instance variable Normal will be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.UseNormalOn">
            <summary>
                <para>Turn on/off use of user specified normal. If on, data normals will be ignored and instance variable Normal will be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.GetUseNormal">
            <summary>
                <para>Turn on/off use of user specified normal. If on, data normals will be ignored and instance variable Normal will be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.SetUseNormal(System.Int32)">
            <summary>
                <para>Turn on/off use of user specified normal. If on, data normals will be ignored and instance variable Normal will be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.GetScaleFactor">
            <summary>
                <para>Specify value to scale displacement.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpScalar.SetScaleFactor(System.Double)">
            <summary>
                <para>Specify value to scale displacement.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.PassAttributeDataOff">
            <summary>
                <para>Turn on/off the passing of point and cell non-field attribute data to the output of the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.PassAttributeDataOn">
            <summary>
                <para>Turn on/off the passing of point and cell non-field attribute data to the output of the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.GetPassAttributeData">
            <summary>
                <para>Turn on/off the passing of point and cell non-field attribute data to the output of the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAttributeDataToFieldDataFilter.SetPassAttributeData(System.Int32)">
            <summary>
                <para>Turn on/off the passing of point and cell non-field attribute data to the output of the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssignAttribute.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAssignAttribute.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAssignAttribute.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAssignAttribute.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAssignAttribute.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAssignAttribute.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAssignAttribute.Assign(System.String,System.String,System.String)">
            <summary>
                <para>Helper method used by other language bindings. Allows the caller to specify arguments as strings instead of enums.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssignAttribute.Assign(System.String,System.Int32,System.Int32)">
            <summary>
                <para>Label an array as an attribute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssignAttribute.Assign(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Label an attribute as another attribute.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxelContoursToSurfaceFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVoxelContoursToSurfaceFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVoxelContoursToSurfaceFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVoxelContoursToSurfaceFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVoxelContoursToSurfaceFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVoxelContoursToSurfaceFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVoxelContoursToSurfaceFilter.GetMemoryLimitInBytes">
            <summary>
                <para>Set / Get the memory limit in bytes for this filter. This is the limit of the size of the structured points data set that is created for intermediate processing. The data will be streamed through this volume in as many pieces as necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoxelContoursToSurfaceFilter.SetMemoryLimitInBytes(System.Int32)">
            <summary>
                <para>Set / Get the memory limit in bytes for this filter. This is the limit of the size of the structured points data set that is created for intermediate processing. The data will be streamed through this volume in as many pieces as necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHyperStreamline.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.LogScalingOff">
            <summary>
                <para>Turn on/off logarithmic scaling. If scaling is on, the log base 10 of the computed eigenvalues are used to scale the cross section radii.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.LogScalingOn">
            <summary>
                <para>Turn on/off logarithmic scaling. If scaling is on, the log base 10 of the computed eigenvalues are used to scale the cross section radii.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetLogScaling">
            <summary>
                <para>Turn on/off logarithmic scaling. If scaling is on, the log base 10 of the computed eigenvalues are used to scale the cross section radii.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetLogScaling(System.Int32)">
            <summary>
                <para>Turn on/off logarithmic scaling. If scaling is on, the log base 10 of the computed eigenvalues are used to scale the cross section radii.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetRadius">
            <summary>
                <para>Set / get the initial tube radius. This is the maximum "elliptical" radius at the beginning of the tube. Radius varies based on ratio of eigenvalues.  Note that tube section is actually elliptical and may become a point or line in cross section in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetRadiusMaxValue">
            <summary>
                <para>Set / get the initial tube radius. This is the maximum "elliptical" radius at the beginning of the tube. Radius varies based on ratio of eigenvalues.  Note that tube section is actually elliptical and may become a point or line in cross section in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetRadiusMinValue">
            <summary>
                <para>Set / get the initial tube radius. This is the maximum "elliptical" radius at the beginning of the tube. Radius varies based on ratio of eigenvalues.  Note that tube section is actually elliptical and may become a point or line in cross section in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetRadius(System.Double)">
            <summary>
                <para>Set / get the initial tube radius. This is the maximum "elliptical" radius at the beginning of the tube. Radius varies based on ratio of eigenvalues.  Note that tube section is actually elliptical and may become a point or line in cross section in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetNumberOfSides">
            <summary>
                <para>Set / get the number of sides for the hyperstreamlines. At a minimum, number of sides is 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetNumberOfSidesMaxValue">
            <summary>
                <para>Set / get the number of sides for the hyperstreamlines. At a minimum, number of sides is 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetNumberOfSidesMinValue">
            <summary>
                <para>Set / get the number of sides for the hyperstreamlines. At a minimum, number of sides is 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetNumberOfSides(System.Int32)">
            <summary>
                <para>Set / get the number of sides for the hyperstreamlines. At a minimum, number of sides is 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetTerminalEigenvalue">
            <summary>
                <para>Set/get terminal eigenvalue.  If major eigenvalue falls below this value, hyperstreamline terminates propagation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetTerminalEigenvalueMaxValue">
            <summary>
                <para>Set/get terminal eigenvalue.  If major eigenvalue falls below this value, hyperstreamline terminates propagation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetTerminalEigenvalueMinValue">
            <summary>
                <para>Set/get terminal eigenvalue.  If major eigenvalue falls below this value, hyperstreamline terminates propagation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetTerminalEigenvalue(System.Double)">
            <summary>
                <para>Set/get terminal eigenvalue.  If major eigenvalue falls below this value, hyperstreamline terminates propagation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationDirectionToIntegrateBothDirections">
            <summary>
                <para>Specify the direction in which to integrate the hyperstreamline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationDirectionToBackward">
            <summary>
                <para>Specify the direction in which to integrate the hyperstreamline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationDirectionToForward">
            <summary>
                <para>Specify the direction in which to integrate the hyperstreamline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationDirection">
            <summary>
                <para>Specify the direction in which to integrate the hyperstreamline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationDirectionMaxValue">
            <summary>
                <para>Specify the direction in which to integrate the hyperstreamline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationDirectionMinValue">
            <summary>
                <para>Specify the direction in which to integrate the hyperstreamline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationDirection(System.Int32)">
            <summary>
                <para>Specify the direction in which to integrate the hyperstreamline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetStepLength">
            <summary>
                <para>Set / get the length of a tube segment composing the hyperstreamline. The length is specified as a fraction of the diagonal length of the input bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetStepLengthMaxValue">
            <summary>
                <para>Set / get the length of a tube segment composing the hyperstreamline. The length is specified as a fraction of the diagonal length of the input bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetStepLengthMinValue">
            <summary>
                <para>Set / get the length of a tube segment composing the hyperstreamline. The length is specified as a fraction of the diagonal length of the input bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetStepLength(System.Double)">
            <summary>
                <para>Set / get the length of a tube segment composing the hyperstreamline. The length is specified as a fraction of the diagonal length of the input bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationStepLength">
            <summary>
                <para>Set / get a nominal integration step size (expressed as a fraction of the size of each cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationStepLengthMaxValue">
            <summary>
                <para>Set / get a nominal integration step size (expressed as a fraction of the size of each cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationStepLengthMinValue">
            <summary>
                <para>Set / get a nominal integration step size (expressed as a fraction of the size of each cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationStepLength(System.Double)">
            <summary>
                <para>Set / get a nominal integration step size (expressed as a fraction of the size of each cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.IntegrateMinorEigenvector">
            <summary>
                <para>Use the minor eigenvector field as the vector field through which to integrate. The minor eigenvector is the eigenvector whose corresponding eigenvalue is closest to negative infinity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.IntegrateMediumEigenvector">
            <summary>
                <para>Use the medium eigenvector field as the vector field through which to integrate. The medium eigenvector is the eigenvector whose corresponding eigenvalue is between the major and minor eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.IntegrateMajorEigenvector">
            <summary>
                <para>Use the major eigenvector field as the vector field through which to integrate.  The major eigenvector is the eigenvector whose corresponding eigenvalue is closest to positive infinity.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationEigenvectorToMinor">
            <summary>
                <para>Set / get the eigenvector field through which to ingrate. It is possible to integrate using the major, medium or minor eigenvector field.  The major eigenvector is the eigenvector whose corresponding eigenvalue is closest to positive infinity. The minor eigenvector is the eigenvector whose corresponding eigenvalue is closest to negative infinity.  The medium eigenvector is the eigenvector whose corresponding eigenvalue is between the major and minor eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationEigenvectorToMedium">
            <summary>
                <para>Set / get the eigenvector field through which to ingrate. It is possible to integrate using the major, medium or minor eigenvector field.  The major eigenvector is the eigenvector whose corresponding eigenvalue is closest to positive infinity. The minor eigenvector is the eigenvector whose corresponding eigenvalue is closest to negative infinity.  The medium eigenvector is the eigenvector whose corresponding eigenvalue is between the major and minor eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationEigenvectorToMajor">
            <summary>
                <para>Set / get the eigenvector field through which to ingrate. It is possible to integrate using the major, medium or minor eigenvector field.  The major eigenvector is the eigenvector whose corresponding eigenvalue is closest to positive infinity. The minor eigenvector is the eigenvector whose corresponding eigenvalue is closest to negative infinity.  The medium eigenvector is the eigenvector whose corresponding eigenvalue is between the major and minor eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationEigenvector">
            <summary>
                <para>Set / get the eigenvector field through which to ingrate. It is possible to integrate using the major, medium or minor eigenvector field.  The major eigenvector is the eigenvector whose corresponding eigenvalue is closest to positive infinity. The minor eigenvector is the eigenvector whose corresponding eigenvalue is closest to negative infinity.  The medium eigenvector is the eigenvector whose corresponding eigenvalue is between the major and minor eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationEigenvectorMaxValue">
            <summary>
                <para>Set / get the eigenvector field through which to ingrate. It is possible to integrate using the major, medium or minor eigenvector field.  The major eigenvector is the eigenvector whose corresponding eigenvalue is closest to positive infinity. The minor eigenvector is the eigenvector whose corresponding eigenvalue is closest to negative infinity.  The medium eigenvector is the eigenvector whose corresponding eigenvalue is between the major and minor eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetIntegrationEigenvectorMinValue">
            <summary>
                <para>Set / get the eigenvector field through which to ingrate. It is possible to integrate using the major, medium or minor eigenvector field.  The major eigenvector is the eigenvector whose corresponding eigenvalue is closest to positive infinity. The minor eigenvector is the eigenvector whose corresponding eigenvalue is closest to negative infinity.  The medium eigenvector is the eigenvector whose corresponding eigenvalue is between the major and minor eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetIntegrationEigenvector(System.Int32)">
            <summary>
                <para>Set / get the eigenvector field through which to ingrate. It is possible to integrate using the major, medium or minor eigenvector field.  The major eigenvector is the eigenvector whose corresponding eigenvalue is closest to positive infinity. The minor eigenvector is the eigenvector whose corresponding eigenvalue is closest to negative infinity.  The medium eigenvector is the eigenvector whose corresponding eigenvalue is between the major and minor eigenvalues.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetMaximumPropagationDistance">
            <summary>
                <para>Set / get the maximum length of the hyperstreamline expressed as absolute distance (i.e., arc length) value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetMaximumPropagationDistanceMaxValue">
            <summary>
                <para>Set / get the maximum length of the hyperstreamline expressed as absolute distance (i.e., arc length) value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetMaximumPropagationDistanceMinValue">
            <summary>
                <para>Set / get the maximum length of the hyperstreamline expressed as absolute distance (i.e., arc length) value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetMaximumPropagationDistance(System.Double)">
            <summary>
                <para>Set / get the maximum length of the hyperstreamline expressed as absolute distance (i.e., arc length) value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetStartPosition">
            <summary>
                <para>Get the start position of the hyperstreamline in global x-y-z coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetStartPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the start of the hyperstreamline in the global coordinate system.  Starting from position implies that a search must be performed to find  initial cell to start integration from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetStartPosition(System.Double[])">
            <summary>
                <para>Specify the start of the hyperstreamline in the global coordinate system.  Starting from position implies that a search must be performed to find  initial cell to start integration from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.GetStartLocation(System.Int32@,System.Double[])">
            <summary>
                <para>Get the starting location of the hyperstreamline in the cell coordinate system. Returns the cell that the starting point is in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetStartLocation(System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify the start of the hyperstreamline in the cell coordinate system.  That is, cellId and subId (if composite cell), and parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHyperStreamline.SetStartLocation(System.Int32,System.Int32,System.Double[])">
            <summary>
                <para>Specify the start of the hyperstreamline in the cell coordinate system.  That is, cellId and subId (if composite cell), and parametric coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLoopSubdivisionFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLoopSubdivisionFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLoopSubdivisionFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLoopSubdivisionFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLoopSubdivisionFilter.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLoopSubdivisionFilter.NewInstance">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLoopSubdivisionFilter.IsA(System.String)">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLoopSubdivisionFilter.GetClassName">
            <summary>
                <para>Construct object with NumberOfSubdivisions set to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkApproximatingSubdivisionFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkApproximatingSubdivisionFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkApproximatingSubdivisionFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkApproximatingSubdivisionFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkApproximatingSubdivisionFilter.GetNumberOfSubdivisions">
            <summary>
                <para>Set/get the number of subdivisions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkApproximatingSubdivisionFilter.SetNumberOfSubdivisions(System.Int32)">
            <summary>
                <para>Set/get the number of subdivisions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTriangularTCoords.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTriangularTCoords.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTriangularTCoords.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTriangularTCoords.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTriangularTCoords.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTriangularTCoords.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellCenters.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellCenters.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellCenters.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellCenters.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellCenters.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellCenters.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellCenters.VertexCellsOff">
            <summary>
                <para>Enable/disable the generation of vertex cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellCenters.VertexCellsOn">
            <summary>
                <para>Enable/disable the generation of vertex cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellCenters.GetVertexCells">
            <summary>
                <para>Enable/disable the generation of vertex cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellCenters.SetVertexCells(System.Int32)">
            <summary>
                <para>Enable/disable the generation of vertex cells.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.FlipTOff">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  t-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.FlipTOn">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  t-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.GetFlipT">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  t-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetFlipT(System.Int32)">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  t-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.FlipSOff">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  s-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.FlipSOn">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  s-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.GetFlipS">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  s-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetFlipS(System.Int32)">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  s-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.FlipROff">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  s-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.FlipROn">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  s-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.GetFlipR">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  s-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetFlipR(System.Int32)">
            <summary>
                <para>Boolean indicates whether the texture map should be flipped around the  s-axis. Note that the flips occur around the texture origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.GetOrigin">
            <summary>
                <para>Set/Get the origin of the texture map. This is the point about which the texture map is flipped (e.g., rotated). Since a typical texture map ranges from (0,1) in the r-s-t coordinates, the default origin is set at  (0.5,0.5,0.5).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetOrigin(System.Double[])">
            <summary>
                <para>Set/Get the origin of the texture map. This is the point about which the texture map is flipped (e.g., rotated). Since a typical texture map ranges from (0,1) in the r-s-t coordinates, the default origin is set at  (0.5,0.5,0.5).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the origin of the texture map. This is the point about which the texture map is flipped (e.g., rotated). Since a typical texture map ranges from (0,1) in the r-s-t coordinates, the default origin is set at  (0.5,0.5,0.5).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.GetScale">
            <summary>
                <para>Set/Get the scale of the texture map. Scaling in performed independently  on the r, s and t axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetScale(System.Double[])">
            <summary>
                <para>Set/Get the scale of the texture map. Scaling in performed independently  on the r, s and t axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetScale(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the scale of the texture map. Scaling in performed independently  on the r, s and t axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.AddPosition(System.Double[])">
            <summary>
                <para>Incrementally change the position of the texture map (i.e., does a translate or shift of the texture coordinates).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.AddPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Incrementally change the position of the texture map (i.e., does a translate or shift of the texture coordinates).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.GetPosition">
            <summary>
                <para>Set/Get the position of the texture map. Setting the position translates the texture map by the amount specified. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetPosition(System.Double[])">
            <summary>
                <para>Set/Get the position of the texture map. Setting the position translates the texture map by the amount specified. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformTextureCoords.SetPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the position of the texture map. Setting the position translates the texture map by the amount specified. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHull.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHull.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHull.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHull.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHull.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHull.GenerateHull(vtk.vtkPolyData,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>A special method that is used to generate a polyhedron directly from a set of n planes. The planes that are supplied by the user are not squeezed towards the input data (in fact the user need not specify an input). To use this method, you must provide an instance of vtkPolyData into which the points and cells defining the polyhedron are placed. You must also provide a bounding box where you expect the resulting polyhedron to lie. This can be a very generous fit, it's only used to create the initial polygons that are eventually clipped.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.GenerateHull(vtk.vtkPolyData,System.Double[])">
            <summary>
                <para>A special method that is used to generate a polyhedron directly from a set of n planes. The planes that are supplied by the user are not squeezed towards the input data (in fact the user need not specify an input). To use this method, you must provide an instance of vtkPolyData into which the points and cells defining the polyhedron are placed. You must also provide a bounding box where you expect the resulting polyhedron to lie. This can be a very generous fit, it's only used to create the initial polygons that are eventually clipped.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.AddRecursiveSpherePlanes(System.Int32)">
            <summary>
                <para>Add the planes that represent the normals of the vertices of a polygonal sphere formed by recursively subdividing the triangles in an octahedron.  Each triangle is subdivided by connecting the midpoints of the edges thus forming 4 smaller triangles. The level indicates how many subdivisions to do with a level of 0 used to add the 6 planes from the original octahedron, level 1 will add 18 planes, and so on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.AddCubeFacePlanes">
            <summary>
                <para>Add the six planes that make up the faces of a cube - (1,0,0), (-1, 0, 0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.AddCubeEdgePlanes">
            <summary>
                <para>Add the 12 planes that represent the edges of a cube - halfway between the two connecting face planes - (1,1,0), (-1,-1,0), (-1,1,0), (1,-1,0), (0,1,1), (0,-1,-1), (0,1,-1), (0,-1,1), (1,0,1), (-1,0,-1), (1,0,-1), (-1,0,1)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.AddCubeVertexPlanes">
            <summary>
                <para>Add the 8 planes that represent the vertices of a cube - the combination of the three face planes connecting to a vertex - (1,1,1), (1,1,-1), (1,-1,1), (1,-1,1), (-1,1,1), (-1,1,-1), (-1,-1,1), (-1,-1-1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.GetNumberOfPlanes">
            <summary>
                <para>Get the number of planes in the current set of planes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.SetPlanes(vtk.vtkPlanes)">
            <summary>
                <para>Set all the planes at once using a vtkPlanes implicit function. This also sets the D value, so it can be used with GenerateHull().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.SetPlane(System.Int32,System.Double[],System.Double)">
            <summary>
                <para>Variations of AddPlane()/SetPlane() that allow D to be set. These  methods are used when GenerateHull() is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.SetPlane(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Variations of AddPlane()/SetPlane() that allow D to be set. These  methods are used when GenerateHull() is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.AddPlane(System.Double[],System.Double)">
            <summary>
                <para>Variations of AddPlane()/SetPlane() that allow D to be set. These  methods are used when GenerateHull() is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.AddPlane(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Variations of AddPlane()/SetPlane() that allow D to be set. These  methods are used when GenerateHull() is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.SetPlane(System.Int32,System.Double[])">
            <summary>
                <para>Set the normal values for plane i. This is a plane that was already added to the current set of planes with AddPlane(), and is now being modified. The values A, B, C are from the plane equation  Ax + By + Cz + D = 0. This vector does not have to have unit length. Note that D is set to zero, except in the case of the method taking a vtkPlanes* argument, where it is set to the D value defined there.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.SetPlane(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the normal values for plane i. This is a plane that was already added to the current set of planes with AddPlane(), and is now being modified. The values A, B, C are from the plane equation  Ax + By + Cz + D = 0. This vector does not have to have unit length. Note that D is set to zero, except in the case of the method taking a vtkPlanes* argument, where it is set to the D value defined there.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.AddPlane(System.Double[])">
            <summary>
                <para>Add a plane to the current set of planes. It will be added at the end of the list, and an index that can later be used to set this plane's normal will be returned. The values A, B, C are from the plane equation Ax + By + Cz + D = 0. This vector does not have to have unit length (but it must have a non-zero length!). If a value 0 &gt; i &gt;= -NumberOfPlanes is returned, then the plane is parallel with a previously inserted plane, and |-i-1| is the index of the plane that was previously inserted. If a value i &lt; -NumberOfPlanes is returned, then the plane normal is zero length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.AddPlane(System.Double,System.Double,System.Double)">
            <summary>
                <para>Add a plane to the current set of planes. It will be added at the end of the list, and an index that can later be used to set this plane's normal will be returned. The values A, B, C are from the plane equation Ax + By + Cz + D = 0. This vector does not have to have unit length (but it must have a non-zero length!). If a value 0 &gt; i &gt;= -NumberOfPlanes is returned, then the plane is parallel with a previously inserted plane, and |-i-1| is the index of the plane that was previously inserted. If a value i &lt; -NumberOfPlanes is returned, then the plane normal is zero length.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHull.RemoveAllPlanes">
            <summary>
                <para>Remove all planes from the current set of planes.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMaskPolyData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.GetOffset">
            <summary>
                <para>Start with this entity (cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.GetOffsetMaxValue">
            <summary>
                <para>Start with this entity (cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.GetOffsetMinValue">
            <summary>
                <para>Start with this entity (cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.SetOffset(System.Int32)">
            <summary>
                <para>Start with this entity (cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.GetOnRatio">
            <summary>
                <para>Turn on every nth entity (cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.GetOnRatioMaxValue">
            <summary>
                <para>Turn on every nth entity (cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.GetOnRatioMinValue">
            <summary>
                <para>Turn on every nth entity (cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPolyData.SetOnRatio(System.Int32)">
            <summary>
                <para>Turn on every nth entity (cell).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.DefaultNormalizeOff">
            <summary>
                <para>Set the default Normalize() flag for those methods setting a default Normalize value (e.g., SetPointComponent).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.DefaultNormalizeOn">
            <summary>
                <para>Set the default Normalize() flag for those methods setting a default Normalize value (e.g., SetPointComponent).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetDefaultNormalize">
            <summary>
                <para>Set the default Normalize() flag for those methods setting a default Normalize value (e.g., SetPointComponent).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetDefaultNormalize(System.Int32)">
            <summary>
                <para>Set the default Normalize() flag for those methods setting a default Normalize value (e.g., SetPointComponent).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetCellConnectivityComponentMaxRange">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetCellConnectivityComponentMinRange">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetCellConnectivityComponentArrayComponent">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetCellConnectivityComponentArrayName">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetCellConnectivityComponent(System.String,System.Int32)">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetCellConnectivityComponent(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetCellTypeComponentMaxRange">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetCellTypeComponentMinRange">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetCellTypeComponentArrayComponent">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetCellTypeComponentArrayName">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetCellTypeComponent(System.String,System.Int32)">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetCellTypeComponent(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define cell types and cell connectivity when creating unstructured grid data.  These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of cell types (an integer value per cell), and another array consisting (for each cell) of a number of points per cell, and then the cell connectivity. (This is the vtk file format described in  in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetStripsComponentMaxRange">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetStripsComponentMinRange">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetStripsComponentArrayComponent">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetStripsComponentArrayName">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetStripsComponent(System.String,System.Int32)">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetStripsComponent(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPolysComponentMaxRange">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPolysComponentMinRange">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPolysComponentArrayComponent">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPolysComponentArrayName">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetPolysComponent(System.String,System.Int32)">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetPolysComponent(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetLinesComponentMaxRange">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetLinesComponentMinRange">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetLinesComponentArrayComponent">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetLinesComponentArrayName">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetLinesComponent(System.String,System.Int32)">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetLinesComponent(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetVertsComponentMaxRange">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetVertsComponentMinRange">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetVertsComponentArrayComponent">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetVertsComponentArrayName">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetVertsComponent(System.String,System.Int32)">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetVertsComponent(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define cell connectivity when creating vtkPolyData. You can define vertices, lines, polygons, and/or triangle strips via these methods. These methods are similar to those for defining points, except that no normalization of the data is possible. Basically, you need to define an array of values that (for each cell) includes the number of  points per cell, and then the cell connectivity. (This is the vtk file  format described in in the textbook or User's Guide.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPointComponentNormailzeFlag(System.Int32)">
            <summary>
                <para>Define the component of the field to be used for the x, y, and z values of the points. Note that the parameter comp must lie between (0,2) and refers to the x-y-z (i.e., 0,1,2) components of the points. To define the field component to use you can specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract. (This method should be used for vtkPolyData, vtkUnstructuredGrid, vtkStructuredGrid, and vtkRectilinearGrid.) A convenience method, SetPointComponent(),is also provided which does not require setting the (min,max) component range or the normalize flag (normalize is set to DefaulatNormalize value).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPointComponentMaxRange(System.Int32)">
            <summary>
                <para>Define the component of the field to be used for the x, y, and z values of the points. Note that the parameter comp must lie between (0,2) and refers to the x-y-z (i.e., 0,1,2) components of the points. To define the field component to use you can specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract. (This method should be used for vtkPolyData, vtkUnstructuredGrid, vtkStructuredGrid, and vtkRectilinearGrid.) A convenience method, SetPointComponent(),is also provided which does not require setting the (min,max) component range or the normalize flag (normalize is set to DefaulatNormalize value).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPointComponentMinRange(System.Int32)">
            <summary>
                <para>Define the component of the field to be used for the x, y, and z values of the points. Note that the parameter comp must lie between (0,2) and refers to the x-y-z (i.e., 0,1,2) components of the points. To define the field component to use you can specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract. (This method should be used for vtkPolyData, vtkUnstructuredGrid, vtkStructuredGrid, and vtkRectilinearGrid.) A convenience method, SetPointComponent(),is also provided which does not require setting the (min,max) component range or the normalize flag (normalize is set to DefaulatNormalize value).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPointComponentArrayComponent(System.Int32)">
            <summary>
                <para>Define the component of the field to be used for the x, y, and z values of the points. Note that the parameter comp must lie between (0,2) and refers to the x-y-z (i.e., 0,1,2) components of the points. To define the field component to use you can specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract. (This method should be used for vtkPolyData, vtkUnstructuredGrid, vtkStructuredGrid, and vtkRectilinearGrid.) A convenience method, SetPointComponent(),is also provided which does not require setting the (min,max) component range or the normalize flag (normalize is set to DefaulatNormalize value).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPointComponentArrayName(System.Int32)">
            <summary>
                <para>Define the component of the field to be used for the x, y, and z values of the points. Note that the parameter comp must lie between (0,2) and refers to the x-y-z (i.e., 0,1,2) components of the points. To define the field component to use you can specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract. (This method should be used for vtkPolyData, vtkUnstructuredGrid, vtkStructuredGrid, and vtkRectilinearGrid.) A convenience method, SetPointComponent(),is also provided which does not require setting the (min,max) component range or the normalize flag (normalize is set to DefaulatNormalize value).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetPointComponent(System.Int32,System.String,System.Int32)">
            <summary>
                <para>Define the component of the field to be used for the x, y, and z values of the points. Note that the parameter comp must lie between (0,2) and refers to the x-y-z (i.e., 0,1,2) components of the points. To define the field component to use you can specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract. (This method should be used for vtkPolyData, vtkUnstructuredGrid, vtkStructuredGrid, and vtkRectilinearGrid.) A convenience method, SetPointComponent(),is also provided which does not require setting the (min,max) component range or the normalize flag (normalize is set to DefaulatNormalize value).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetPointComponent(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define the component of the field to be used for the x, y, and z values of the points. Note that the parameter comp must lie between (0,2) and refers to the x-y-z (i.e., 0,1,2) components of the points. To define the field component to use you can specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract. (This method should be used for vtkPolyData, vtkUnstructuredGrid, vtkStructuredGrid, and vtkRectilinearGrid.) A convenience method, SetPointComponent(),is also provided which does not require setting the (min,max) component range or the normalize flag (normalize is set to DefaulatNormalize value).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetRectilinearGridOutput">
            <summary>
                <para>Get the output in different forms. The particular method invoked should be consistent with the SetDataSetType() method. (Note: GetOutput() will always return a type consistent with  SetDataSetType(). Also, GetOutput() will return NULL if the filter aborted due to inconsistent data.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetUnstructuredGridOutput">
            <summary>
                <para>Get the output in different forms. The particular method invoked should be consistent with the SetDataSetType() method. (Note: GetOutput() will always return a type consistent with  SetDataSetType(). Also, GetOutput() will return NULL if the filter aborted due to inconsistent data.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetStructuredGridOutput">
            <summary>
                <para>Get the output in different forms. The particular method invoked should be consistent with the SetDataSetType() method. (Note: GetOutput() will always return a type consistent with  SetDataSetType(). Also, GetOutput() will return NULL if the filter aborted due to inconsistent data.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetStructuredPointsOutput">
            <summary>
                <para>Get the output in different forms. The particular method invoked should be consistent with the SetDataSetType() method. (Note: GetOutput() will always return a type consistent with  SetDataSetType(). Also, GetOutput() will return NULL if the filter aborted due to inconsistent data.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetPolyDataOutput">
            <summary>
                <para>Get the output in different forms. The particular method invoked should be consistent with the SetDataSetType() method. (Note: GetOutput() will always return a type consistent with  SetDataSetType(). Also, GetOutput() will return NULL if the filter aborted due to inconsistent data.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetOutput(System.Int32)">
            <summary>
                <para>Get the output in different forms. The particular method invoked should be consistent with the SetDataSetType() method. (Note: GetOutput() will always return a type consistent with  SetDataSetType(). Also, GetOutput() will return NULL if the filter aborted due to inconsistent data.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetOutput">
            <summary>
                <para>Get the output in different forms. The particular method invoked should be consistent with the SetDataSetType() method. (Note: GetOutput() will always return a type consistent with  SetDataSetType(). Also, GetOutput() will return NULL if the filter aborted due to inconsistent data.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetDataSetTypeToUnstructuredGrid">
            <summary>
                <para>Control what type of data is generated for output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetDataSetTypeToRectilinearGrid">
            <summary>
                <para>Control what type of data is generated for output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetDataSetTypeToStructuredGrid">
            <summary>
                <para>Control what type of data is generated for output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetDataSetTypeToStructuredPoints">
            <summary>
                <para>Control what type of data is generated for output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetDataSetTypeToPolyData">
            <summary>
                <para>Control what type of data is generated for output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetDataSetType">
            <summary>
                <para>Control what type of data is generated for output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.SetDataSetType(System.Int32)">
            <summary>
                <para>Control what type of data is generated for output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataObjectToDataSetFilter.GetInput">
            <summary>
                <para>Get the input to the filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkArrayCalculator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetReplacementValue">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.SetReplacementValue(System.Double)">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.ReplaceInvalidValuesOff">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.ReplaceInvalidValuesOn">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetReplaceInvalidValues">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.SetReplaceInvalidValues(System.Int32)">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetNumberOfVectorArrays">
            <summary>
                <para>Methods to get information about the current variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetNumberOfScalarArrays">
            <summary>
                <para>Methods to get information about the current variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetSelectedScalarComponent(System.Int32)">
            <summary>
                <para>Methods to get information about the current variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetVectorVariableName(System.Int32)">
            <summary>
                <para>Methods to get information about the current variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetScalarVariableName(System.Int32)">
            <summary>
                <para>Methods to get information about the current variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetVectorArrayName(System.Int32)">
            <summary>
                <para>Methods to get information about the current variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetScalarArrayName(System.Int32)">
            <summary>
                <para>Methods to get information about the current variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.RemoveAllVariables">
            <summary>
                <para>Remove all the variable names and their associated array names.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetAttributeModeAsString">
            <summary>
                <para>Control whether the filter operates on point data or cell data. By default (AttributeModeToDefault), the filter uses point data. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.SetAttributeModeToUseCellData">
            <summary>
                <para>Control whether the filter operates on point data or cell data. By default (AttributeModeToDefault), the filter uses point data. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.SetAttributeModeToUsePointData">
            <summary>
                <para>Control whether the filter operates on point data or cell data. By default (AttributeModeToDefault), the filter uses point data. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.SetAttributeModeToDefault">
            <summary>
                <para>Control whether the filter operates on point data or cell data. By default (AttributeModeToDefault), the filter uses point data. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetAttributeMode">
            <summary>
                <para>Control whether the filter operates on point data or cell data. By default (AttributeModeToDefault), the filter uses point data. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.SetAttributeMode(System.Int32)">
            <summary>
                <para>Control whether the filter operates on point data or cell data. By default (AttributeModeToDefault), the filter uses point data. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetResultArrayName">
            <summary>
                <para>Set the name of the array in which to store the result of evaluating this function.  If this is the name of an existing array, that array will be overwritten.  Otherwise a new array will be created with the specified name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.SetResultArrayName(System.String)">
            <summary>
                <para>Set the name of the array in which to store the result of evaluating this function.  If this is the name of an existing array, that array will be overwritten.  Otherwise a new array will be created with the specified name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.AddVectorVariable(System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Add a variable name, a corresponding array name, and which components of the array to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.AddScalarVariable(System.String,System.String,System.Int32)">
            <summary>
                <para>Add a variable name, a corresponding array name, and which components of the array to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.AddVectorArrayName(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Add an array name to the list of arrays used in the function and specify which components of the array to use in evaluating the function.  The array name must match the name in the function.  Use AddScalarVariable or AddVectorVariable to use a variable name different from the array name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.AddScalarArrayName(System.String,System.Int32)">
            <summary>
                <para>Add an array name to the list of arrays used in the function and specify which components of the array to use in evaluating the function.  The array name must match the name in the function.  Use AddScalarVariable or AddVectorVariable to use a variable name different from the array name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.GetFunction">
            <summary>
                <para>Set/Get the function to be evaluated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArrayCalculator.SetFunction(System.String)">
            <summary>
                <para>Set/Get the function to be evaluated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.GetTargetValue">
            <summary>
                <para>These methods can make the positioning look for a target scalar value instead of looking for a maximum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.SetTargetValue(System.Double)">
            <summary>
                <para>These methods can make the positioning look for a target scalar value instead of looking for a maximum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.TargetFlagOff">
            <summary>
                <para>These methods can make the positioning look for a target scalar value instead of looking for a maximum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.TargetFlagOn">
            <summary>
                <para>These methods can make the positioning look for a target scalar value instead of looking for a maximum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.GetTargetFlag">
            <summary>
                <para>These methods can make the positioning look for a target scalar value instead of looking for a maximum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.SetTargetFlag(System.Int32)">
            <summary>
                <para>These methods can make the positioning look for a target scalar value instead of looking for a maximum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.GetGradMaps">
            <summary>
                <para>Set/Get the gradient data for doing the position adjustments.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSubPixelPositionEdgels.SetGradMaps(vtk.vtkStructuredPoints)">
            <summary>
                <para>Set/Get the gradient data for doing the position adjustments.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetMTime">
            <summary>
                <para>Return the MTime also considering the parametric function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToFunctionDefined">
            <summary>
                <para>Return the MTime also considering the parametric function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToDistance">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToZ">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToY">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToX">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToQuadrant">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToPhase">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToModulus">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToU0V0">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToV0">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToU0">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToV">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToU">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarModeToNone">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetScalarMode">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetScalarModeMaxValue">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetScalarModeMinValue">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetScalarMode(System.Int32)">
            <summary>
                <para>Get/Set the mode used for the scalar data.  The options are: SCALAR_NONE, (default) scalars are not generated. SCALAR_U, the scalar is set to the u-value.  SCALAR_V, the scalar is set to the v-value. SCALAR_U0, the scalar is set to 1 if u = (u_max - u_min)/2 = u_avg, 0 otherwise. SCALAR_V0, the scalar is set to 1 if v = (v_max - v_min)/2 = v_avg, 0 otherwise. SCALAR_U0V0, the scalar is    set to 1 if u == u_avg, 2 if v == v_avg, 3 if u = u_avg &amp;&amp; v = v_avg, 0 otherwise. SCALAR_MODULUS, the scalar is set to (sqrt(u*u+v*v)), this is measured relative to (u_avg,v_avg). SCALAR_PHASE, the scalar is set to (atan2(v,u)) (in degrees, 0 to 360), this is measured relative to (u_avg,v_avg). SCALAR_QUADRANT, the scalar is set to 1, 2, 3 or 4    depending upon the quadrant of the point (u,v). SCALAR_X, the scalar is set to the x-value.  SCALAR_Y, the scalar is set to the y-value.  SCALAR_Z, the scalar is set to the z-value.  SCALAR_DISTANCE, the scalar is set to (sqrt(x*x+y*y+z*z)). I.e. distance from the origin. SCALAR_FUNCTION_DEFINED, the scalar is set to the value returned from EvaluateScalar().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetGenerateTextureCoordinates">
            <summary>
                <para>Set/Get the generation of texture coordinates. This is off by default. Note that this is only applicable to parametric surfaces  whose parametric dimension is 2. Note that texturing may fail in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetGenerateTextureCoordinates(System.Int32)">
            <summary>
                <para>Set/Get the generation of texture coordinates. This is off by default. Note that this is only applicable to parametric surfaces  whose parametric dimension is 2. Note that texturing may fail in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GenerateTextureCoordinatesOff">
            <summary>
                <para>Set/Get the generation of texture coordinates. This is off by default. Note that this is only applicable to parametric surfaces  whose parametric dimension is 2. Note that texturing may fail in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GenerateTextureCoordinatesOn">
            <summary>
                <para>Set/Get the generation of texture coordinates. This is off by default. Note that this is only applicable to parametric surfaces  whose parametric dimension is 2. Note that texturing may fail in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetWResolution">
            <summary>
                <para>Set/Get the number of subdivisions / tessellations in the w parametric direction. Note that the number of tessellant points in the w  direction is the WResolution + 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetWResolution(System.Int32)">
            <summary>
                <para>Set/Get the number of subdivisions / tessellations in the w parametric direction. Note that the number of tessellant points in the w  direction is the WResolution + 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetVResolution">
            <summary>
                <para>Set/Get the number of subdivisions / tessellations in the v parametric direction. Note that the number of tessellant points in the v  direction is the VResolution + 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetVResolution(System.Int32)">
            <summary>
                <para>Set/Get the number of subdivisions / tessellations in the v parametric direction. Note that the number of tessellant points in the v  direction is the VResolution + 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetUResolution">
            <summary>
                <para>Set/Get the number of subdivisions / tessellations in the u parametric direction. Note that the number of tessellant points in the u  direction is the UResolution + 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetUResolution(System.Int32)">
            <summary>
                <para>Set/Get the number of subdivisions / tessellations in the u parametric direction. Note that the number of tessellant points in the u  direction is the UResolution + 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.GetParametricFunction">
            <summary>
                <para>Specify the parametric function to use to generate the tessellation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunctionSource.SetParametricFunction(vtk.vtkParametricFunction)">
            <summary>
                <para>Specify the parametric function to use to generate the tessellation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetFieldArray(vtk.vtkFieldData,System.String,System.Int32)">
            <summary>
                <para>Return an array of a particular name from field data and do error checking.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.ConstructArray(vtk.vtkDataArray,System.Int32,vtk.vtkDataArray,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Construct a portion of a data array (the comp portion) from another data array and its component. The variables min and max control the range of the data to use from the other data array; normalize is a flag that when set will normalize the data between (0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.DefaultNormalizeOff">
            <summary>
                <para>Set the default Normalize() flag for those methods setting a default Normalize value (e.g., SetScalarComponents).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.DefaultNormalizeOn">
            <summary>
                <para>Set the default Normalize() flag for those methods setting a default Normalize value (e.g., SetScalarComponents).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetDefaultNormalize">
            <summary>
                <para>Set the default Normalize() flag for those methods setting a default Normalize value (e.g., SetScalarComponents).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetDefaultNormalize(System.Int32)">
            <summary>
                <para>Set the default Normalize() flag for those methods setting a default Normalize value (e.g., SetScalarComponents).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTCoordComponentNormalizeFlag(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the cell texture coord components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTCoordComponentMaxRange(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the cell texture coord components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTCoordComponentMinRange(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the cell texture coord components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTCoordComponentArrayComponent(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the cell texture coord components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTCoordComponentArrayName(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the cell texture coord components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetTCoordComponent(System.Int32,System.String,System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the cell texture coord components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetTCoordComponent(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the cell texture coord components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTensorComponentNormalizeFlag(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the tensor components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTensorComponentMaxRange(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the tensor components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTensorComponentMinRange(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the tensor components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTensorComponentArrayComponent(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the tensor components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetTensorComponentArrayName(System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the tensor components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetTensorComponent(System.Int32,System.String,System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the tensor components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetTensorComponent(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define the components of the field to be used for the tensor components.  Note that the parameter comp must lie between (0,9). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetNormalComponentNormalizeFlag(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the normal components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetNormalComponentMaxRange(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the normal components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetNormalComponentMinRange(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the normal components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetNormalComponentArrayComponent(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the normal components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetNormalComponentArrayName(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the normal components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetNormalComponent(System.Int32,System.String,System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the normal components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetNormalComponent(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the normal components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetVectorComponentNormalizeFlag(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the vector components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetVectorComponentMaxRange(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the vector components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetVectorComponentMinRange(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the vector components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetVectorComponentArrayComponent(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the vector components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetVectorComponentArrayName(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the vector components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetVectorComponent(System.Int32,System.String,System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the vector components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetVectorComponent(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the vector components.  Note that the parameter comp must lie between (0,3). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetScalarComponentNormalizeFlag(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the scalar components.  Note that the parameter comp must lie between (0,4). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetScalarComponentMaxRange(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the scalar components.  Note that the parameter comp must lie between (0,4). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetScalarComponentMinRange(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the scalar components.  Note that the parameter comp must lie between (0,4). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetScalarComponentArrayComponent(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the scalar components.  Note that the parameter comp must lie between (0,4). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetScalarComponentArrayName(System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the scalar components.  Note that the parameter comp must lie between (0,4). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetScalarComponent(System.Int32,System.String,System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the scalar components.  Note that the parameter comp must lie between (0,4). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetScalarComponent(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Define the component(s) of the field to be used for the scalar components.  Note that the parameter comp must lie between (0,4). To define the field component to use you specify an array name and the component in that array. The (min,max) values are the range of data in the component you wish to extract.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetOutputAttributeDataToPointData">
            <summary>
                <para>Specify which attribute data to output: point or cell data attributes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetOutputAttributeDataToCellData">
            <summary>
                <para>Specify which attribute data to output: point or cell data attributes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetOutputAttributeData">
            <summary>
                <para>Specify which attribute data to output: point or cell data attributes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetOutputAttributeData(System.Int32)">
            <summary>
                <para>Specify which attribute data to output: point or cell data attributes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetInputFieldToCellDataField">
            <summary>
                <para>Specify which field data to use to generate the output attribute data. There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetInputFieldToPointDataField">
            <summary>
                <para>Specify which field data to use to generate the output attribute data. There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetInputFieldToDataObjectField">
            <summary>
                <para>Specify which field data to use to generate the output attribute data. There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.GetInputField">
            <summary>
                <para>Specify which field data to use to generate the output attribute data. There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFieldDataToAttributeDataFilter.SetInputField(System.Int32)">
            <summary>
                <para>Specify which field data to use to generate the output attribute data. There are three choices: the field data associated with the vtkDataObject superclass; the point field attribute data; and the cell field attribute data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMarchingSquares.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified.  The locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.GetMTime">
            <summary>
                <para>Because we delegate to vtkContourValues</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.GetNumberOfContours">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.GetValues(System.Double[])">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.GetValue(System.Int32)">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Methods to set contour values</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.SetImageRange(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the i-j-k index range which define a plane on which to generate  contour lines. Using this ivar it is possible to input a 3D volume directly and then generate contour lines on one of the i-j-k planes, or  a portion of a plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.GetImageRange">
            <summary>
                <para>Set/Get the i-j-k index range which define a plane on which to generate  contour lines. Using this ivar it is possible to input a 3D volume directly and then generate contour lines on one of the i-j-k planes, or  a portion of a plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMarchingSquares.SetImageRange(System.Int32[])">
            <summary>
                <para>Set/Get the i-j-k index range which define a plane on which to generate  contour lines. Using this ivar it is possible to input a 3D volume directly and then generate contour lines on one of the i-j-k planes, or  a portion of a plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkShrinkFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.GetShrinkFactor">
            <summary>
                <para>Get/Set the fraction of shrink for each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.GetShrinkFactorMaxValue">
            <summary>
                <para>Get/Set the fraction of shrink for each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.GetShrinkFactorMinValue">
            <summary>
                <para>Get/Set the fraction of shrink for each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShrinkFilter.SetShrinkFactor(System.Double)">
            <summary>
                <para>Get/Set the fraction of shrink for each cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFeatureEdges.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetMTime">
            <summary>
                <para>Return MTime also considering the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetLocator">
            <summary>
                <para>Set / get a spatial locator for merging points. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / get a spatial locator for merging points. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.ColoringOff">
            <summary>
                <para>Turn on/off the coloring of edges by type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.ColoringOn">
            <summary>
                <para>Turn on/off the coloring of edges by type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetColoring">
            <summary>
                <para>Turn on/off the coloring of edges by type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.SetColoring(System.Int32)">
            <summary>
                <para>Turn on/off the coloring of edges by type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.ManifoldEdgesOff">
            <summary>
                <para>Turn on/off the extraction of manifold edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.ManifoldEdgesOn">
            <summary>
                <para>Turn on/off the extraction of manifold edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetManifoldEdges">
            <summary>
                <para>Turn on/off the extraction of manifold edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.SetManifoldEdges(System.Int32)">
            <summary>
                <para>Turn on/off the extraction of manifold edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.NonManifoldEdgesOff">
            <summary>
                <para>Turn on/off the extraction of non-manifold edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.NonManifoldEdgesOn">
            <summary>
                <para>Turn on/off the extraction of non-manifold edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetNonManifoldEdges">
            <summary>
                <para>Turn on/off the extraction of non-manifold edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.SetNonManifoldEdges(System.Int32)">
            <summary>
                <para>Turn on/off the extraction of non-manifold edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetFeatureAngle">
            <summary>
                <para>Specify the feature angle for extracting feature edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetFeatureAngleMaxValue">
            <summary>
                <para>Specify the feature angle for extracting feature edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetFeatureAngleMinValue">
            <summary>
                <para>Specify the feature angle for extracting feature edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.SetFeatureAngle(System.Double)">
            <summary>
                <para>Specify the feature angle for extracting feature edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.FeatureEdgesOff">
            <summary>
                <para>Turn on/off the extraction of feature edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.FeatureEdgesOn">
            <summary>
                <para>Turn on/off the extraction of feature edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetFeatureEdges">
            <summary>
                <para>Turn on/off the extraction of feature edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.SetFeatureEdges(System.Int32)">
            <summary>
                <para>Turn on/off the extraction of feature edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.BoundaryEdgesOff">
            <summary>
                <para>Turn on/off the extraction of boundary edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.BoundaryEdgesOn">
            <summary>
                <para>Turn on/off the extraction of boundary edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.GetBoundaryEdges">
            <summary>
                <para>Turn on/off the extraction of boundary edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFeatureEdges.SetBoundaryEdges(System.Int32)">
            <summary>
                <para>Turn on/off the extraction of boundary edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadricClustering.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.CopyCellDataOff">
            <summary>
                <para>This flag makes the filter copy cell data from input to output  (the best it can).  It uses input cells that trigger the addition of output cells (no averaging).  This is off by default, and does not work when append is being called explicitely (non-pipeline usage).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.CopyCellDataOn">
            <summary>
                <para>This flag makes the filter copy cell data from input to output  (the best it can).  It uses input cells that trigger the addition of output cells (no averaging).  This is off by default, and does not work when append is being called explicitely (non-pipeline usage).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetCopyCellData">
            <summary>
                <para>This flag makes the filter copy cell data from input to output  (the best it can).  It uses input cells that trigger the addition of output cells (no averaging).  This is off by default, and does not work when append is being called explicitely (non-pipeline usage).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetCopyCellData(System.Int32)">
            <summary>
                <para>This flag makes the filter copy cell data from input to output  (the best it can).  It uses input cells that trigger the addition of output cells (no averaging).  This is off by default, and does not work when append is being called explicitely (non-pipeline usage).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.EndAppend">
            <summary>
                <para>These methods provide an alternative way of executing the filter. PolyData can be added to the result in pieces (append). In this mode, the user must specify the bounds of the entire model as an argument to the "StartAppend" method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.Append(vtk.vtkPolyData)">
            <summary>
                <para>These methods provide an alternative way of executing the filter. PolyData can be added to the result in pieces (append). In this mode, the user must specify the bounds of the entire model as an argument to the "StartAppend" method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.StartAppend(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods provide an alternative way of executing the filter. PolyData can be added to the result in pieces (append). In this mode, the user must specify the bounds of the entire model as an argument to the "StartAppend" method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.StartAppend(System.Double[])">
            <summary>
                <para>These methods provide an alternative way of executing the filter. PolyData can be added to the result in pieces (append). In this mode, the user must specify the bounds of the entire model as an argument to the "StartAppend" method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.UseInternalTrianglesOff">
            <summary>
                <para>When this flag is on (and it is on by default), then triangles that are  completely contained in a bin are added to the bin quadrics.  When the the flag is off the filter operates faster, but the surface may not be as well behaved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.UseInternalTrianglesOn">
            <summary>
                <para>When this flag is on (and it is on by default), then triangles that are  completely contained in a bin are added to the bin quadrics.  When the the flag is off the filter operates faster, but the surface may not be as well behaved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetUseInternalTriangles">
            <summary>
                <para>When this flag is on (and it is on by default), then triangles that are  completely contained in a bin are added to the bin quadrics.  When the the flag is off the filter operates faster, but the surface may not be as well behaved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetUseInternalTriangles(System.Int32)">
            <summary>
                <para>When this flag is on (and it is on by default), then triangles that are  completely contained in a bin are added to the bin quadrics.  When the the flag is off the filter operates faster, but the surface may not be as well behaved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetFeaturePointsAngle">
            <summary>
                <para>Set/Get the angle to use in determining whether a point on a boundary / feature edge is a feature point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetFeaturePointsAngleMaxValue">
            <summary>
                <para>Set/Get the angle to use in determining whether a point on a boundary / feature edge is a feature point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetFeaturePointsAngleMinValue">
            <summary>
                <para>Set/Get the angle to use in determining whether a point on a boundary / feature edge is a feature point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetFeaturePointsAngle(System.Double)">
            <summary>
                <para>Set/Get the angle to use in determining whether a point on a boundary / feature edge is a feature point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.UseFeaturePointsOff">
            <summary>
                <para>By default, this flag is off.  It only has an effect when "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on, then quadrics are computed for boundary / feature points used in the boundary / feature edges.  They influence the quadrics (position of points), but not the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.UseFeaturePointsOn">
            <summary>
                <para>By default, this flag is off.  It only has an effect when "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on, then quadrics are computed for boundary / feature points used in the boundary / feature edges.  They influence the quadrics (position of points), but not the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetUseFeaturePoints">
            <summary>
                <para>By default, this flag is off.  It only has an effect when "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on, then quadrics are computed for boundary / feature points used in the boundary / feature edges.  They influence the quadrics (position of points), but not the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetUseFeaturePoints(System.Int32)">
            <summary>
                <para>By default, this flag is off.  It only has an effect when "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on, then quadrics are computed for boundary / feature points used in the boundary / feature edges.  They influence the quadrics (position of points), but not the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetFeatureEdges">
            <summary>
                <para>By default, this flag is off.  It only has an effect when "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on, then quadrics are computed for boundary / feature points used in the boundary / feature edges.  They influence the quadrics (position of points), but not the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.UseFeatureEdgesOff">
            <summary>
                <para>By default, this flag is off.  When "UseFeatureEdges" is on, then quadrics are computed for boundary edges/feature edges.  They influence the quadrics (position of points), but not the mesh.  Which features to use can be controlled by the filter "FeatureEdges".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.UseFeatureEdgesOn">
            <summary>
                <para>By default, this flag is off.  When "UseFeatureEdges" is on, then quadrics are computed for boundary edges/feature edges.  They influence the quadrics (position of points), but not the mesh.  Which features to use can be controlled by the filter "FeatureEdges".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetUseFeatureEdges">
            <summary>
                <para>By default, this flag is off.  When "UseFeatureEdges" is on, then quadrics are computed for boundary edges/feature edges.  They influence the quadrics (position of points), but not the mesh.  Which features to use can be controlled by the filter "FeatureEdges".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetUseFeatureEdges(System.Int32)">
            <summary>
                <para>By default, this flag is off.  When "UseFeatureEdges" is on, then quadrics are computed for boundary edges/feature edges.  They influence the quadrics (position of points), but not the mesh.  Which features to use can be controlled by the filter "FeatureEdges".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.UseInputPointsOff">
            <summary>
                <para>Normally the point that minimizes the quadric error function is used as the output of the bin.  When this flag is on, the bin point is forced to be one of the points from the input (the one with the smallest error). This option does not work (i.e., input points cannot be used) when the append methods (StartAppend(), Append(), EndAppend()) are being called directly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.UseInputPointsOn">
            <summary>
                <para>Normally the point that minimizes the quadric error function is used as the output of the bin.  When this flag is on, the bin point is forced to be one of the points from the input (the one with the smallest error). This option does not work (i.e., input points cannot be used) when the append methods (StartAppend(), Append(), EndAppend()) are being called directly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetUseInputPoints">
            <summary>
                <para>Normally the point that minimizes the quadric error function is used as the output of the bin.  When this flag is on, the bin point is forced to be one of the points from the input (the one with the smallest error). This option does not work (i.e., input points cannot be used) when the append methods (StartAppend(), Append(), EndAppend()) are being called directly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetUseInputPoints(System.Int32)">
            <summary>
                <para>Normally the point that minimizes the quadric error function is used as the output of the bin.  When this flag is on, the bin point is forced to be one of the points from the input (the one with the smallest error). This option does not work (i.e., input points cannot be used) when the append methods (StartAppend(), Append(), EndAppend()) are being called directly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetDivisionSpacing">
            <summary>
                <para>This is an alternative way to set up the bins.  If you are trying to match boundaries between pieces, then you should use these methods rather than SetNumberOfDivisions. To use these methods, specify the origin and spacing of the spatial binning.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetDivisionSpacing(System.Double[])">
            <summary>
                <para>This is an alternative way to set up the bins.  If you are trying to match boundaries between pieces, then you should use these methods rather than SetNumberOfDivisions. To use these methods, specify the origin and spacing of the spatial binning.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetDivisionSpacing(System.Double,System.Double,System.Double)">
            <summary>
                <para>This is an alternative way to set up the bins.  If you are trying to match boundaries between pieces, then you should use these methods rather than SetNumberOfDivisions. To use these methods, specify the origin and spacing of the spatial binning.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetDivisionOrigin">
            <summary>
                <para>This is an alternative way to set up the bins.  If you are trying to match boundaries between pieces, then you should use these methods rather than SetNumberOfDivisions. To use these methods, specify the origin and spacing of the spatial binning.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetDivisionOrigin(System.Double[])">
            <summary>
                <para>This is an alternative way to set up the bins.  If you are trying to match boundaries between pieces, then you should use these methods rather than SetNumberOfDivisions. To use these methods, specify the origin and spacing of the spatial binning.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetDivisionOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>This is an alternative way to set up the bins.  If you are trying to match boundaries between pieces, then you should use these methods rather than SetNumberOfDivisions. To use these methods, specify the origin and spacing of the spatial binning.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.AutoAdjustNumberOfDivisionsOff">
            <summary>
                <para>Enable automatic adjustment of number of divisions. If off, the number of divisions specified by the user is always used (as long as it is valid).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.AutoAdjustNumberOfDivisionsOn">
            <summary>
                <para>Enable automatic adjustment of number of divisions. If off, the number of divisions specified by the user is always used (as long as it is valid).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetAutoAdjustNumberOfDivisions">
            <summary>
                <para>Enable automatic adjustment of number of divisions. If off, the number of divisions specified by the user is always used (as long as it is valid).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetAutoAdjustNumberOfDivisions(System.Int32)">
            <summary>
                <para>Enable automatic adjustment of number of divisions. If off, the number of divisions specified by the user is always used (as long as it is valid).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetNumberOfDivisions(System.Int32[])">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetNumberOfDivisions">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetNumberOfDivisions(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetNumberOfDivisions(System.Int32[])">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetNumberOfZDivisions">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetNumberOfYDivisions">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.GetNumberOfXDivisions">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetNumberOfZDivisions(System.Int32)">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetNumberOfYDivisions(System.Int32)">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuadricClustering.SetNumberOfXDivisions(System.Int32)">
            <summary>
                <para>Set/Get the number of divisions along each axis for the spatial bins. The number of spatial bins is NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The filter may choose to ignore large numbers of divisions if the input has few points and AutoAdjustNumberOfDivisions is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkElevationFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.GetScalarRange">
            <summary>
                <para>Specify range to map scalars into.  Default is [0, 1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.SetScalarRange(System.Double[])">
            <summary>
                <para>Specify range to map scalars into.  Default is [0, 1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.SetScalarRange(System.Double,System.Double)">
            <summary>
                <para>Specify range to map scalars into.  Default is [0, 1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.GetHighPoint">
            <summary>
                <para>Define other end of the line (large scalar values).  Default is (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.SetHighPoint(System.Double[])">
            <summary>
                <para>Define other end of the line (large scalar values).  Default is (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.SetHighPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Define other end of the line (large scalar values).  Default is (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.GetLowPoint">
            <summary>
                <para>Define one end of the line (small scalar values).  Default is (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.SetLowPoint(System.Double[])">
            <summary>
                <para>Define one end of the line (small scalar values).  Default is (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkElevationFilter.SetLowPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Define one end of the line (small scalar values).  Default is (0,0,0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetSource">
            <summary>
                <para>Specify the source object which is used to constrain smoothing. The  source defines a surface that the input (as it is smoothed) is  constrained to lie upon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetSource(vtk.vtkPolyData)">
            <summary>
                <para>Specify the source object which is used to constrain smoothing. The  source defines a surface that the input (as it is smoothed) is  constrained to lie upon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GenerateErrorVectorsOff">
            <summary>
                <para>Turn on/off the generation of error vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GenerateErrorVectorsOn">
            <summary>
                <para>Turn on/off the generation of error vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetGenerateErrorVectors">
            <summary>
                <para>Turn on/off the generation of error vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetGenerateErrorVectors(System.Int32)">
            <summary>
                <para>Turn on/off the generation of error vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GenerateErrorScalarsOff">
            <summary>
                <para>Turn on/off the generation of scalar distance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GenerateErrorScalarsOn">
            <summary>
                <para>Turn on/off the generation of scalar distance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetGenerateErrorScalars">
            <summary>
                <para>Turn on/off the generation of scalar distance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetGenerateErrorScalars(System.Int32)">
            <summary>
                <para>Turn on/off the generation of scalar distance values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.BoundarySmoothingOff">
            <summary>
                <para>Turn on/off the smoothing of vertices on the boundary of the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.BoundarySmoothingOn">
            <summary>
                <para>Turn on/off the smoothing of vertices on the boundary of the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetBoundarySmoothing">
            <summary>
                <para>Turn on/off the smoothing of vertices on the boundary of the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetBoundarySmoothing(System.Int32)">
            <summary>
                <para>Turn on/off the smoothing of vertices on the boundary of the mesh.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetEdgeAngle">
            <summary>
                <para>Specify the edge angle to control smoothing along edges (either interior or boundary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetEdgeAngleMaxValue">
            <summary>
                <para>Specify the edge angle to control smoothing along edges (either interior or boundary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetEdgeAngleMinValue">
            <summary>
                <para>Specify the edge angle to control smoothing along edges (either interior or boundary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetEdgeAngle(System.Double)">
            <summary>
                <para>Specify the edge angle to control smoothing along edges (either interior or boundary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetFeatureAngle">
            <summary>
                <para>Specify the feature angle for sharp edge identification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetFeatureAngleMaxValue">
            <summary>
                <para>Specify the feature angle for sharp edge identification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetFeatureAngleMinValue">
            <summary>
                <para>Specify the feature angle for sharp edge identification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetFeatureAngle(System.Double)">
            <summary>
                <para>Specify the feature angle for sharp edge identification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.FeatureEdgeSmoothingOff">
            <summary>
                <para>Turn on/off smoothing along sharp interior edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.FeatureEdgeSmoothingOn">
            <summary>
                <para>Turn on/off smoothing along sharp interior edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetFeatureEdgeSmoothing">
            <summary>
                <para>Turn on/off smoothing along sharp interior edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetFeatureEdgeSmoothing(System.Int32)">
            <summary>
                <para>Turn on/off smoothing along sharp interior edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetRelaxationFactor">
            <summary>
                <para>Specify the relaxation factor for Laplacian smoothing. As in all iterative methods, the stability of the process is sensitive to this parameter. In general, small relaxation factors and large numbers of iterations are more stable than larger relaxation factors and smaller numbers of iterations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetRelaxationFactor(System.Double)">
            <summary>
                <para>Specify the relaxation factor for Laplacian smoothing. As in all iterative methods, the stability of the process is sensitive to this parameter. In general, small relaxation factors and large numbers of iterations are more stable than larger relaxation factors and smaller numbers of iterations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetNumberOfIterations">
            <summary>
                <para>Specify the number of iterations for Laplacian smoothing,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetNumberOfIterationsMaxValue">
            <summary>
                <para>Specify the number of iterations for Laplacian smoothing,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetNumberOfIterationsMinValue">
            <summary>
                <para>Specify the number of iterations for Laplacian smoothing,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetNumberOfIterations(System.Int32)">
            <summary>
                <para>Specify the number of iterations for Laplacian smoothing,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetConvergence">
            <summary>
                <para>Specify a convergence criterion for the iteration process. Smaller numbers result in more smoothing iterations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetConvergenceMaxValue">
            <summary>
                <para>Specify a convergence criterion for the iteration process. Smaller numbers result in more smoothing iterations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.GetConvergenceMinValue">
            <summary>
                <para>Specify a convergence criterion for the iteration process. Smaller numbers result in more smoothing iterations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSmoothPolyDataFilter.SetConvergence(System.Double)">
            <summary>
                <para>Specify a convergence criterion for the iteration process. Smaller numbers result in more smoothing iterations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetGeometryFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetGeometryFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetGeometryFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetGeometryFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetGeometryFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataSetGeometryFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSortDataArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.Sort(vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Sorts the given key/value pairs based on the keys.  A pair is given as the entries at a given index of each of the arrays.  Obviously, the two arrays must be of equal size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.Sort(vtk.vtkDataArray,vtk.vtkIdList)">
            <summary>
                <para>Sorts the given key/value pairs based on the keys.  A pair is given as the entries at a given index of each of the arrays.  Obviously, the two arrays must be of equal size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.Sort(vtk.vtkIdList,vtk.vtkDataArray)">
            <summary>
                <para>Sorts the given key/value pairs based on the keys.  A pair is given as the entries at a given index of each of the arrays.  Obviously, the two arrays must be of equal size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.Sort(vtk.vtkIdList,vtk.vtkIdList)">
            <summary>
                <para>Sorts the given key/value pairs based on the keys.  A pair is given as the entries at a given index of each of the arrays.  Obviously, the two arrays must be of equal size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.Sort(vtk.vtkDataArray)">
            <summary>
                <para>Sorts the given array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSortDataArray.Sort(vtk.vtkIdList)">
            <summary>
                <para>Sorts the given array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanesIntersection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPlanesIntersection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPlanesIntersection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPlanesIntersection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPlanesIntersection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPlanesIntersection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRibbonFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetTextureLength">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetTextureLengthMaxValue">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetTextureLengthMinValue">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetTextureLength(System.Double)">
            <summary>
                <para>Control the conversion of units during the texture coordinates calculation. The TextureLength indicates what length (whether  calculated from scalars or length) is mapped to the [0,1) texture space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetGenerateTCoordsAsString">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetGenerateTCoordsToUseScalars">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetGenerateTCoordsToUseLength">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetGenerateTCoordsToNormalizedLength">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetGenerateTCoordsToOff">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetGenerateTCoords">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetGenerateTCoordsMaxValue">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetGenerateTCoordsMinValue">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetGenerateTCoords(System.Int32)">
            <summary>
                <para>Control whether and how texture coordinates are produced. This is useful for striping the ribbon with time textures, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.UseDefaultNormalOff">
            <summary>
                <para>Set a boolean to control whether to use default normals. DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.UseDefaultNormalOn">
            <summary>
                <para>Set a boolean to control whether to use default normals. DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetUseDefaultNormal">
            <summary>
                <para>Set a boolean to control whether to use default normals. DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetUseDefaultNormal(System.Int32)">
            <summary>
                <para>Set a boolean to control whether to use default normals. DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetDefaultNormal">
            <summary>
                <para>Set the default normal to use if no normals are supplied, and the DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetDefaultNormal(System.Double[])">
            <summary>
                <para>Set the default normal to use if no normals are supplied, and the DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetDefaultNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the default normal to use if no normals are supplied, and the DefaultNormalOn is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetWidthFactor">
            <summary>
                <para>Set the maximum ribbon width in terms of a multiple of the minimum width.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetWidthFactor(System.Double)">
            <summary>
                <para>Set the maximum ribbon width in terms of a multiple of the minimum width.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.VaryWidthOff">
            <summary>
                <para>Turn on/off the variation of ribbon width with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.VaryWidthOn">
            <summary>
                <para>Turn on/off the variation of ribbon width with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetVaryWidth">
            <summary>
                <para>Turn on/off the variation of ribbon width with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetVaryWidth(System.Int32)">
            <summary>
                <para>Turn on/off the variation of ribbon width with scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetAngle">
            <summary>
                <para>Set the offset angle of the ribbon from the line normal. (The angle is expressed in degrees.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetAngleMaxValue">
            <summary>
                <para>Set the offset angle of the ribbon from the line normal. (The angle is expressed in degrees.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetAngleMinValue">
            <summary>
                <para>Set the offset angle of the ribbon from the line normal. (The angle is expressed in degrees.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetAngle(System.Double)">
            <summary>
                <para>Set the offset angle of the ribbon from the line normal. (The angle is expressed in degrees.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetWidth">
            <summary>
                <para>Set the "half" width of the ribbon. If the width is allowed to vary,  this is the minimum width.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetWidthMaxValue">
            <summary>
                <para>Set the "half" width of the ribbon. If the width is allowed to vary,  this is the minimum width.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.GetWidthMinValue">
            <summary>
                <para>Set the "half" width of the ribbon. If the width is allowed to vary,  this is the minimum width.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRibbonFilter.SetWidth(System.Double)">
            <summary>
                <para>Set the "half" width of the ribbon. If the width is allowed to vary,  this is the minimum width.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGeometryFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetMTime">
            <summary>
                <para>Return the MTime also considering the locator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetLocator">
            <summary>
                <para>Set / get a spatial locator for merging points. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / get a spatial locator for merging points. By default an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.MergingOff">
            <summary>
                <para>Turn on/off merging of coincident points. Note that is merging is on, points with different point attributes (e.g., normals) are merged, which may cause rendering artifacts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.MergingOn">
            <summary>
                <para>Turn on/off merging of coincident points. Note that is merging is on, points with different point attributes (e.g., normals) are merged, which may cause rendering artifacts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetMerging">
            <summary>
                <para>Turn on/off merging of coincident points. Note that is merging is on, points with different point attributes (e.g., normals) are merged, which may cause rendering artifacts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetMerging(System.Int32)">
            <summary>
                <para>Turn on/off merging of coincident points. Note that is merging is on, points with different point attributes (e.g., normals) are merged, which may cause rendering artifacts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetExtent">
            <summary>
                <para>Set / get a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetExtent(System.Double[])">
            <summary>
                <para>Set / get a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetExtent(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Specify a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetCellMaximum">
            <summary>
                <para>Specify the maximum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetCellMaximumMaxValue">
            <summary>
                <para>Specify the maximum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetCellMaximumMinValue">
            <summary>
                <para>Specify the maximum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetCellMaximum(System.Int32)">
            <summary>
                <para>Specify the maximum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetCellMinimum">
            <summary>
                <para>Specify the minimum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetCellMinimumMaxValue">
            <summary>
                <para>Specify the minimum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetCellMinimumMinValue">
            <summary>
                <para>Specify the minimum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetCellMinimum(System.Int32)">
            <summary>
                <para>Specify the minimum cell id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetPointMaximum">
            <summary>
                <para>Specify the maximum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetPointMaximumMaxValue">
            <summary>
                <para>Specify the maximum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetPointMaximumMinValue">
            <summary>
                <para>Specify the maximum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetPointMaximum(System.Int32)">
            <summary>
                <para>Specify the maximum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetPointMinimum">
            <summary>
                <para>Specify the minimum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetPointMinimumMaxValue">
            <summary>
                <para>Specify the minimum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetPointMinimumMinValue">
            <summary>
                <para>Specify the minimum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetPointMinimum(System.Int32)">
            <summary>
                <para>Specify the minimum point id for point id selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.ExtentClippingOff">
            <summary>
                <para>Turn on/off selection of geometry via bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.ExtentClippingOn">
            <summary>
                <para>Turn on/off selection of geometry via bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetExtentClipping">
            <summary>
                <para>Turn on/off selection of geometry via bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetExtentClipping(System.Int32)">
            <summary>
                <para>Turn on/off selection of geometry via bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.CellClippingOff">
            <summary>
                <para>Turn on/off selection of geometry by cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.CellClippingOn">
            <summary>
                <para>Turn on/off selection of geometry by cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetCellClipping">
            <summary>
                <para>Turn on/off selection of geometry by cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetCellClipping(System.Int32)">
            <summary>
                <para>Turn on/off selection of geometry by cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.PointClippingOff">
            <summary>
                <para>Turn on/off selection of geometry by point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.PointClippingOn">
            <summary>
                <para>Turn on/off selection of geometry by point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.GetPointClipping">
            <summary>
                <para>Turn on/off selection of geometry by point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeometryFilter.SetPointClipping(System.Int32)">
            <summary>
                <para>Turn on/off selection of geometry by point id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractDataSets.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractDataSets.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractDataSets.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractDataSets.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractDataSets.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractDataSets.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractDataSets.ClearDataSetList">
            <summary>
                <para>Remove all entries from the list of datasets to be extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalDataExtractDataSets.AddDataSet(System.UInt32,System.UInt32)">
            <summary>
                <para>Add a dataset to be extracted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplatesCutter3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplatesCutter3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplatesCutter3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplatesCutter3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplatesCutter3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplatesCutter3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplatesCutter3D.ThreadedExecute(vtk.vtkImageData,vtk.vtkInformation,System.Int32[],System.Int32)">
            <summary>
                <para>Needed by templated functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetArrayComponent">
            <summary>
                <para>Set/get which component of the scalar array to contour on; defaults to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.SetArrayComponent(System.Int32)">
            <summary>
                <para>Set/get which component of the scalar array to contour on; defaults to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetInputMemoryLimit">
            <summary>
                <para>Determines the chunk size fro streaming.  This filter will act like a collector: ask for many input pieces, but generate one output.  Limit is in KBytes</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.SetInputMemoryLimit(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Determines the chunk size fro streaming.  This filter will act like a collector: ask for many input pieces, but generate one output.  Limit is in KBytes</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.ThreadedExecute(vtk.vtkImageData,vtk.vtkInformation,vtk.vtkInformation,System.Int32[],vtk.vtkDataArray)">
            <summary>
                <para>Needed by templated functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetExecuteExtent">
            <summary>
                <para>Needed by templated functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Needed by templated functions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetNumberOfContours">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Get the number of contours in the list of contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetValues(System.Double[])">
            <summary>
                <para>Set the number of contours to place into the list. You only really need to use this method to reduce list size. The method SetValue() will automatically increase list size as needed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetValue(System.Int32)">
            <summary>
                <para>Get a pointer to an array of contour values. There will be GetNumberOfContours() values in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Get the ith contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.ComputeScalarsOff">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.ComputeScalarsOn">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetComputeScalars">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.SetComputeScalars(System.Int32)">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.ComputeGradientsOff">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.ComputeGradientsOn">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetComputeGradients">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.SetComputeGradients(System.Int32)">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSynchronizedTemplates3D.GetMTime">
            <summary>
                <para>Because we delegate to vtkContourValues</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRearrangeFields.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.RemoveOperation(System.String,System.String,System.String,System.String)">
            <summary>
                <para>Remove an operation with the given signature. See AddOperation for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.RemoveOperation(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
                <para>Remove an operation with the given signature. See AddOperation for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.RemoveOperation(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Remove an operation with the given signature. See AddOperation for details.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.RemoveOperation(System.Int32)">
            <summary>
                <para>Remove an operation with the given id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.AddOperation(System.String,System.String,System.String,System.String)">
            <summary>
                <para>Helper method used by other language bindings. Allows the caller to specify arguments as strings instead of enums.Returns an operation id  which can later be used to remove the operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.AddOperation(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
                <para>Add an operation which copies a field (data array) from one field  data to another. Returns an operation id which can later be used to remove the operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRearrangeFields.AddOperation(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Add an operation which copies an attribute's field (data array) from one field data to another. Returns an operation id which can later be used to remove the operation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMaskPoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GenerateVerticesOff">
            <summary>
                <para>Generate output polydata vertices as well as points. A useful convenience method because vertices are drawn (they are topology) while points are not (they are geometry). By default this method is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GenerateVerticesOn">
            <summary>
                <para>Generate output polydata vertices as well as points. A useful convenience method because vertices are drawn (they are topology) while points are not (they are geometry). By default this method is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetGenerateVertices">
            <summary>
                <para>Generate output polydata vertices as well as points. A useful convenience method because vertices are drawn (they are topology) while points are not (they are geometry). By default this method is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.SetGenerateVertices(System.Int32)">
            <summary>
                <para>Generate output polydata vertices as well as points. A useful convenience method because vertices are drawn (they are topology) while points are not (they are geometry). By default this method is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.RandomModeOff">
            <summary>
                <para>Special flag causes randomization of point selection. If this mode is on, statistically every nth point (i.e., OnRatio) will be displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.RandomModeOn">
            <summary>
                <para>Special flag causes randomization of point selection. If this mode is on, statistically every nth point (i.e., OnRatio) will be displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetRandomMode">
            <summary>
                <para>Special flag causes randomization of point selection. If this mode is on, statistically every nth point (i.e., OnRatio) will be displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.SetRandomMode(System.Int32)">
            <summary>
                <para>Special flag causes randomization of point selection. If this mode is on, statistically every nth point (i.e., OnRatio) will be displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetOffset">
            <summary>
                <para>Start with this point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetOffsetMaxValue">
            <summary>
                <para>Start with this point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetOffsetMinValue">
            <summary>
                <para>Start with this point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.SetOffset(System.Int32)">
            <summary>
                <para>Start with this point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetMaximumNumberOfPoints">
            <summary>
                <para>Limit the number of points that can be passed through.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetMaximumNumberOfPointsMaxValue">
            <summary>
                <para>Limit the number of points that can be passed through.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetMaximumNumberOfPointsMinValue">
            <summary>
                <para>Limit the number of points that can be passed through.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.SetMaximumNumberOfPoints(System.Int32)">
            <summary>
                <para>Limit the number of points that can be passed through.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetOnRatio">
            <summary>
                <para>Turn on every nth point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetOnRatioMaxValue">
            <summary>
                <para>Turn on every nth point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.GetOnRatioMinValue">
            <summary>
                <para>Turn on every nth point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMaskPoints.SetOnRatio(System.Int32)">
            <summary>
                <para>Turn on every nth point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.GetColorModeAsString">
            <summary>
                <para>Either color by the input or source scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.SetColorModeToColorBySource">
            <summary>
                <para>Either color by the input or source scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.SetColorModeToColorByInput">
            <summary>
                <para>Either color by the input or source scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.GetColorMode">
            <summary>
                <para>Either color by the input or source scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.SetColorMode(System.Int32)">
            <summary>
                <para>Either color by the input or source scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.GetPointData">
            <summary>
                <para>Get the set of point data attributes for the input. A convenience to the programmer to be used in the GlyphMethod(). Only valid during the Execute() method of this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.GetPoint">
            <summary>
                <para>Get the current point coordinates during processing. Value only valid during the Execute() method of this filter. (Meant to be called by the GlyphMethod().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.GetPointId">
            <summary>
                <para>Get the current point id during processing. Value only valid during the Execute() method of this filter. (Meant to be called by the GlyphMethod().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.GetSource">
            <summary>
                <para>Set/Get the source to use for this glyph.  Note: you can change the source during execution of this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProgrammableGlyphFilter.SetSource(vtk.vtkPolyData)">
            <summary>
                <para>Set/Get the source to use for this glyph.  Note: you can change the source during execution of this filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkThreshold.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkThreshold.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkThreshold.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkThreshold.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkThreshold.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkThreshold.AllScalarsOff">
            <summary>
                <para>If using scalars from point data, all scalars for all points in a cell  must satisfy the threshold criterion if AllScalars is set. Otherwise,  just a single scalar value satisfying the threshold criterion enables will extract the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.AllScalarsOn">
            <summary>
                <para>If using scalars from point data, all scalars for all points in a cell  must satisfy the threshold criterion if AllScalars is set. Otherwise,  just a single scalar value satisfying the threshold criterion enables will extract the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetAllScalars">
            <summary>
                <para>If using scalars from point data, all scalars for all points in a cell  must satisfy the threshold criterion if AllScalars is set. Otherwise,  just a single scalar value satisfying the threshold criterion enables will extract the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetAllScalars(System.Int32)">
            <summary>
                <para>If using scalars from point data, all scalars for all points in a cell  must satisfy the threshold criterion if AllScalars is set. Otherwise,  just a single scalar value satisfying the threshold criterion enables will extract the cell.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetSelectedComponent">
            <summary>
                <para>When the component mode is UseSelected, this ivar indicated the selected component. The default value is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetSelectedComponentMaxValue">
            <summary>
                <para>When the component mode is UseSelected, this ivar indicated the selected component. The default value is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetSelectedComponentMinValue">
            <summary>
                <para>When the component mode is UseSelected, this ivar indicated the selected component. The default value is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetSelectedComponent(System.Int32)">
            <summary>
                <para>When the component mode is UseSelected, this ivar indicated the selected component. The default value is 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetComponentModeAsString">
            <summary>
                <para>Control how the decision of in / out is made with multi-component data. The choices are to use the selected component (specified in the SelectedComponent ivar), or to look at all components. When looking at all components, the evaluation can pass if all the components satisfy the rule (UseAll) or if any satisfy is (UseAny). The default value is UseSelected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetComponentModeToUseAny">
            <summary>
                <para>Control how the decision of in / out is made with multi-component data. The choices are to use the selected component (specified in the SelectedComponent ivar), or to look at all components. When looking at all components, the evaluation can pass if all the components satisfy the rule (UseAll) or if any satisfy is (UseAny). The default value is UseSelected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetComponentModeToUseAll">
            <summary>
                <para>Control how the decision of in / out is made with multi-component data. The choices are to use the selected component (specified in the SelectedComponent ivar), or to look at all components. When looking at all components, the evaluation can pass if all the components satisfy the rule (UseAll) or if any satisfy is (UseAny). The default value is UseSelected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetComponentModeToUseSelected">
            <summary>
                <para>Control how the decision of in / out is made with multi-component data. The choices are to use the selected component (specified in the SelectedComponent ivar), or to look at all components. When looking at all components, the evaluation can pass if all the components satisfy the rule (UseAll) or if any satisfy is (UseAny). The default value is UseSelected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetComponentMode">
            <summary>
                <para>Control how the decision of in / out is made with multi-component data. The choices are to use the selected component (specified in the SelectedComponent ivar), or to look at all components. When looking at all components, the evaluation can pass if all the components satisfy the rule (UseAll) or if any satisfy is (UseAny). The default value is UseSelected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetComponentModeMaxValue">
            <summary>
                <para>Control how the decision of in / out is made with multi-component data. The choices are to use the selected component (specified in the SelectedComponent ivar), or to look at all components. When looking at all components, the evaluation can pass if all the components satisfy the rule (UseAll) or if any satisfy is (UseAny). The default value is UseSelected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetComponentModeMinValue">
            <summary>
                <para>Control how the decision of in / out is made with multi-component data. The choices are to use the selected component (specified in the SelectedComponent ivar), or to look at all components. When looking at all components, the evaluation can pass if all the components satisfy the rule (UseAll) or if any satisfy is (UseAny). The default value is UseSelected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetComponentMode(System.Int32)">
            <summary>
                <para>Control how the decision of in / out is made with multi-component data. The choices are to use the selected component (specified in the SelectedComponent ivar), or to look at all components. When looking at all components, the evaluation can pass if all the components satisfy the rule (UseAll) or if any satisfy is (UseAny). The default value is UseSelected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetAttributeModeAsString">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (AttributeModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetAttributeModeToUseCellData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (AttributeModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetAttributeModeToUsePointData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (AttributeModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetAttributeModeToDefault">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (AttributeModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetAttributeMode">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (AttributeModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.SetAttributeMode(System.Int32)">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (AttributeModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (AttributeModeToUsePointData) or cell data (AttributeModeToUseCellData).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetLowerThreshold">
            <summary>
                <para>Get the Upper and Lower thresholds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.GetUpperThreshold">
            <summary>
                <para>Get the Upper and Lower thresholds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.ThresholdBetween(System.Double,System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are between lower and upper thresholds (inclusive of the end values).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.ThresholdByUpper(System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are greater or equal to upper threshold.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreshold.ThresholdByLower(System.Double)">
            <summary>
                <para>Criterion is cells whose scalars are less or equal to lower threshold.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.IncludeBoundaryOff">
            <summary>
                <para>Control whether to enforce that the "boundary" of the grid is output in the subsampling process. (This ivar only has effect when the SampleRate in any direction is not equal to 1.) When this ivar IncludeBoundary is on, the subsampling will always include the boundary of the grid even though the sample rate is not an even multiple of the grid dimensions. (By default IncludeBoundary is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.IncludeBoundaryOn">
            <summary>
                <para>Control whether to enforce that the "boundary" of the grid is output in the subsampling process. (This ivar only has effect when the SampleRate in any direction is not equal to 1.) When this ivar IncludeBoundary is on, the subsampling will always include the boundary of the grid even though the sample rate is not an even multiple of the grid dimensions. (By default IncludeBoundary is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.GetIncludeBoundary">
            <summary>
                <para>Control whether to enforce that the "boundary" of the grid is output in the subsampling process. (This ivar only has effect when the SampleRate in any direction is not equal to 1.) When this ivar IncludeBoundary is on, the subsampling will always include the boundary of the grid even though the sample rate is not an even multiple of the grid dimensions. (By default IncludeBoundary is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.SetIncludeBoundary(System.Int32)">
            <summary>
                <para>Control whether to enforce that the "boundary" of the grid is output in the subsampling process. (This ivar only has effect when the SampleRate in any direction is not equal to 1.) When this ivar IncludeBoundary is on, the subsampling will always include the boundary of the grid even though the sample rate is not an even multiple of the grid dimensions. (By default IncludeBoundary is off.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.GetSampleRate">
            <summary>
                <para>Set the sampling rate in the i, j, and k directions. If the rate is &gt; 1, then the resulting VOI will be subsampled representation of the input. For example, if the SampleRate=(2,2,2), every other point will be selected, resulting in a volume 1/8th the original size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.SetSampleRate(System.Int32[])">
            <summary>
                <para>Set the sampling rate in the i, j, and k directions. If the rate is &gt; 1, then the resulting VOI will be subsampled representation of the input. For example, if the SampleRate=(2,2,2), every other point will be selected, resulting in a volume 1/8th the original size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.SetSampleRate(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the sampling rate in the i, j, and k directions. If the rate is &gt; 1, then the resulting VOI will be subsampled representation of the input. For example, if the SampleRate=(2,2,2), every other point will be selected, resulting in a volume 1/8th the original size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.GetVOI">
            <summary>
                <para>Specify i-j-k (min,max) pairs to extract. The resulting structured grid dataset can be of any topological dimension (i.e., point, line, plane, or 3D grid). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.SetVOI(System.Int32[])">
            <summary>
                <para>Specify i-j-k (min,max) pairs to extract. The resulting structured grid dataset can be of any topological dimension (i.e., point, line, plane, or 3D grid). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtractRectilinearGrid.SetVOI(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Specify i-j-k (min,max) pairs to extract. The resulting structured grid dataset can be of any topological dimension (i.e., point, line, plane, or 3D grid). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkContourGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkContourGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkContourGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkContourGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkContourGrid.CreateDefaultLocator">
            <summary>
                <para>Create default locator. Used to create one when none is specified. The locator is used to merge coincident points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetLocator">
            <summary>
                <para>Set / get a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.SetLocator(vtk.vtkPointLocator)">
            <summary>
                <para>Set / get a spatial locator for merging points. By default,  an instance of vtkMergePoints is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.UseScalarTreeOff">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.UseScalarTreeOn">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetUseScalarTree">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.SetUseScalarTree(System.Int32)">
            <summary>
                <para>Enable the use of a scalar tree to accelerate contour extraction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.ComputeScalarsOff">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.ComputeScalarsOn">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetComputeScalars">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.SetComputeScalars(System.Int32)">
            <summary>
                <para>Set/Get the computation of scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.ComputeGradientsOff">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.ComputeGradientsOn">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetComputeGradients">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.SetComputeGradients(System.Int32)">
            <summary>
                <para>Set/Get the computation of gradients. Gradient computation is fairly expensive in both time and storage. Note that if ComputeNormals is on, gradients will have to be calculated, but will not be stored in the output dataset.  If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. Normal computation is fairly expensive in both time and storage. If the output data will be processed by filters that modify topology or geometry, it may be wise to turn Normals and Gradients off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetMTime">
            <summary>
                <para>Modified GetMTime Because we delegate to vtkContourValues</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetNumberOfContours">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetValues(System.Double[])">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.GetValue(System.Int32)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourGrid.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Methods to set / get contour values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.SetExtent(System.Int32[])">
            <summary>
                <para>Specify (imin,imax, jmin,jmax, kmin,kmax) indices in array form.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.SetExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Specify (imin,imax, jmin,jmax, kmin,kmax) indices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRectilinearGridGeometryFilter.GetExtent">
            <summary>
                <para>Get the extent in topological coordinate range (imin,imax, jmin,jmax, kmin,kmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.SetExtent(System.Int32[])">
            <summary>
                <para>Specify (imin,imax, jmin,jmax, kmin,kmax) indices in array form.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.SetExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Specify (imin,imax, jmin,jmax, kmin,kmax) indices.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredGridGeometryFilter.GetExtent">
            <summary>
                <para>Get the extent in topological coordinate range (imin,imax, jmin,jmax, kmin,kmax).</para>
            </summary>
        </member>
    </members>
</doc>